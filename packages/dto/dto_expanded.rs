#![feature(prelude_import)]
#[prelude_import]
use std::prelude::rust_2024::*;
#[macro_use]
extern crate std;
pub mod asset {
    use by_macros::api_model;
    use dioxus_translate::Translate;
    use crate::Error;
    /// AssetPresignedUris is a generated struct that represents the model
    ///
    /// For making API calls related to this model, use `AssetPresignedUris::get_client(endpoint: &str)`.
    /// It will returns AssetPresignedUrisClient struct that implements the API calls.
    ///
    /// In server side, you can use `AssetPresignedUris::get_repository()` to interact with the database.
    /// Recommend to use `AssetPresignedUrisRepository` to insert or update the model.
    /// To query the model, use `AssetPresignedUris::query_builder()`.
    /// For more detail, refer to the documentation of the query builder.
    pub struct AssetPresignedUris {
        pub presigned_uris: Vec<String>,
        pub uris: Vec<String>,
        pub total_count: usize,
        pub file_type: FileType,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for AssetPresignedUris {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field4_finish(
                f,
                "AssetPresignedUris",
                "presigned_uris",
                &self.presigned_uris,
                "uris",
                &self.uris,
                "total_count",
                &self.total_count,
                "file_type",
                &&self.file_type,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for AssetPresignedUris {
        #[inline]
        fn clone(&self) -> AssetPresignedUris {
            AssetPresignedUris {
                presigned_uris: ::core::clone::Clone::clone(&self.presigned_uris),
                uris: ::core::clone::Clone::clone(&self.uris),
                total_count: ::core::clone::Clone::clone(&self.total_count),
                file_type: ::core::clone::Clone::clone(&self.file_type),
            }
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for AssetPresignedUris {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "presigned_uris" => _serde::__private::Ok(__Field::__field0),
                            "uris" => _serde::__private::Ok(__Field::__field1),
                            "total_count" => _serde::__private::Ok(__Field::__field2),
                            "file_type" => _serde::__private::Ok(__Field::__field3),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"presigned_uris" => _serde::__private::Ok(__Field::__field0),
                            b"uris" => _serde::__private::Ok(__Field::__field1),
                            b"total_count" => _serde::__private::Ok(__Field::__field2),
                            b"file_type" => _serde::__private::Ok(__Field::__field3),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<AssetPresignedUris>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = AssetPresignedUris;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct AssetPresignedUris",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            Vec<String>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct AssetPresignedUris with 4 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            Vec<String>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct AssetPresignedUris with 4 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match _serde::de::SeqAccess::next_element::<
                            usize,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct AssetPresignedUris with 4 elements",
                                    ),
                                );
                            }
                        };
                        let __field3 = match _serde::de::SeqAccess::next_element::<
                            FileType,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        3usize,
                                        &"struct AssetPresignedUris with 4 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(AssetPresignedUris {
                            presigned_uris: __field0,
                            uris: __field1,
                            total_count: __field2,
                            file_type: __field3,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<Vec<String>> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<Vec<String>> = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<usize> = _serde::__private::None;
                        let mut __field3: _serde::__private::Option<FileType> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "presigned_uris",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Vec<String>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("uris"),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Vec<String>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "total_count",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<usize>(&mut __map)?,
                                    );
                                }
                                __Field::__field3 => {
                                    if _serde::__private::Option::is_some(&__field3) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "file_type",
                                            ),
                                        );
                                    }
                                    __field3 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<FileType>(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("presigned_uris")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("uris")?
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("total_count")?
                            }
                        };
                        let __field3 = match __field3 {
                            _serde::__private::Some(__field3) => __field3,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("file_type")?
                            }
                        };
                        _serde::__private::Ok(AssetPresignedUris {
                            presigned_uris: __field0,
                            uris: __field1,
                            total_count: __field2,
                            file_type: __field3,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "presigned_uris",
                    "uris",
                    "total_count",
                    "file_type",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "AssetPresignedUris",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<AssetPresignedUris>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for AssetPresignedUris {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "AssetPresignedUris",
                    false as usize + 1 + 1 + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "presigned_uris",
                    &self.presigned_uris,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "uris",
                    &self.uris,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "total_count",
                    &self.total_count,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "file_type",
                    &self.file_type,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[automatically_derived]
    impl ::core::default::Default for AssetPresignedUris {
        #[inline]
        fn default() -> AssetPresignedUris {
            AssetPresignedUris {
                presigned_uris: ::core::default::Default::default(),
                uris: ::core::default::Default::default(),
                total_count: ::core::default::Default::default(),
                file_type: ::core::default::Default::default(),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for AssetPresignedUris {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for AssetPresignedUris {
        #[inline]
        fn eq(&self, other: &AssetPresignedUris) -> bool {
            self.presigned_uris == other.presigned_uris && self.uris == other.uris
                && self.total_count == other.total_count
                && self.file_type == other.file_type
        }
    }
    pub struct AssetPresignedUrisSummary {}
    #[automatically_derived]
    impl ::core::fmt::Debug for AssetPresignedUrisSummary {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "AssetPresignedUrisSummary")
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for AssetPresignedUrisSummary {
        #[inline]
        fn clone(&self) -> AssetPresignedUrisSummary {
            AssetPresignedUrisSummary {}
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for AssetPresignedUrisSummary {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "AssetPresignedUrisSummary",
                    false as usize,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for AssetPresignedUrisSummary {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<AssetPresignedUrisSummary>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = AssetPresignedUrisSummary;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct AssetPresignedUrisSummary",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        _: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        _serde::__private::Ok(AssetPresignedUrisSummary {})
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        _serde::__private::Ok(AssetPresignedUrisSummary {})
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "AssetPresignedUrisSummary",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<
                            AssetPresignedUrisSummary,
                        >,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::default::Default for AssetPresignedUrisSummary {
        #[inline]
        fn default() -> AssetPresignedUrisSummary {
            AssetPresignedUrisSummary {}
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for AssetPresignedUrisSummary {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for AssetPresignedUrisSummary {
        #[inline]
        fn eq(&self, other: &AssetPresignedUrisSummary) -> bool {
            true
        }
    }
    impl From<AssetPresignedUris> for AssetPresignedUrisSummary {
        fn from(item: AssetPresignedUris) -> Self {
            Self {}
        }
    }
    impl Into<AssetPresignedUris> for AssetPresignedUrisSummary {
        fn into(self) -> AssetPresignedUris {
            AssetPresignedUris {
                ..Default::default()
            }
        }
    }
    #[serde(rename_all = "kebab-case")]
    pub struct AssetPresignedUrisQuery {
        #[serde(deserialize_with = "parse_size_of_asset_presigned_uris_query", default)]
        pub size: usize,
        pub bookmark: Option<String>,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for AssetPresignedUrisQuery {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(
                f,
                "AssetPresignedUrisQuery",
                "size",
                &self.size,
                "bookmark",
                &&self.bookmark,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for AssetPresignedUrisQuery {
        #[inline]
        fn clone(&self) -> AssetPresignedUrisQuery {
            AssetPresignedUrisQuery {
                size: ::core::clone::Clone::clone(&self.size),
                bookmark: ::core::clone::Clone::clone(&self.bookmark),
            }
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for AssetPresignedUrisQuery {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "AssetPresignedUrisQuery",
                    false as usize + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "size",
                    &self.size,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "bookmark",
                    &self.bookmark,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for AssetPresignedUrisQuery {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "size" => _serde::__private::Ok(__Field::__field0),
                            "bookmark" => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"size" => _serde::__private::Ok(__Field::__field0),
                            b"bookmark" => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<AssetPresignedUrisQuery>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = AssetPresignedUrisQuery;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct AssetPresignedUrisQuery",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match {
                            #[doc(hidden)]
                            struct __DeserializeWith<'de> {
                                value: usize,
                                phantom: _serde::__private::PhantomData<
                                    AssetPresignedUrisQuery,
                                >,
                                lifetime: _serde::__private::PhantomData<&'de ()>,
                            }
                            #[automatically_derived]
                            impl<'de> _serde::Deserialize<'de>
                            for __DeserializeWith<'de> {
                                fn deserialize<__D>(
                                    __deserializer: __D,
                                ) -> _serde::__private::Result<Self, __D::Error>
                                where
                                    __D: _serde::Deserializer<'de>,
                                {
                                    _serde::__private::Ok(__DeserializeWith {
                                        value: parse_size_of_asset_presigned_uris_query(
                                            __deserializer,
                                        )?,
                                        phantom: _serde::__private::PhantomData,
                                        lifetime: _serde::__private::PhantomData,
                                    })
                                }
                            }
                            _serde::__private::Option::map(
                                _serde::de::SeqAccess::next_element::<
                                    __DeserializeWith<'de>,
                                >(&mut __seq)?,
                                |__wrap| __wrap.value,
                            )
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                _serde::__private::Default::default()
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            Option<String>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct AssetPresignedUrisQuery with 2 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(AssetPresignedUrisQuery {
                            size: __field0,
                            bookmark: __field1,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<usize> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<Option<String>> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("size"),
                                        );
                                    }
                                    __field0 = _serde::__private::Some({
                                        #[doc(hidden)]
                                        struct __DeserializeWith<'de> {
                                            value: usize,
                                            phantom: _serde::__private::PhantomData<
                                                AssetPresignedUrisQuery,
                                            >,
                                            lifetime: _serde::__private::PhantomData<&'de ()>,
                                        }
                                        #[automatically_derived]
                                        impl<'de> _serde::Deserialize<'de>
                                        for __DeserializeWith<'de> {
                                            fn deserialize<__D>(
                                                __deserializer: __D,
                                            ) -> _serde::__private::Result<Self, __D::Error>
                                            where
                                                __D: _serde::Deserializer<'de>,
                                            {
                                                _serde::__private::Ok(__DeserializeWith {
                                                    value: parse_size_of_asset_presigned_uris_query(
                                                        __deserializer,
                                                    )?,
                                                    phantom: _serde::__private::PhantomData,
                                                    lifetime: _serde::__private::PhantomData,
                                                })
                                            }
                                        }
                                        match _serde::de::MapAccess::next_value::<
                                            __DeserializeWith<'de>,
                                        >(&mut __map) {
                                            _serde::__private::Ok(__wrapper) => __wrapper.value,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        }
                                    });
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "bookmark",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<String>,
                                        >(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::Default::default()
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("bookmark")?
                            }
                        };
                        _serde::__private::Ok(AssetPresignedUrisQuery {
                            size: __field0,
                            bookmark: __field1,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &["size", "bookmark"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "AssetPresignedUrisQuery",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<
                            AssetPresignedUrisQuery,
                        >,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::default::Default for AssetPresignedUrisQuery {
        #[inline]
        fn default() -> AssetPresignedUrisQuery {
            AssetPresignedUrisQuery {
                size: ::core::default::Default::default(),
                bookmark: ::core::default::Default::default(),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for AssetPresignedUrisQuery {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for AssetPresignedUrisQuery {
        #[inline]
        fn eq(&self, other: &AssetPresignedUrisQuery) -> bool {
            self.size == other.size && self.bookmark == other.bookmark
        }
    }
    impl std::fmt::Display for AssetPresignedUrisQuery {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let query = serde_urlencoded::to_string(&self).map_err(|_| std::fmt::Error)?;
            f.write_fmt(format_args!("{0}", query))
        }
    }
    pub fn parse_size_of_asset_presigned_uris_query<'de, D>(
        deserializer: D,
    ) -> std::result::Result<usize, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::Deserialize;
        let s: Option<String> = Option::deserialize(deserializer)?;
        s.unwrap_or_else(|| Default::default())
            .parse::<usize>()
            .map_err(serde::de::Error::custom)
    }
    impl AssetPresignedUrisQuery {
        pub fn new(size: usize) -> Self {
            Self { size, ..Self::default() }
        }
        pub fn with_bookmark(mut self, bookmark: String) -> Self {
            self.bookmark = Some(bookmark);
            self
        }
        pub fn with_page(mut self, page: usize) -> Self {
            self.bookmark = Some(page.to_string());
            self
        }
        /// Returns the size(i32) of the query
        pub fn size(&self) -> i32 {
            self.size as i32
        }
        pub fn page(&self) -> i32 {
            self.bookmark.as_ref().unwrap_or(&"1".to_string()).parse().unwrap_or(1)
        }
    }
    impl AssetPresignedUrisClient {}
    impl AssetPresignedUris {
        pub fn get_client(endpoint: &str) -> AssetPresignedUrisClient {
            AssetPresignedUrisClient {
                endpoint: endpoint.to_string(),
            }
        }
    }
    pub struct AssetPresignedUrisClient {
        pub endpoint: String,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for AssetPresignedUrisClient {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field1_finish(
                f,
                "AssetPresignedUrisClient",
                "endpoint",
                &&self.endpoint,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for AssetPresignedUrisClient {
        #[inline]
        fn clone(&self) -> AssetPresignedUrisClient {
            AssetPresignedUrisClient {
                endpoint: ::core::clone::Clone::clone(&self.endpoint),
            }
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for AssetPresignedUrisClient {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "AssetPresignedUrisClient",
                    false as usize + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "endpoint",
                    &self.endpoint,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for AssetPresignedUrisClient {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "endpoint" => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"endpoint" => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<AssetPresignedUrisClient>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = AssetPresignedUrisClient;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct AssetPresignedUrisClient",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct AssetPresignedUrisClient with 1 element",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(AssetPresignedUrisClient {
                            endpoint: __field0,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "endpoint",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("endpoint")?
                            }
                        };
                        _serde::__private::Ok(AssetPresignedUrisClient {
                            endpoint: __field0,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &["endpoint"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "AssetPresignedUrisClient",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<
                            AssetPresignedUrisClient,
                        >,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::default::Default for AssetPresignedUrisClient {
        #[inline]
        fn default() -> AssetPresignedUrisClient {
            AssetPresignedUrisClient {
                endpoint: ::core::default::Default::default(),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for AssetPresignedUrisClient {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for AssetPresignedUrisClient {
        #[inline]
        fn eq(&self, other: &AssetPresignedUrisClient) -> bool {
            self.endpoint == other.endpoint
        }
    }
    impl AssetPresignedUrisClient {
        pub async fn query(
            &self,
            params: AssetPresignedUrisQuery,
        ) -> crate::Result<by_types::QueryResponse<AssetPresignedUrisSummary>> {
            let path = ::alloc::__export::must_use({
                let res = ::alloc::fmt::format(format_args!("/v1/assets"));
                res
            });
            let endpoint = ::alloc::__export::must_use({
                let res = ::alloc::fmt::format(
                    format_args!("{0}{1}", self.endpoint, path),
                );
                res
            });
            let query = ::alloc::__export::must_use({
                let res = ::alloc::fmt::format(
                    format_args!(
                        "{0}?{1}",
                        endpoint,
                        AssetPresignedUrisParam::Query(params),
                    ),
                );
                res
            });
            rest_api::get(&query).await
        }
        pub async fn get(&self, id: i64) -> crate::Result<AssetPresignedUris> {
            let path = ::alloc::__export::must_use({
                let res = ::alloc::fmt::format(format_args!("/v1/assets"));
                res
            });
            let endpoint = ::alloc::__export::must_use({
                let res = ::alloc::fmt::format(
                    format_args!("{0}{1}/{2}", self.endpoint, path, id),
                );
                res
            });
            rest_api::get(&endpoint).await
        }
    }
    impl AssetPresignedUris {
        pub fn url() -> String {
            "/v1/assets".to_string()
        }
    }
    pub struct AssetPresignedUrisReadAction {
        pub action: Option<AssetPresignedUrisReadActionType>,
        #[serde(
            deserialize_with = "parse_total_count_of_asset_presigned_uris_read",
            default
        )]
        pub total_count: Option<usize>,
        #[serde(
            deserialize_with = "parse_file_type_of_asset_presigned_uris_read",
            default
        )]
        pub file_type: Option<FileType>,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for AssetPresignedUrisReadAction {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "AssetPresignedUrisReadAction",
                "action",
                &self.action,
                "total_count",
                &self.total_count,
                "file_type",
                &&self.file_type,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for AssetPresignedUrisReadAction {
        #[inline]
        fn clone(&self) -> AssetPresignedUrisReadAction {
            AssetPresignedUrisReadAction {
                action: ::core::clone::Clone::clone(&self.action),
                total_count: ::core::clone::Clone::clone(&self.total_count),
                file_type: ::core::clone::Clone::clone(&self.file_type),
            }
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for AssetPresignedUrisReadAction {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "AssetPresignedUrisReadAction",
                    false as usize + 1 + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "action",
                    &self.action,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "total_count",
                    &self.total_count,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "file_type",
                    &self.file_type,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for AssetPresignedUrisReadAction {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "action" => _serde::__private::Ok(__Field::__field0),
                            "total_count" => _serde::__private::Ok(__Field::__field1),
                            "file_type" => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"action" => _serde::__private::Ok(__Field::__field0),
                            b"total_count" => _serde::__private::Ok(__Field::__field1),
                            b"file_type" => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<AssetPresignedUrisReadAction>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = AssetPresignedUrisReadAction;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct AssetPresignedUrisReadAction",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            Option<AssetPresignedUrisReadActionType>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct AssetPresignedUrisReadAction with 3 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match {
                            #[doc(hidden)]
                            struct __DeserializeWith<'de> {
                                value: Option<usize>,
                                phantom: _serde::__private::PhantomData<
                                    AssetPresignedUrisReadAction,
                                >,
                                lifetime: _serde::__private::PhantomData<&'de ()>,
                            }
                            #[automatically_derived]
                            impl<'de> _serde::Deserialize<'de>
                            for __DeserializeWith<'de> {
                                fn deserialize<__D>(
                                    __deserializer: __D,
                                ) -> _serde::__private::Result<Self, __D::Error>
                                where
                                    __D: _serde::Deserializer<'de>,
                                {
                                    _serde::__private::Ok(__DeserializeWith {
                                        value: parse_total_count_of_asset_presigned_uris_read(
                                            __deserializer,
                                        )?,
                                        phantom: _serde::__private::PhantomData,
                                        lifetime: _serde::__private::PhantomData,
                                    })
                                }
                            }
                            _serde::__private::Option::map(
                                _serde::de::SeqAccess::next_element::<
                                    __DeserializeWith<'de>,
                                >(&mut __seq)?,
                                |__wrap| __wrap.value,
                            )
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                _serde::__private::Default::default()
                            }
                        };
                        let __field2 = match {
                            #[doc(hidden)]
                            struct __DeserializeWith<'de> {
                                value: Option<FileType>,
                                phantom: _serde::__private::PhantomData<
                                    AssetPresignedUrisReadAction,
                                >,
                                lifetime: _serde::__private::PhantomData<&'de ()>,
                            }
                            #[automatically_derived]
                            impl<'de> _serde::Deserialize<'de>
                            for __DeserializeWith<'de> {
                                fn deserialize<__D>(
                                    __deserializer: __D,
                                ) -> _serde::__private::Result<Self, __D::Error>
                                where
                                    __D: _serde::Deserializer<'de>,
                                {
                                    _serde::__private::Ok(__DeserializeWith {
                                        value: parse_file_type_of_asset_presigned_uris_read(
                                            __deserializer,
                                        )?,
                                        phantom: _serde::__private::PhantomData,
                                        lifetime: _serde::__private::PhantomData,
                                    })
                                }
                            }
                            _serde::__private::Option::map(
                                _serde::de::SeqAccess::next_element::<
                                    __DeserializeWith<'de>,
                                >(&mut __seq)?,
                                |__wrap| __wrap.value,
                            )
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                _serde::__private::Default::default()
                            }
                        };
                        _serde::__private::Ok(AssetPresignedUrisReadAction {
                            action: __field0,
                            total_count: __field1,
                            file_type: __field2,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<
                            Option<AssetPresignedUrisReadActionType>,
                        > = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<Option<usize>> = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<Option<FileType>> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("action"),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<AssetPresignedUrisReadActionType>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "total_count",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some({
                                        #[doc(hidden)]
                                        struct __DeserializeWith<'de> {
                                            value: Option<usize>,
                                            phantom: _serde::__private::PhantomData<
                                                AssetPresignedUrisReadAction,
                                            >,
                                            lifetime: _serde::__private::PhantomData<&'de ()>,
                                        }
                                        #[automatically_derived]
                                        impl<'de> _serde::Deserialize<'de>
                                        for __DeserializeWith<'de> {
                                            fn deserialize<__D>(
                                                __deserializer: __D,
                                            ) -> _serde::__private::Result<Self, __D::Error>
                                            where
                                                __D: _serde::Deserializer<'de>,
                                            {
                                                _serde::__private::Ok(__DeserializeWith {
                                                    value: parse_total_count_of_asset_presigned_uris_read(
                                                        __deserializer,
                                                    )?,
                                                    phantom: _serde::__private::PhantomData,
                                                    lifetime: _serde::__private::PhantomData,
                                                })
                                            }
                                        }
                                        match _serde::de::MapAccess::next_value::<
                                            __DeserializeWith<'de>,
                                        >(&mut __map) {
                                            _serde::__private::Ok(__wrapper) => __wrapper.value,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        }
                                    });
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "file_type",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::__private::Some({
                                        #[doc(hidden)]
                                        struct __DeserializeWith<'de> {
                                            value: Option<FileType>,
                                            phantom: _serde::__private::PhantomData<
                                                AssetPresignedUrisReadAction,
                                            >,
                                            lifetime: _serde::__private::PhantomData<&'de ()>,
                                        }
                                        #[automatically_derived]
                                        impl<'de> _serde::Deserialize<'de>
                                        for __DeserializeWith<'de> {
                                            fn deserialize<__D>(
                                                __deserializer: __D,
                                            ) -> _serde::__private::Result<Self, __D::Error>
                                            where
                                                __D: _serde::Deserializer<'de>,
                                            {
                                                _serde::__private::Ok(__DeserializeWith {
                                                    value: parse_file_type_of_asset_presigned_uris_read(
                                                        __deserializer,
                                                    )?,
                                                    phantom: _serde::__private::PhantomData,
                                                    lifetime: _serde::__private::PhantomData,
                                                })
                                            }
                                        }
                                        match _serde::de::MapAccess::next_value::<
                                            __DeserializeWith<'de>,
                                        >(&mut __map) {
                                            _serde::__private::Ok(__wrapper) => __wrapper.value,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        }
                                    });
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("action")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::Default::default()
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                _serde::__private::Default::default()
                            }
                        };
                        _serde::__private::Ok(AssetPresignedUrisReadAction {
                            action: __field0,
                            total_count: __field1,
                            file_type: __field2,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "action",
                    "total_count",
                    "file_type",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "AssetPresignedUrisReadAction",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<
                            AssetPresignedUrisReadAction,
                        >,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::default::Default for AssetPresignedUrisReadAction {
        #[inline]
        fn default() -> AssetPresignedUrisReadAction {
            AssetPresignedUrisReadAction {
                action: ::core::default::Default::default(),
                total_count: ::core::default::Default::default(),
                file_type: ::core::default::Default::default(),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for AssetPresignedUrisReadAction {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for AssetPresignedUrisReadAction {
        #[inline]
        fn eq(&self, other: &AssetPresignedUrisReadAction) -> bool {
            self.action == other.action && self.total_count == other.total_count
                && self.file_type == other.file_type
        }
    }
    impl std::fmt::Display for AssetPresignedUrisReadAction {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let query = serde_urlencoded::to_string(&self).map_err(|_| std::fmt::Error)?;
            f.write_fmt(format_args!("{0}", query))
        }
    }
    pub fn parse_total_count_of_asset_presigned_uris_read<'de, D>(
        deserializer: D,
    ) -> std::result::Result<Option<usize>, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::Deserialize;
        let s: Option<String> = Option::deserialize(deserializer)?;
        match s {
            Some(s) => s.parse::<usize>().map_err(serde::de::Error::custom).map(Some),
            None => Ok(None),
        }
    }
    pub fn parse_file_type_of_asset_presigned_uris_read<'de, D>(
        deserializer: D,
    ) -> std::result::Result<Option<FileType>, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::Deserialize;
        let s: Option<String> = Option::deserialize(deserializer)?;
        match s {
            Some(s) => s.parse::<FileType>().map_err(serde::de::Error::custom).map(Some),
            None => Ok(None),
        }
    }
    impl AssetPresignedUrisReadAction {
        pub fn new() -> Self {
            Self::default()
        }
        pub fn get_presigned_uris(
            mut self,
            total_count: usize,
            file_type: FileType,
        ) -> Self {
            self.total_count = Some(total_count);
            self.file_type = Some(file_type);
            self.action = Some(AssetPresignedUrisReadActionType::GetPresignedUris);
            self
        }
    }
    #[serde(rename_all = "kebab-case")]
    pub enum AssetPresignedUrisReadActionType {
        GetPresignedUris,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for AssetPresignedUrisReadActionType {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "GetPresignedUris")
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for AssetPresignedUrisReadActionType {
        #[inline]
        fn clone(&self) -> AssetPresignedUrisReadActionType {
            AssetPresignedUrisReadActionType::GetPresignedUris
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for AssetPresignedUrisReadActionType {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for AssetPresignedUrisReadActionType {
        #[inline]
        fn eq(&self, other: &AssetPresignedUrisReadActionType) -> bool {
            true
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for AssetPresignedUrisReadActionType {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    AssetPresignedUrisReadActionType::GetPresignedUris => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "AssetPresignedUrisReadActionType",
                            0u32,
                            "get-presigned-uris",
                        )
                    }
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for AssetPresignedUrisReadActionType {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "variant identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::invalid_value(
                                        _serde::de::Unexpected::Unsigned(__value),
                                        &"variant index 0 <= i < 1",
                                    ),
                                )
                            }
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "get-presigned-uris" => {
                                _serde::__private::Ok(__Field::__field0)
                            }
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"get-presigned-uris" => {
                                _serde::__private::Ok(__Field::__field0)
                            }
                            _ => {
                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<
                        AssetPresignedUrisReadActionType,
                    >,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = AssetPresignedUrisReadActionType;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "enum AssetPresignedUrisReadActionType",
                        )
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match _serde::de::EnumAccess::variant(__data)? {
                            (__Field::__field0, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(
                                    AssetPresignedUrisReadActionType::GetPresignedUris,
                                )
                            }
                        }
                    }
                }
                #[doc(hidden)]
                const VARIANTS: &'static [&'static str] = &["get-presigned-uris"];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "AssetPresignedUrisReadActionType",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<
                            AssetPresignedUrisReadActionType,
                        >,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    impl AssetPresignedUrisClient {
        pub async fn get_presigned_uris(
            &self,
            total_count: usize,
            file_type: FileType,
        ) -> crate::Result<AssetPresignedUris> {
            let path = ::alloc::__export::must_use({
                let res = ::alloc::fmt::format(format_args!("/v1/assets"));
                res
            });
            let endpoint = ::alloc::__export::must_use({
                let res = ::alloc::fmt::format(
                    format_args!("{0}{1}", self.endpoint, path),
                );
                res
            });
            let params = AssetPresignedUrisReadAction::new()
                .get_presigned_uris(total_count, file_type);
            let query = ::alloc::__export::must_use({
                let res = ::alloc::fmt::format(
                    format_args!(
                        "{0}?{1}",
                        endpoint,
                        AssetPresignedUrisParam::Read(params),
                    ),
                );
                res
            });
            rest_api::get(&query).await
        }
    }
    #[serde(tag = "param-type", rename_all = "kebab-case")]
    pub enum AssetPresignedUrisParam {
        Query(AssetPresignedUrisQuery),
        Read(AssetPresignedUrisReadAction),
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for AssetPresignedUrisParam {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                AssetPresignedUrisParam::Query(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Query",
                        &__self_0,
                    )
                }
                AssetPresignedUrisParam::Read(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Read",
                        &__self_0,
                    )
                }
            }
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for AssetPresignedUrisParam {
        #[inline]
        fn clone(&self) -> AssetPresignedUrisParam {
            match self {
                AssetPresignedUrisParam::Query(__self_0) => {
                    AssetPresignedUrisParam::Query(::core::clone::Clone::clone(__self_0))
                }
                AssetPresignedUrisParam::Read(__self_0) => {
                    AssetPresignedUrisParam::Read(::core::clone::Clone::clone(__self_0))
                }
            }
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for AssetPresignedUrisParam {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    AssetPresignedUrisParam::Query(ref __field0) => {
                        _serde::__private::ser::serialize_tagged_newtype(
                            __serializer,
                            "AssetPresignedUrisParam",
                            "Query",
                            "param-type",
                            "query",
                            __field0,
                        )
                    }
                    AssetPresignedUrisParam::Read(ref __field0) => {
                        _serde::__private::ser::serialize_tagged_newtype(
                            __serializer,
                            "AssetPresignedUrisParam",
                            "Read",
                            "param-type",
                            "read",
                            __field0,
                        )
                    }
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for AssetPresignedUrisParam {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "variant identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::invalid_value(
                                        _serde::de::Unexpected::Unsigned(__value),
                                        &"variant index 0 <= i < 2",
                                    ),
                                )
                            }
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "query" => _serde::__private::Ok(__Field::__field0),
                            "read" => _serde::__private::Ok(__Field::__field1),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"query" => _serde::__private::Ok(__Field::__field0),
                            b"read" => _serde::__private::Ok(__Field::__field1),
                            _ => {
                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                const VARIANTS: &'static [&'static str] = &["query", "read"];
                let (__tag, __content) = _serde::Deserializer::deserialize_any(
                    __deserializer,
                    _serde::__private::de::TaggedContentVisitor::<
                        __Field,
                    >::new(
                        "param-type",
                        "internally tagged enum AssetPresignedUrisParam",
                    ),
                )?;
                let __deserializer = _serde::__private::de::ContentDeserializer::<
                    __D::Error,
                >::new(__content);
                match __tag {
                    __Field::__field0 => {
                        _serde::__private::Result::map(
                            <AssetPresignedUrisQuery as _serde::Deserialize>::deserialize(
                                __deserializer,
                            ),
                            AssetPresignedUrisParam::Query,
                        )
                    }
                    __Field::__field1 => {
                        _serde::__private::Result::map(
                            <AssetPresignedUrisReadAction as _serde::Deserialize>::deserialize(
                                __deserializer,
                            ),
                            AssetPresignedUrisParam::Read,
                        )
                    }
                }
            }
        }
    };
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for AssetPresignedUrisParam {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for AssetPresignedUrisParam {
        #[inline]
        fn eq(&self, other: &AssetPresignedUrisParam) -> bool {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            let __arg1_discr = ::core::intrinsics::discriminant_value(other);
            __self_discr == __arg1_discr
                && match (self, other) {
                    (
                        AssetPresignedUrisParam::Query(__self_0),
                        AssetPresignedUrisParam::Query(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (
                        AssetPresignedUrisParam::Read(__self_0),
                        AssetPresignedUrisParam::Read(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    _ => unsafe { ::core::intrinsics::unreachable() }
                }
        }
    }
    impl std::fmt::Display for AssetPresignedUrisParam {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let query = serde_urlencoded::to_string(&self).map_err(|_| std::fmt::Error)?;
            f.write_fmt(format_args!("{0}", query))
        }
    }
    #[serde(tag = "param_type")]
    #[serde(rename_all = "snake_case")]
    pub enum AssetPresignedUrisGetResponse {
        Query(by_types::QueryResponse<AssetPresignedUris>),
        Read(AssetPresignedUris),
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for AssetPresignedUrisGetResponse {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                AssetPresignedUrisGetResponse::Query(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Query",
                        &__self_0,
                    )
                }
                AssetPresignedUrisGetResponse::Read(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Read",
                        &__self_0,
                    )
                }
            }
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for AssetPresignedUrisGetResponse {
        #[inline]
        fn clone(&self) -> AssetPresignedUrisGetResponse {
            match self {
                AssetPresignedUrisGetResponse::Query(__self_0) => {
                    AssetPresignedUrisGetResponse::Query(
                        ::core::clone::Clone::clone(__self_0),
                    )
                }
                AssetPresignedUrisGetResponse::Read(__self_0) => {
                    AssetPresignedUrisGetResponse::Read(
                        ::core::clone::Clone::clone(__self_0),
                    )
                }
            }
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for AssetPresignedUrisGetResponse {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    AssetPresignedUrisGetResponse::Query(ref __field0) => {
                        _serde::__private::ser::serialize_tagged_newtype(
                            __serializer,
                            "AssetPresignedUrisGetResponse",
                            "Query",
                            "param_type",
                            "query",
                            __field0,
                        )
                    }
                    AssetPresignedUrisGetResponse::Read(ref __field0) => {
                        _serde::__private::ser::serialize_tagged_newtype(
                            __serializer,
                            "AssetPresignedUrisGetResponse",
                            "Read",
                            "param_type",
                            "read",
                            __field0,
                        )
                    }
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for AssetPresignedUrisGetResponse {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "variant identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::invalid_value(
                                        _serde::de::Unexpected::Unsigned(__value),
                                        &"variant index 0 <= i < 2",
                                    ),
                                )
                            }
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "query" => _serde::__private::Ok(__Field::__field0),
                            "read" => _serde::__private::Ok(__Field::__field1),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"query" => _serde::__private::Ok(__Field::__field0),
                            b"read" => _serde::__private::Ok(__Field::__field1),
                            _ => {
                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                const VARIANTS: &'static [&'static str] = &["query", "read"];
                let (__tag, __content) = _serde::Deserializer::deserialize_any(
                    __deserializer,
                    _serde::__private::de::TaggedContentVisitor::<
                        __Field,
                    >::new(
                        "param_type",
                        "internally tagged enum AssetPresignedUrisGetResponse",
                    ),
                )?;
                let __deserializer = _serde::__private::de::ContentDeserializer::<
                    __D::Error,
                >::new(__content);
                match __tag {
                    __Field::__field0 => {
                        _serde::__private::Result::map(
                            <by_types::QueryResponse<
                                AssetPresignedUris,
                            > as _serde::Deserialize>::deserialize(__deserializer),
                            AssetPresignedUrisGetResponse::Query,
                        )
                    }
                    __Field::__field1 => {
                        _serde::__private::Result::map(
                            <AssetPresignedUris as _serde::Deserialize>::deserialize(
                                __deserializer,
                            ),
                            AssetPresignedUrisGetResponse::Read,
                        )
                    }
                }
            }
        }
    };
    pub struct File {
        pub name: String,
        pub ext: String,
        pub url: Option<String>,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for File {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "File",
                "name",
                &self.name,
                "ext",
                &self.ext,
                "url",
                &&self.url,
            )
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for File {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "File",
                    false as usize + 1 + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "name",
                    &self.name,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "ext",
                    &self.ext,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "url",
                    &self.url,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for File {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "name" => _serde::__private::Ok(__Field::__field0),
                            "ext" => _serde::__private::Ok(__Field::__field1),
                            "url" => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"name" => _serde::__private::Ok(__Field::__field0),
                            b"ext" => _serde::__private::Ok(__Field::__field1),
                            b"url" => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<File>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = File;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct File",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct File with 3 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct File with 3 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match _serde::de::SeqAccess::next_element::<
                            Option<String>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct File with 3 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(File {
                            name: __field0,
                            ext: __field1,
                            url: __field2,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<Option<String>> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("name"),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("ext"),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("url"),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<String>,
                                        >(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("name")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("ext")?
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("url")?
                            }
                        };
                        _serde::__private::Ok(File {
                            name: __field0,
                            ext: __field1,
                            url: __field2,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &["name", "ext", "url"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "File",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<File>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::clone::Clone for File {
        #[inline]
        fn clone(&self) -> File {
            File {
                name: ::core::clone::Clone::clone(&self.name),
                ext: ::core::clone::Clone::clone(&self.ext),
                url: ::core::clone::Clone::clone(&self.url),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for File {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for File {
        #[inline]
        fn eq(&self, other: &File) -> bool {
            self.name == other.name && self.ext == other.ext && self.url == other.url
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Eq for File {
        #[inline]
        #[doc(hidden)]
        #[coverage(off)]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<String>;
            let _: ::core::cmp::AssertParamIsEq<Option<String>>;
        }
    }
    #[serde(rename_all = "lowercase")]
    pub enum FileType {
        #[default]
        None,
        PNG,
        JPG,
        GIF,
        WEBM,
        SVG,
        AI,
        GLB,
        GLTF,
        MP3,
        WAV,
        MP4,
        PPTX,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for FileType {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(
                f,
                match self {
                    FileType::None => "None",
                    FileType::PNG => "PNG",
                    FileType::JPG => "JPG",
                    FileType::GIF => "GIF",
                    FileType::WEBM => "WEBM",
                    FileType::SVG => "SVG",
                    FileType::AI => "AI",
                    FileType::GLB => "GLB",
                    FileType::GLTF => "GLTF",
                    FileType::MP3 => "MP3",
                    FileType::WAV => "WAV",
                    FileType::MP4 => "MP4",
                    FileType::PPTX => "PPTX",
                },
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for FileType {
        #[inline]
        fn clone(&self) -> FileType {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for FileType {}
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for FileType {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    FileType::None => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "FileType",
                            0u32,
                            "none",
                        )
                    }
                    FileType::PNG => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "FileType",
                            1u32,
                            "png",
                        )
                    }
                    FileType::JPG => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "FileType",
                            2u32,
                            "jpg",
                        )
                    }
                    FileType::GIF => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "FileType",
                            3u32,
                            "gif",
                        )
                    }
                    FileType::WEBM => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "FileType",
                            4u32,
                            "webm",
                        )
                    }
                    FileType::SVG => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "FileType",
                            5u32,
                            "svg",
                        )
                    }
                    FileType::AI => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "FileType",
                            6u32,
                            "ai",
                        )
                    }
                    FileType::GLB => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "FileType",
                            7u32,
                            "glb",
                        )
                    }
                    FileType::GLTF => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "FileType",
                            8u32,
                            "gltf",
                        )
                    }
                    FileType::MP3 => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "FileType",
                            9u32,
                            "mp3",
                        )
                    }
                    FileType::WAV => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "FileType",
                            10u32,
                            "wav",
                        )
                    }
                    FileType::MP4 => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "FileType",
                            11u32,
                            "mp4",
                        )
                    }
                    FileType::PPTX => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "FileType",
                            12u32,
                            "pptx",
                        )
                    }
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for FileType {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __field4,
                    __field5,
                    __field6,
                    __field7,
                    __field8,
                    __field9,
                    __field10,
                    __field11,
                    __field12,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "variant identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            4u64 => _serde::__private::Ok(__Field::__field4),
                            5u64 => _serde::__private::Ok(__Field::__field5),
                            6u64 => _serde::__private::Ok(__Field::__field6),
                            7u64 => _serde::__private::Ok(__Field::__field7),
                            8u64 => _serde::__private::Ok(__Field::__field8),
                            9u64 => _serde::__private::Ok(__Field::__field9),
                            10u64 => _serde::__private::Ok(__Field::__field10),
                            11u64 => _serde::__private::Ok(__Field::__field11),
                            12u64 => _serde::__private::Ok(__Field::__field12),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::invalid_value(
                                        _serde::de::Unexpected::Unsigned(__value),
                                        &"variant index 0 <= i < 13",
                                    ),
                                )
                            }
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "none" => _serde::__private::Ok(__Field::__field0),
                            "png" => _serde::__private::Ok(__Field::__field1),
                            "jpg" => _serde::__private::Ok(__Field::__field2),
                            "gif" => _serde::__private::Ok(__Field::__field3),
                            "webm" => _serde::__private::Ok(__Field::__field4),
                            "svg" => _serde::__private::Ok(__Field::__field5),
                            "ai" => _serde::__private::Ok(__Field::__field6),
                            "glb" => _serde::__private::Ok(__Field::__field7),
                            "gltf" => _serde::__private::Ok(__Field::__field8),
                            "mp3" => _serde::__private::Ok(__Field::__field9),
                            "wav" => _serde::__private::Ok(__Field::__field10),
                            "mp4" => _serde::__private::Ok(__Field::__field11),
                            "pptx" => _serde::__private::Ok(__Field::__field12),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"none" => _serde::__private::Ok(__Field::__field0),
                            b"png" => _serde::__private::Ok(__Field::__field1),
                            b"jpg" => _serde::__private::Ok(__Field::__field2),
                            b"gif" => _serde::__private::Ok(__Field::__field3),
                            b"webm" => _serde::__private::Ok(__Field::__field4),
                            b"svg" => _serde::__private::Ok(__Field::__field5),
                            b"ai" => _serde::__private::Ok(__Field::__field6),
                            b"glb" => _serde::__private::Ok(__Field::__field7),
                            b"gltf" => _serde::__private::Ok(__Field::__field8),
                            b"mp3" => _serde::__private::Ok(__Field::__field9),
                            b"wav" => _serde::__private::Ok(__Field::__field10),
                            b"mp4" => _serde::__private::Ok(__Field::__field11),
                            b"pptx" => _serde::__private::Ok(__Field::__field12),
                            _ => {
                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<FileType>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = FileType;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "enum FileType",
                        )
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match _serde::de::EnumAccess::variant(__data)? {
                            (__Field::__field0, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(FileType::None)
                            }
                            (__Field::__field1, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(FileType::PNG)
                            }
                            (__Field::__field2, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(FileType::JPG)
                            }
                            (__Field::__field3, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(FileType::GIF)
                            }
                            (__Field::__field4, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(FileType::WEBM)
                            }
                            (__Field::__field5, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(FileType::SVG)
                            }
                            (__Field::__field6, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(FileType::AI)
                            }
                            (__Field::__field7, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(FileType::GLB)
                            }
                            (__Field::__field8, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(FileType::GLTF)
                            }
                            (__Field::__field9, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(FileType::MP3)
                            }
                            (__Field::__field10, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(FileType::WAV)
                            }
                            (__Field::__field11, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(FileType::MP4)
                            }
                            (__Field::__field12, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(FileType::PPTX)
                            }
                        }
                    }
                }
                #[doc(hidden)]
                const VARIANTS: &'static [&'static str] = &[
                    "none",
                    "png",
                    "jpg",
                    "gif",
                    "webm",
                    "svg",
                    "ai",
                    "glb",
                    "gltf",
                    "mp3",
                    "wav",
                    "mp4",
                    "pptx",
                ];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "FileType",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<FileType>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::default::Default for FileType {
        #[inline]
        fn default() -> FileType {
            Self::None
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for FileType {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for FileType {
        #[inline]
        fn eq(&self, other: &FileType) -> bool {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            let __arg1_discr = ::core::intrinsics::discriminant_value(other);
            __self_discr == __arg1_discr
        }
    }
    impl FileType {
        pub fn translate(&self, lang: &dioxus_translate::Language) -> &'static str {
            match lang {
                dioxus_translate::Language::En => {
                    match self {
                        FileType::None => "None",
                        FileType::PNG => "PNG",
                        FileType::JPG => "JPG",
                        FileType::GIF => "GIF",
                        FileType::WEBM => "WEBM",
                        FileType::SVG => "SVG",
                        FileType::AI => "AI",
                        FileType::GLB => "GLB",
                        FileType::GLTF => "GLTF",
                        FileType::MP3 => "MP3",
                        FileType::WAV => "WAV",
                        FileType::MP4 => "MP4",
                        FileType::PPTX => "PPTX",
                    }
                }
                dioxus_translate::Language::Ko => {
                    match self {
                        FileType::None => "None",
                        FileType::PNG => "PNG",
                        FileType::JPG => "JPG",
                        FileType::GIF => "GIF",
                        FileType::WEBM => "WEBM",
                        FileType::SVG => "SVG",
                        FileType::AI => "AI",
                        FileType::GLB => "GLB",
                        FileType::GLTF => "GLTF",
                        FileType::MP3 => "MP3",
                        FileType::WAV => "WAV",
                        FileType::MP4 => "MP4",
                        FileType::PPTX => "PPTX",
                    }
                }
            }
        }
        pub const VARIANTS: &'static [Self] = &[
            FileType::None,
            FileType::PNG,
            FileType::JPG,
            FileType::GIF,
            FileType::WEBM,
            FileType::SVG,
            FileType::AI,
            FileType::GLB,
            FileType::GLTF,
            FileType::MP3,
            FileType::WAV,
            FileType::MP4,
            FileType::PPTX,
        ];
        pub fn variants(lang: &dioxus_translate::Language) -> Vec<String> {
            Self::VARIANTS
                .iter()
                .map(|v| v.translate(&lang).to_string())
                .collect::<Vec<_>>()
        }
    }
    impl std::fmt::Display for FileType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match self {
                FileType::None => f.write_fmt(format_args!("none")),
                FileType::PNG => f.write_fmt(format_args!("png")),
                FileType::JPG => f.write_fmt(format_args!("jpg")),
                FileType::GIF => f.write_fmt(format_args!("gif")),
                FileType::WEBM => f.write_fmt(format_args!("webm")),
                FileType::SVG => f.write_fmt(format_args!("svg")),
                FileType::AI => f.write_fmt(format_args!("ai")),
                FileType::GLB => f.write_fmt(format_args!("glb")),
                FileType::GLTF => f.write_fmt(format_args!("gltf")),
                FileType::MP3 => f.write_fmt(format_args!("mp3")),
                FileType::WAV => f.write_fmt(format_args!("wav")),
                FileType::MP4 => f.write_fmt(format_args!("mp4")),
                FileType::PPTX => f.write_fmt(format_args!("pptx")),
            }
        }
    }
    impl std::str::FromStr for FileType {
        type Err = String;
        fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
            match s {
                "None" | "none" => Ok(FileType::None),
                "None" => Ok(FileType::None),
                "PNG" | "png" => Ok(FileType::PNG),
                "PNG" => Ok(FileType::PNG),
                "JPG" | "jpg" => Ok(FileType::JPG),
                "JPG" => Ok(FileType::JPG),
                "GIF" | "gif" => Ok(FileType::GIF),
                "GIF" => Ok(FileType::GIF),
                "WEBM" | "webm" => Ok(FileType::WEBM),
                "WEBM" => Ok(FileType::WEBM),
                "SVG" | "svg" => Ok(FileType::SVG),
                "SVG" => Ok(FileType::SVG),
                "AI" | "ai" => Ok(FileType::AI),
                "AI" => Ok(FileType::AI),
                "GLB" | "glb" => Ok(FileType::GLB),
                "GLB" => Ok(FileType::GLB),
                "GLTF" | "gltf" => Ok(FileType::GLTF),
                "GLTF" => Ok(FileType::GLTF),
                "MP3" | "mp3" => Ok(FileType::MP3),
                "MP3" => Ok(FileType::MP3),
                "WAV" | "wav" => Ok(FileType::WAV),
                "WAV" => Ok(FileType::WAV),
                "MP4" | "mp4" => Ok(FileType::MP4),
                "MP4" => Ok(FileType::MP4),
                "PPTX" | "pptx" => Ok(FileType::PPTX),
                "PPTX" => Ok(FileType::PPTX),
                _ => {
                    Err(
                        ::alloc::__export::must_use({
                            let res = ::alloc::fmt::format(
                                format_args!("invalid field"),
                            );
                            res
                        }),
                    )
                }
            }
        }
    }
    impl FileType {
        pub fn from_str(s: &str) -> Result<FileType, Error> {
            match s {
                "jpg" | "jpeg" => Ok(FileType::JPG),
                "png" => Ok(FileType::PNG),
                _ => Err(Error::InvalidType),
            }
        }
    }
}
pub mod content {
    #![allow(unused_variables)]
    use by_macros::api_model;
    use dioxus_translate::Translate;
    use validator::Validate;
    /// Content is a generated struct that represents the model
    ///
    /// For making API calls related to this model, use `Content::get_client(endpoint: &str)`.
    /// It will returns ContentClient struct that implements the API calls.
    ///
    /// In server side, you can use `Content::get_repository()` to interact with the database.
    /// Recommend to use `ContentRepository` to insert or update the model.
    /// To query the model, use `Content::query_builder()`.
    /// For more detail, refer to the documentation of the query builder.
    pub struct Content {
        pub id: i64,
        pub created_at: i64,
        pub updated_at: i64,
        pub title: String,
        #[validate(url)]
        pub thumbnail_image: String,
        #[validate(url)]
        pub source: String,
        pub description: String,
        pub creator_id: i64,
        pub downloads: i64,
        pub likes: i64,
        pub liked: bool,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Content {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let names: &'static _ = &[
                "id",
                "created_at",
                "updated_at",
                "title",
                "thumbnail_image",
                "source",
                "description",
                "creator_id",
                "downloads",
                "likes",
                "liked",
            ];
            let values: &[&dyn ::core::fmt::Debug] = &[
                &self.id,
                &self.created_at,
                &self.updated_at,
                &self.title,
                &self.thumbnail_image,
                &self.source,
                &self.description,
                &self.creator_id,
                &self.downloads,
                &self.likes,
                &&self.liked,
            ];
            ::core::fmt::Formatter::debug_struct_fields_finish(
                f,
                "Content",
                names,
                values,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Content {
        #[inline]
        fn clone(&self) -> Content {
            Content {
                id: ::core::clone::Clone::clone(&self.id),
                created_at: ::core::clone::Clone::clone(&self.created_at),
                updated_at: ::core::clone::Clone::clone(&self.updated_at),
                title: ::core::clone::Clone::clone(&self.title),
                thumbnail_image: ::core::clone::Clone::clone(&self.thumbnail_image),
                source: ::core::clone::Clone::clone(&self.source),
                description: ::core::clone::Clone::clone(&self.description),
                creator_id: ::core::clone::Clone::clone(&self.creator_id),
                downloads: ::core::clone::Clone::clone(&self.downloads),
                likes: ::core::clone::Clone::clone(&self.likes),
                liked: ::core::clone::Clone::clone(&self.liked),
            }
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for Content {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __field4,
                    __field5,
                    __field6,
                    __field7,
                    __field8,
                    __field9,
                    __field10,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            4u64 => _serde::__private::Ok(__Field::__field4),
                            5u64 => _serde::__private::Ok(__Field::__field5),
                            6u64 => _serde::__private::Ok(__Field::__field6),
                            7u64 => _serde::__private::Ok(__Field::__field7),
                            8u64 => _serde::__private::Ok(__Field::__field8),
                            9u64 => _serde::__private::Ok(__Field::__field9),
                            10u64 => _serde::__private::Ok(__Field::__field10),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "id" => _serde::__private::Ok(__Field::__field0),
                            "created_at" => _serde::__private::Ok(__Field::__field1),
                            "updated_at" => _serde::__private::Ok(__Field::__field2),
                            "title" => _serde::__private::Ok(__Field::__field3),
                            "thumbnail_image" => _serde::__private::Ok(__Field::__field4),
                            "source" => _serde::__private::Ok(__Field::__field5),
                            "description" => _serde::__private::Ok(__Field::__field6),
                            "creator_id" => _serde::__private::Ok(__Field::__field7),
                            "downloads" => _serde::__private::Ok(__Field::__field8),
                            "likes" => _serde::__private::Ok(__Field::__field9),
                            "liked" => _serde::__private::Ok(__Field::__field10),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"id" => _serde::__private::Ok(__Field::__field0),
                            b"created_at" => _serde::__private::Ok(__Field::__field1),
                            b"updated_at" => _serde::__private::Ok(__Field::__field2),
                            b"title" => _serde::__private::Ok(__Field::__field3),
                            b"thumbnail_image" => {
                                _serde::__private::Ok(__Field::__field4)
                            }
                            b"source" => _serde::__private::Ok(__Field::__field5),
                            b"description" => _serde::__private::Ok(__Field::__field6),
                            b"creator_id" => _serde::__private::Ok(__Field::__field7),
                            b"downloads" => _serde::__private::Ok(__Field::__field8),
                            b"likes" => _serde::__private::Ok(__Field::__field9),
                            b"liked" => _serde::__private::Ok(__Field::__field10),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<Content>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = Content;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct Content",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            i64,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct Content with 11 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            i64,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct Content with 11 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match _serde::de::SeqAccess::next_element::<
                            i64,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct Content with 11 elements",
                                    ),
                                );
                            }
                        };
                        let __field3 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        3usize,
                                        &"struct Content with 11 elements",
                                    ),
                                );
                            }
                        };
                        let __field4 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        4usize,
                                        &"struct Content with 11 elements",
                                    ),
                                );
                            }
                        };
                        let __field5 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        5usize,
                                        &"struct Content with 11 elements",
                                    ),
                                );
                            }
                        };
                        let __field6 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        6usize,
                                        &"struct Content with 11 elements",
                                    ),
                                );
                            }
                        };
                        let __field7 = match _serde::de::SeqAccess::next_element::<
                            i64,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        7usize,
                                        &"struct Content with 11 elements",
                                    ),
                                );
                            }
                        };
                        let __field8 = match _serde::de::SeqAccess::next_element::<
                            i64,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        8usize,
                                        &"struct Content with 11 elements",
                                    ),
                                );
                            }
                        };
                        let __field9 = match _serde::de::SeqAccess::next_element::<
                            i64,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        9usize,
                                        &"struct Content with 11 elements",
                                    ),
                                );
                            }
                        };
                        let __field10 = match _serde::de::SeqAccess::next_element::<
                            bool,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        10usize,
                                        &"struct Content with 11 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(Content {
                            id: __field0,
                            created_at: __field1,
                            updated_at: __field2,
                            title: __field3,
                            thumbnail_image: __field4,
                            source: __field5,
                            description: __field6,
                            creator_id: __field7,
                            downloads: __field8,
                            likes: __field9,
                            liked: __field10,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<i64> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<i64> = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<i64> = _serde::__private::None;
                        let mut __field3: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field4: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field5: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field6: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field7: _serde::__private::Option<i64> = _serde::__private::None;
                        let mut __field8: _serde::__private::Option<i64> = _serde::__private::None;
                        let mut __field9: _serde::__private::Option<i64> = _serde::__private::None;
                        let mut __field10: _serde::__private::Option<bool> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("id"),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<i64>(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "created_at",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<i64>(&mut __map)?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "updated_at",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<i64>(&mut __map)?,
                                    );
                                }
                                __Field::__field3 => {
                                    if _serde::__private::Option::is_some(&__field3) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("title"),
                                        );
                                    }
                                    __field3 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field4 => {
                                    if _serde::__private::Option::is_some(&__field4) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "thumbnail_image",
                                            ),
                                        );
                                    }
                                    __field4 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field5 => {
                                    if _serde::__private::Option::is_some(&__field5) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("source"),
                                        );
                                    }
                                    __field5 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field6 => {
                                    if _serde::__private::Option::is_some(&__field6) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "description",
                                            ),
                                        );
                                    }
                                    __field6 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field7 => {
                                    if _serde::__private::Option::is_some(&__field7) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "creator_id",
                                            ),
                                        );
                                    }
                                    __field7 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<i64>(&mut __map)?,
                                    );
                                }
                                __Field::__field8 => {
                                    if _serde::__private::Option::is_some(&__field8) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "downloads",
                                            ),
                                        );
                                    }
                                    __field8 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<i64>(&mut __map)?,
                                    );
                                }
                                __Field::__field9 => {
                                    if _serde::__private::Option::is_some(&__field9) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("likes"),
                                        );
                                    }
                                    __field9 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<i64>(&mut __map)?,
                                    );
                                }
                                __Field::__field10 => {
                                    if _serde::__private::Option::is_some(&__field10) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("liked"),
                                        );
                                    }
                                    __field10 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<bool>(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("id")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("created_at")?
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("updated_at")?
                            }
                        };
                        let __field3 = match __field3 {
                            _serde::__private::Some(__field3) => __field3,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("title")?
                            }
                        };
                        let __field4 = match __field4 {
                            _serde::__private::Some(__field4) => __field4,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("thumbnail_image")?
                            }
                        };
                        let __field5 = match __field5 {
                            _serde::__private::Some(__field5) => __field5,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("source")?
                            }
                        };
                        let __field6 = match __field6 {
                            _serde::__private::Some(__field6) => __field6,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("description")?
                            }
                        };
                        let __field7 = match __field7 {
                            _serde::__private::Some(__field7) => __field7,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("creator_id")?
                            }
                        };
                        let __field8 = match __field8 {
                            _serde::__private::Some(__field8) => __field8,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("downloads")?
                            }
                        };
                        let __field9 = match __field9 {
                            _serde::__private::Some(__field9) => __field9,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("likes")?
                            }
                        };
                        let __field10 = match __field10 {
                            _serde::__private::Some(__field10) => __field10,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("liked")?
                            }
                        };
                        _serde::__private::Ok(Content {
                            id: __field0,
                            created_at: __field1,
                            updated_at: __field2,
                            title: __field3,
                            thumbnail_image: __field4,
                            source: __field5,
                            description: __field6,
                            creator_id: __field7,
                            downloads: __field8,
                            likes: __field9,
                            liked: __field10,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "id",
                    "created_at",
                    "updated_at",
                    "title",
                    "thumbnail_image",
                    "source",
                    "description",
                    "creator_id",
                    "downloads",
                    "likes",
                    "liked",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "Content",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<Content>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for Content {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "Content",
                    false as usize + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "id",
                    &self.id,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "created_at",
                    &self.created_at,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "updated_at",
                    &self.updated_at,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "title",
                    &self.title,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "thumbnail_image",
                    &self.thumbnail_image,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "source",
                    &self.source,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "description",
                    &self.description,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "creator_id",
                    &self.creator_id,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "downloads",
                    &self.downloads,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "likes",
                    &self.likes,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "liked",
                    &self.liked,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[automatically_derived]
    impl ::core::default::Default for Content {
        #[inline]
        fn default() -> Content {
            Content {
                id: ::core::default::Default::default(),
                created_at: ::core::default::Default::default(),
                updated_at: ::core::default::Default::default(),
                title: ::core::default::Default::default(),
                thumbnail_image: ::core::default::Default::default(),
                source: ::core::default::Default::default(),
                description: ::core::default::Default::default(),
                creator_id: ::core::default::Default::default(),
                downloads: ::core::default::Default::default(),
                likes: ::core::default::Default::default(),
                liked: ::core::default::Default::default(),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Content {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Content {
        #[inline]
        fn eq(&self, other: &Content) -> bool {
            self.id == other.id && self.created_at == other.created_at
                && self.updated_at == other.updated_at && self.title == other.title
                && self.thumbnail_image == other.thumbnail_image
                && self.source == other.source && self.description == other.description
                && self.creator_id == other.creator_id
                && self.downloads == other.downloads && self.likes == other.likes
                && self.liked == other.liked
        }
    }
    #[serde(rename_all = "snake_case")]
    pub enum ContentAction {
        CreateBulk(ContentCreateBulkRequest),
        Create(ContentCreateRequest),
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for ContentAction {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                ContentAction::CreateBulk(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "CreateBulk",
                        &__self_0,
                    )
                }
                ContentAction::Create(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Create",
                        &__self_0,
                    )
                }
            }
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for ContentAction {
        #[inline]
        fn clone(&self) -> ContentAction {
            match self {
                ContentAction::CreateBulk(__self_0) => {
                    ContentAction::CreateBulk(::core::clone::Clone::clone(__self_0))
                }
                ContentAction::Create(__self_0) => {
                    ContentAction::Create(::core::clone::Clone::clone(__self_0))
                }
            }
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for ContentAction {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    ContentAction::CreateBulk(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "ContentAction",
                            0u32,
                            "create_bulk",
                            __field0,
                        )
                    }
                    ContentAction::Create(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "ContentAction",
                            1u32,
                            "create",
                            __field0,
                        )
                    }
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for ContentAction {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "variant identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::invalid_value(
                                        _serde::de::Unexpected::Unsigned(__value),
                                        &"variant index 0 <= i < 2",
                                    ),
                                )
                            }
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "create_bulk" => _serde::__private::Ok(__Field::__field0),
                            "create" => _serde::__private::Ok(__Field::__field1),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"create_bulk" => _serde::__private::Ok(__Field::__field0),
                            b"create" => _serde::__private::Ok(__Field::__field1),
                            _ => {
                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<ContentAction>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = ContentAction;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "enum ContentAction",
                        )
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match _serde::de::EnumAccess::variant(__data)? {
                            (__Field::__field0, __variant) => {
                                _serde::__private::Result::map(
                                    _serde::de::VariantAccess::newtype_variant::<
                                        ContentCreateBulkRequest,
                                    >(__variant),
                                    ContentAction::CreateBulk,
                                )
                            }
                            (__Field::__field1, __variant) => {
                                _serde::__private::Result::map(
                                    _serde::de::VariantAccess::newtype_variant::<
                                        ContentCreateRequest,
                                    >(__variant),
                                    ContentAction::Create,
                                )
                            }
                        }
                    }
                }
                #[doc(hidden)]
                const VARIANTS: &'static [&'static str] = &["create_bulk", "create"];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "ContentAction",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<ContentAction>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for ContentAction {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for ContentAction {
        #[inline]
        fn eq(&self, other: &ContentAction) -> bool {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            let __arg1_discr = ::core::intrinsics::discriminant_value(other);
            __self_discr == __arg1_discr
                && match (self, other) {
                    (
                        ContentAction::CreateBulk(__self_0),
                        ContentAction::CreateBulk(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (
                        ContentAction::Create(__self_0),
                        ContentAction::Create(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    _ => unsafe { ::core::intrinsics::unreachable() }
                }
        }
    }
    impl validator::Validate for ContentAction {
        fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
            match self {
                ContentAction::CreateBulk(req) => req.validate(),
                ContentAction::Create(req) => req.validate(),
            }
        }
    }
    pub struct ContentCreateBulkRequest {
        pub items: Vec<ContentCreateRequest>,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for ContentCreateBulkRequest {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field1_finish(
                f,
                "ContentCreateBulkRequest",
                "items",
                &&self.items,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for ContentCreateBulkRequest {
        #[inline]
        fn clone(&self) -> ContentCreateBulkRequest {
            ContentCreateBulkRequest {
                items: ::core::clone::Clone::clone(&self.items),
            }
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for ContentCreateBulkRequest {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "ContentCreateBulkRequest",
                    false as usize + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "items",
                    &self.items,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for ContentCreateBulkRequest {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "items" => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"items" => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<ContentCreateBulkRequest>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = ContentCreateBulkRequest;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct ContentCreateBulkRequest",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            Vec<ContentCreateRequest>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct ContentCreateBulkRequest with 1 element",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(ContentCreateBulkRequest {
                            items: __field0,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<
                            Vec<ContentCreateRequest>,
                        > = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("items"),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Vec<ContentCreateRequest>,
                                        >(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("items")?
                            }
                        };
                        _serde::__private::Ok(ContentCreateBulkRequest {
                            items: __field0,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &["items"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "ContentCreateBulkRequest",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<
                            ContentCreateBulkRequest,
                        >,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::default::Default for ContentCreateBulkRequest {
        #[inline]
        fn default() -> ContentCreateBulkRequest {
            ContentCreateBulkRequest {
                items: ::core::default::Default::default(),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for ContentCreateBulkRequest {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for ContentCreateBulkRequest {
        #[inline]
        fn eq(&self, other: &ContentCreateBulkRequest) -> bool {
            self.items == other.items
        }
    }
    impl ::validator::Validate for ContentCreateBulkRequest {
        fn validate(&self) -> ::std::result::Result<(), ::validator::ValidationErrors> {
            use ::validator::ValidateArgs;
            self.validate_with_args(())
        }
    }
    impl<'v_a> ::validator::ValidateArgs<'v_a> for ContentCreateBulkRequest {
        type Args = ();
        fn validate_with_args(
            &self,
            args: Self::Args,
        ) -> ::std::result::Result<(), ::validator::ValidationErrors> {
            let mut errors = ::validator::ValidationErrors::new();
            if errors.is_empty() {
                ::std::result::Result::Ok(())
            } else {
                ::std::result::Result::Err(errors)
            }
        }
    }
    pub struct ContentCreateRequest {
        pub title: String,
        #[validate(url)]
        pub thumbnail_image: String,
        #[validate(url)]
        pub source: String,
        pub description: String,
        pub creator_id: i64,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for ContentCreateRequest {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field5_finish(
                f,
                "ContentCreateRequest",
                "title",
                &self.title,
                "thumbnail_image",
                &self.thumbnail_image,
                "source",
                &self.source,
                "description",
                &self.description,
                "creator_id",
                &&self.creator_id,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for ContentCreateRequest {
        #[inline]
        fn clone(&self) -> ContentCreateRequest {
            ContentCreateRequest {
                title: ::core::clone::Clone::clone(&self.title),
                thumbnail_image: ::core::clone::Clone::clone(&self.thumbnail_image),
                source: ::core::clone::Clone::clone(&self.source),
                description: ::core::clone::Clone::clone(&self.description),
                creator_id: ::core::clone::Clone::clone(&self.creator_id),
            }
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for ContentCreateRequest {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "ContentCreateRequest",
                    false as usize + 1 + 1 + 1 + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "title",
                    &self.title,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "thumbnail_image",
                    &self.thumbnail_image,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "source",
                    &self.source,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "description",
                    &self.description,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "creator_id",
                    &self.creator_id,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for ContentCreateRequest {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __field4,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            4u64 => _serde::__private::Ok(__Field::__field4),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "title" => _serde::__private::Ok(__Field::__field0),
                            "thumbnail_image" => _serde::__private::Ok(__Field::__field1),
                            "source" => _serde::__private::Ok(__Field::__field2),
                            "description" => _serde::__private::Ok(__Field::__field3),
                            "creator_id" => _serde::__private::Ok(__Field::__field4),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"title" => _serde::__private::Ok(__Field::__field0),
                            b"thumbnail_image" => {
                                _serde::__private::Ok(__Field::__field1)
                            }
                            b"source" => _serde::__private::Ok(__Field::__field2),
                            b"description" => _serde::__private::Ok(__Field::__field3),
                            b"creator_id" => _serde::__private::Ok(__Field::__field4),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<ContentCreateRequest>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = ContentCreateRequest;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct ContentCreateRequest",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct ContentCreateRequest with 5 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct ContentCreateRequest with 5 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct ContentCreateRequest with 5 elements",
                                    ),
                                );
                            }
                        };
                        let __field3 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        3usize,
                                        &"struct ContentCreateRequest with 5 elements",
                                    ),
                                );
                            }
                        };
                        let __field4 = match _serde::de::SeqAccess::next_element::<
                            i64,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        4usize,
                                        &"struct ContentCreateRequest with 5 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(ContentCreateRequest {
                            title: __field0,
                            thumbnail_image: __field1,
                            source: __field2,
                            description: __field3,
                            creator_id: __field4,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field3: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field4: _serde::__private::Option<i64> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("title"),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "thumbnail_image",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("source"),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field3 => {
                                    if _serde::__private::Option::is_some(&__field3) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "description",
                                            ),
                                        );
                                    }
                                    __field3 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field4 => {
                                    if _serde::__private::Option::is_some(&__field4) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "creator_id",
                                            ),
                                        );
                                    }
                                    __field4 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<i64>(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("title")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("thumbnail_image")?
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("source")?
                            }
                        };
                        let __field3 = match __field3 {
                            _serde::__private::Some(__field3) => __field3,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("description")?
                            }
                        };
                        let __field4 = match __field4 {
                            _serde::__private::Some(__field4) => __field4,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("creator_id")?
                            }
                        };
                        _serde::__private::Ok(ContentCreateRequest {
                            title: __field0,
                            thumbnail_image: __field1,
                            source: __field2,
                            description: __field3,
                            creator_id: __field4,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "title",
                    "thumbnail_image",
                    "source",
                    "description",
                    "creator_id",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "ContentCreateRequest",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<ContentCreateRequest>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::default::Default for ContentCreateRequest {
        #[inline]
        fn default() -> ContentCreateRequest {
            ContentCreateRequest {
                title: ::core::default::Default::default(),
                thumbnail_image: ::core::default::Default::default(),
                source: ::core::default::Default::default(),
                description: ::core::default::Default::default(),
                creator_id: ::core::default::Default::default(),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for ContentCreateRequest {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for ContentCreateRequest {
        #[inline]
        fn eq(&self, other: &ContentCreateRequest) -> bool {
            self.title == other.title && self.thumbnail_image == other.thumbnail_image
                && self.source == other.source && self.description == other.description
                && self.creator_id == other.creator_id
        }
    }
    impl ::validator::Validate for ContentCreateRequest {
        fn validate(&self) -> ::std::result::Result<(), ::validator::ValidationErrors> {
            use ::validator::ValidateArgs;
            self.validate_with_args(())
        }
    }
    impl<'v_a> ::validator::ValidateArgs<'v_a> for ContentCreateRequest {
        type Args = ();
        fn validate_with_args(
            &self,
            args: Self::Args,
        ) -> ::std::result::Result<(), ::validator::ValidationErrors> {
            use ::validator::ValidateUrl;
            let mut errors = ::validator::ValidationErrors::new();
            if !self.thumbnail_image.validate_url() {
                let mut err = ::validator::ValidationError::new("url");
                err.add_param(::std::borrow::Cow::from("value"), &self.thumbnail_image);
                errors.add("thumbnail_image", err);
            }
            if !self.source.validate_url() {
                let mut err = ::validator::ValidationError::new("url");
                err.add_param(::std::borrow::Cow::from("value"), &self.source);
                errors.add("source", err);
            }
            if errors.is_empty() {
                ::std::result::Result::Ok(())
            } else {
                ::std::result::Result::Err(errors)
            }
        }
    }
    impl ContentClient {
        pub async fn act(&self, params: ContentAction) -> crate::Result<Content> {
            let path = ::alloc::__export::must_use({
                let res = ::alloc::fmt::format(format_args!("/v1/contents"));
                res
            });
            let endpoint = ::alloc::__export::must_use({
                let res = ::alloc::fmt::format(
                    format_args!("{0}{1}", self.endpoint, path),
                );
                res
            });
            rest_api::post(&endpoint, params).await
        }
        pub async fn create_bulk(
            &self,
            items: Vec<ContentCreateRequest>,
        ) -> crate::Result<Content> {
            let path = ::alloc::__export::must_use({
                let res = ::alloc::fmt::format(format_args!("/v1/contents"));
                res
            });
            let endpoint = ::alloc::__export::must_use({
                let res = ::alloc::fmt::format(
                    format_args!("{0}{1}", self.endpoint, path),
                );
                res
            });
            let req = ContentAction::CreateBulk(ContentCreateBulkRequest { items });
            rest_api::post(&endpoint, req).await
        }
        pub async fn create(
            &self,
            title: String,
            thumbnail_image: String,
            source: String,
            description: String,
            creator_id: i64,
        ) -> crate::Result<Content> {
            let path = ::alloc::__export::must_use({
                let res = ::alloc::fmt::format(format_args!("/v1/contents"));
                res
            });
            let endpoint = ::alloc::__export::must_use({
                let res = ::alloc::fmt::format(
                    format_args!("{0}{1}", self.endpoint, path),
                );
                res
            });
            let req = ContentAction::Create(ContentCreateRequest {
                title,
                thumbnail_image,
                source,
                description,
                creator_id,
            });
            rest_api::post(&endpoint, req).await
        }
    }
    #[serde(rename_all = "snake_case")]
    pub enum ContentByIdAction {
        Mint(ContentMintRequest),
        Like(ContentLikeRequest),
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for ContentByIdAction {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                ContentByIdAction::Mint(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Mint",
                        &__self_0,
                    )
                }
                ContentByIdAction::Like(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Like",
                        &__self_0,
                    )
                }
            }
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for ContentByIdAction {
        #[inline]
        fn clone(&self) -> ContentByIdAction {
            match self {
                ContentByIdAction::Mint(__self_0) => {
                    ContentByIdAction::Mint(::core::clone::Clone::clone(__self_0))
                }
                ContentByIdAction::Like(__self_0) => {
                    ContentByIdAction::Like(::core::clone::Clone::clone(__self_0))
                }
            }
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for ContentByIdAction {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    ContentByIdAction::Mint(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "ContentByIdAction",
                            0u32,
                            "mint",
                            __field0,
                        )
                    }
                    ContentByIdAction::Like(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "ContentByIdAction",
                            1u32,
                            "like",
                            __field0,
                        )
                    }
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for ContentByIdAction {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "variant identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::invalid_value(
                                        _serde::de::Unexpected::Unsigned(__value),
                                        &"variant index 0 <= i < 2",
                                    ),
                                )
                            }
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "mint" => _serde::__private::Ok(__Field::__field0),
                            "like" => _serde::__private::Ok(__Field::__field1),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"mint" => _serde::__private::Ok(__Field::__field0),
                            b"like" => _serde::__private::Ok(__Field::__field1),
                            _ => {
                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<ContentByIdAction>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = ContentByIdAction;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "enum ContentByIdAction",
                        )
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match _serde::de::EnumAccess::variant(__data)? {
                            (__Field::__field0, __variant) => {
                                _serde::__private::Result::map(
                                    _serde::de::VariantAccess::newtype_variant::<
                                        ContentMintRequest,
                                    >(__variant),
                                    ContentByIdAction::Mint,
                                )
                            }
                            (__Field::__field1, __variant) => {
                                _serde::__private::Result::map(
                                    _serde::de::VariantAccess::newtype_variant::<
                                        ContentLikeRequest,
                                    >(__variant),
                                    ContentByIdAction::Like,
                                )
                            }
                        }
                    }
                }
                #[doc(hidden)]
                const VARIANTS: &'static [&'static str] = &["mint", "like"];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "ContentByIdAction",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<ContentByIdAction>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for ContentByIdAction {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for ContentByIdAction {
        #[inline]
        fn eq(&self, other: &ContentByIdAction) -> bool {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            let __arg1_discr = ::core::intrinsics::discriminant_value(other);
            __self_discr == __arg1_discr
                && match (self, other) {
                    (
                        ContentByIdAction::Mint(__self_0),
                        ContentByIdAction::Mint(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (
                        ContentByIdAction::Like(__self_0),
                        ContentByIdAction::Like(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    _ => unsafe { ::core::intrinsics::unreachable() }
                }
        }
    }
    impl validator::Validate for ContentByIdAction {
        fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
            match self {
                ContentByIdAction::Mint(req) => req.validate(),
                ContentByIdAction::Like(req) => req.validate(),
            }
        }
    }
    pub struct ContentMintRequest {}
    #[automatically_derived]
    impl ::core::fmt::Debug for ContentMintRequest {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "ContentMintRequest")
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for ContentMintRequest {
        #[inline]
        fn clone(&self) -> ContentMintRequest {
            ContentMintRequest {}
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for ContentMintRequest {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "ContentMintRequest",
                    false as usize,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for ContentMintRequest {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<ContentMintRequest>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = ContentMintRequest;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct ContentMintRequest",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        _: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        _serde::__private::Ok(ContentMintRequest {})
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        _serde::__private::Ok(ContentMintRequest {})
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "ContentMintRequest",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<ContentMintRequest>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::default::Default for ContentMintRequest {
        #[inline]
        fn default() -> ContentMintRequest {
            ContentMintRequest {}
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for ContentMintRequest {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for ContentMintRequest {
        #[inline]
        fn eq(&self, other: &ContentMintRequest) -> bool {
            true
        }
    }
    impl ::validator::Validate for ContentMintRequest {
        fn validate(&self) -> ::std::result::Result<(), ::validator::ValidationErrors> {
            use ::validator::ValidateArgs;
            self.validate_with_args(())
        }
    }
    impl<'v_a> ::validator::ValidateArgs<'v_a> for ContentMintRequest {
        type Args = ();
        fn validate_with_args(
            &self,
            args: Self::Args,
        ) -> ::std::result::Result<(), ::validator::ValidationErrors> {
            let mut errors = ::validator::ValidationErrors::new();
            if errors.is_empty() {
                ::std::result::Result::Ok(())
            } else {
                ::std::result::Result::Err(errors)
            }
        }
    }
    pub struct ContentLikeRequest {}
    #[automatically_derived]
    impl ::core::fmt::Debug for ContentLikeRequest {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "ContentLikeRequest")
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for ContentLikeRequest {
        #[inline]
        fn clone(&self) -> ContentLikeRequest {
            ContentLikeRequest {}
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for ContentLikeRequest {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "ContentLikeRequest",
                    false as usize,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for ContentLikeRequest {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<ContentLikeRequest>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = ContentLikeRequest;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct ContentLikeRequest",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        _: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        _serde::__private::Ok(ContentLikeRequest {})
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        _serde::__private::Ok(ContentLikeRequest {})
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "ContentLikeRequest",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<ContentLikeRequest>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::default::Default for ContentLikeRequest {
        #[inline]
        fn default() -> ContentLikeRequest {
            ContentLikeRequest {}
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for ContentLikeRequest {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for ContentLikeRequest {
        #[inline]
        fn eq(&self, other: &ContentLikeRequest) -> bool {
            true
        }
    }
    impl ::validator::Validate for ContentLikeRequest {
        fn validate(&self) -> ::std::result::Result<(), ::validator::ValidationErrors> {
            use ::validator::ValidateArgs;
            self.validate_with_args(())
        }
    }
    impl<'v_a> ::validator::ValidateArgs<'v_a> for ContentLikeRequest {
        type Args = ();
        fn validate_with_args(
            &self,
            args: Self::Args,
        ) -> ::std::result::Result<(), ::validator::ValidationErrors> {
            let mut errors = ::validator::ValidationErrors::new();
            if errors.is_empty() {
                ::std::result::Result::Ok(())
            } else {
                ::std::result::Result::Err(errors)
            }
        }
    }
    impl ContentClient {
        pub async fn act_by_id(
            &self,
            id: i64,
            params: ContentByIdAction,
        ) -> crate::Result<Content> {
            let path = ::alloc::__export::must_use({
                let res = ::alloc::fmt::format(format_args!("/v1/contents"));
                res
            });
            let endpoint = ::alloc::__export::must_use({
                let res = ::alloc::fmt::format(
                    format_args!("{0}{1}/{2}", self.endpoint, path, id),
                );
                res
            });
            rest_api::post(&endpoint, params).await
        }
        pub async fn mint(&self, id: i64) -> crate::Result<Content> {
            let path = ::alloc::__export::must_use({
                let res = ::alloc::fmt::format(format_args!("/v1/contents"));
                res
            });
            let endpoint = ::alloc::__export::must_use({
                let res = ::alloc::fmt::format(
                    format_args!("{0}{1}/{2}", self.endpoint, path, id),
                );
                res
            });
            let req = ContentByIdAction::Mint(ContentMintRequest {});
            rest_api::post(&endpoint, req).await
        }
        pub async fn like(&self, id: i64) -> crate::Result<Content> {
            let path = ::alloc::__export::must_use({
                let res = ::alloc::fmt::format(format_args!("/v1/contents"));
                res
            });
            let endpoint = ::alloc::__export::must_use({
                let res = ::alloc::fmt::format(
                    format_args!("{0}{1}/{2}", self.endpoint, path, id),
                );
                res
            });
            let req = ContentByIdAction::Like(ContentLikeRequest {});
            rest_api::post(&endpoint, req).await
        }
    }
    pub struct ContentSummary {
        pub id: i64,
        pub created_at: i64,
        pub updated_at: i64,
        pub title: String,
        pub thumbnail_image: String,
        pub source: String,
        pub likes: i64,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for ContentSummary {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let names: &'static _ = &[
                "id",
                "created_at",
                "updated_at",
                "title",
                "thumbnail_image",
                "source",
                "likes",
            ];
            let values: &[&dyn ::core::fmt::Debug] = &[
                &self.id,
                &self.created_at,
                &self.updated_at,
                &self.title,
                &self.thumbnail_image,
                &self.source,
                &&self.likes,
            ];
            ::core::fmt::Formatter::debug_struct_fields_finish(
                f,
                "ContentSummary",
                names,
                values,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for ContentSummary {
        #[inline]
        fn clone(&self) -> ContentSummary {
            ContentSummary {
                id: ::core::clone::Clone::clone(&self.id),
                created_at: ::core::clone::Clone::clone(&self.created_at),
                updated_at: ::core::clone::Clone::clone(&self.updated_at),
                title: ::core::clone::Clone::clone(&self.title),
                thumbnail_image: ::core::clone::Clone::clone(&self.thumbnail_image),
                source: ::core::clone::Clone::clone(&self.source),
                likes: ::core::clone::Clone::clone(&self.likes),
            }
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for ContentSummary {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "ContentSummary",
                    false as usize + 1 + 1 + 1 + 1 + 1 + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "id",
                    &self.id,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "created_at",
                    &self.created_at,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "updated_at",
                    &self.updated_at,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "title",
                    &self.title,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "thumbnail_image",
                    &self.thumbnail_image,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "source",
                    &self.source,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "likes",
                    &self.likes,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for ContentSummary {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __field4,
                    __field5,
                    __field6,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            4u64 => _serde::__private::Ok(__Field::__field4),
                            5u64 => _serde::__private::Ok(__Field::__field5),
                            6u64 => _serde::__private::Ok(__Field::__field6),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "id" => _serde::__private::Ok(__Field::__field0),
                            "created_at" => _serde::__private::Ok(__Field::__field1),
                            "updated_at" => _serde::__private::Ok(__Field::__field2),
                            "title" => _serde::__private::Ok(__Field::__field3),
                            "thumbnail_image" => _serde::__private::Ok(__Field::__field4),
                            "source" => _serde::__private::Ok(__Field::__field5),
                            "likes" => _serde::__private::Ok(__Field::__field6),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"id" => _serde::__private::Ok(__Field::__field0),
                            b"created_at" => _serde::__private::Ok(__Field::__field1),
                            b"updated_at" => _serde::__private::Ok(__Field::__field2),
                            b"title" => _serde::__private::Ok(__Field::__field3),
                            b"thumbnail_image" => {
                                _serde::__private::Ok(__Field::__field4)
                            }
                            b"source" => _serde::__private::Ok(__Field::__field5),
                            b"likes" => _serde::__private::Ok(__Field::__field6),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<ContentSummary>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = ContentSummary;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct ContentSummary",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            i64,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct ContentSummary with 7 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            i64,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct ContentSummary with 7 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match _serde::de::SeqAccess::next_element::<
                            i64,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct ContentSummary with 7 elements",
                                    ),
                                );
                            }
                        };
                        let __field3 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        3usize,
                                        &"struct ContentSummary with 7 elements",
                                    ),
                                );
                            }
                        };
                        let __field4 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        4usize,
                                        &"struct ContentSummary with 7 elements",
                                    ),
                                );
                            }
                        };
                        let __field5 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        5usize,
                                        &"struct ContentSummary with 7 elements",
                                    ),
                                );
                            }
                        };
                        let __field6 = match _serde::de::SeqAccess::next_element::<
                            i64,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        6usize,
                                        &"struct ContentSummary with 7 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(ContentSummary {
                            id: __field0,
                            created_at: __field1,
                            updated_at: __field2,
                            title: __field3,
                            thumbnail_image: __field4,
                            source: __field5,
                            likes: __field6,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<i64> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<i64> = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<i64> = _serde::__private::None;
                        let mut __field3: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field4: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field5: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field6: _serde::__private::Option<i64> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("id"),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<i64>(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "created_at",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<i64>(&mut __map)?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "updated_at",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<i64>(&mut __map)?,
                                    );
                                }
                                __Field::__field3 => {
                                    if _serde::__private::Option::is_some(&__field3) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("title"),
                                        );
                                    }
                                    __field3 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field4 => {
                                    if _serde::__private::Option::is_some(&__field4) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "thumbnail_image",
                                            ),
                                        );
                                    }
                                    __field4 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field5 => {
                                    if _serde::__private::Option::is_some(&__field5) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("source"),
                                        );
                                    }
                                    __field5 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field6 => {
                                    if _serde::__private::Option::is_some(&__field6) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("likes"),
                                        );
                                    }
                                    __field6 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<i64>(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("id")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("created_at")?
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("updated_at")?
                            }
                        };
                        let __field3 = match __field3 {
                            _serde::__private::Some(__field3) => __field3,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("title")?
                            }
                        };
                        let __field4 = match __field4 {
                            _serde::__private::Some(__field4) => __field4,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("thumbnail_image")?
                            }
                        };
                        let __field5 = match __field5 {
                            _serde::__private::Some(__field5) => __field5,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("source")?
                            }
                        };
                        let __field6 = match __field6 {
                            _serde::__private::Some(__field6) => __field6,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("likes")?
                            }
                        };
                        _serde::__private::Ok(ContentSummary {
                            id: __field0,
                            created_at: __field1,
                            updated_at: __field2,
                            title: __field3,
                            thumbnail_image: __field4,
                            source: __field5,
                            likes: __field6,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "id",
                    "created_at",
                    "updated_at",
                    "title",
                    "thumbnail_image",
                    "source",
                    "likes",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "ContentSummary",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<ContentSummary>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::default::Default for ContentSummary {
        #[inline]
        fn default() -> ContentSummary {
            ContentSummary {
                id: ::core::default::Default::default(),
                created_at: ::core::default::Default::default(),
                updated_at: ::core::default::Default::default(),
                title: ::core::default::Default::default(),
                thumbnail_image: ::core::default::Default::default(),
                source: ::core::default::Default::default(),
                likes: ::core::default::Default::default(),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for ContentSummary {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for ContentSummary {
        #[inline]
        fn eq(&self, other: &ContentSummary) -> bool {
            self.id == other.id && self.created_at == other.created_at
                && self.updated_at == other.updated_at && self.title == other.title
                && self.thumbnail_image == other.thumbnail_image
                && self.source == other.source && self.likes == other.likes
        }
    }
    impl From<Content> for ContentSummary {
        fn from(item: Content) -> Self {
            Self {
                id: item.id,
                created_at: item.created_at,
                updated_at: item.updated_at,
                title: item.title,
                thumbnail_image: item.thumbnail_image,
                source: item.source,
                likes: item.likes,
            }
        }
    }
    impl Into<Content> for ContentSummary {
        fn into(self) -> Content {
            Content {
                id: self.id,
                created_at: self.created_at,
                updated_at: self.updated_at,
                title: self.title,
                thumbnail_image: self.thumbnail_image,
                source: self.source,
                likes: self.likes,
                ..Default::default()
            }
        }
    }
    #[serde(rename_all = "kebab-case")]
    pub struct ContentQuery {
        #[serde(deserialize_with = "parse_size_of_content_query", default)]
        pub size: usize,
        pub bookmark: Option<String>,
        pub action: Option<ContentQueryActionType>,
        pub description: Option<String>,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for ContentQuery {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field4_finish(
                f,
                "ContentQuery",
                "size",
                &self.size,
                "bookmark",
                &self.bookmark,
                "action",
                &self.action,
                "description",
                &&self.description,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for ContentQuery {
        #[inline]
        fn clone(&self) -> ContentQuery {
            ContentQuery {
                size: ::core::clone::Clone::clone(&self.size),
                bookmark: ::core::clone::Clone::clone(&self.bookmark),
                action: ::core::clone::Clone::clone(&self.action),
                description: ::core::clone::Clone::clone(&self.description),
            }
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for ContentQuery {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "ContentQuery",
                    false as usize + 1 + 1 + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "size",
                    &self.size,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "bookmark",
                    &self.bookmark,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "action",
                    &self.action,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "description",
                    &self.description,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for ContentQuery {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "size" => _serde::__private::Ok(__Field::__field0),
                            "bookmark" => _serde::__private::Ok(__Field::__field1),
                            "action" => _serde::__private::Ok(__Field::__field2),
                            "description" => _serde::__private::Ok(__Field::__field3),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"size" => _serde::__private::Ok(__Field::__field0),
                            b"bookmark" => _serde::__private::Ok(__Field::__field1),
                            b"action" => _serde::__private::Ok(__Field::__field2),
                            b"description" => _serde::__private::Ok(__Field::__field3),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<ContentQuery>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = ContentQuery;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct ContentQuery",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match {
                            #[doc(hidden)]
                            struct __DeserializeWith<'de> {
                                value: usize,
                                phantom: _serde::__private::PhantomData<ContentQuery>,
                                lifetime: _serde::__private::PhantomData<&'de ()>,
                            }
                            #[automatically_derived]
                            impl<'de> _serde::Deserialize<'de>
                            for __DeserializeWith<'de> {
                                fn deserialize<__D>(
                                    __deserializer: __D,
                                ) -> _serde::__private::Result<Self, __D::Error>
                                where
                                    __D: _serde::Deserializer<'de>,
                                {
                                    _serde::__private::Ok(__DeserializeWith {
                                        value: parse_size_of_content_query(__deserializer)?,
                                        phantom: _serde::__private::PhantomData,
                                        lifetime: _serde::__private::PhantomData,
                                    })
                                }
                            }
                            _serde::__private::Option::map(
                                _serde::de::SeqAccess::next_element::<
                                    __DeserializeWith<'de>,
                                >(&mut __seq)?,
                                |__wrap| __wrap.value,
                            )
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                _serde::__private::Default::default()
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            Option<String>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct ContentQuery with 4 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match _serde::de::SeqAccess::next_element::<
                            Option<ContentQueryActionType>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct ContentQuery with 4 elements",
                                    ),
                                );
                            }
                        };
                        let __field3 = match _serde::de::SeqAccess::next_element::<
                            Option<String>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        3usize,
                                        &"struct ContentQuery with 4 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(ContentQuery {
                            size: __field0,
                            bookmark: __field1,
                            action: __field2,
                            description: __field3,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<usize> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<Option<String>> = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<
                            Option<ContentQueryActionType>,
                        > = _serde::__private::None;
                        let mut __field3: _serde::__private::Option<Option<String>> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("size"),
                                        );
                                    }
                                    __field0 = _serde::__private::Some({
                                        #[doc(hidden)]
                                        struct __DeserializeWith<'de> {
                                            value: usize,
                                            phantom: _serde::__private::PhantomData<ContentQuery>,
                                            lifetime: _serde::__private::PhantomData<&'de ()>,
                                        }
                                        #[automatically_derived]
                                        impl<'de> _serde::Deserialize<'de>
                                        for __DeserializeWith<'de> {
                                            fn deserialize<__D>(
                                                __deserializer: __D,
                                            ) -> _serde::__private::Result<Self, __D::Error>
                                            where
                                                __D: _serde::Deserializer<'de>,
                                            {
                                                _serde::__private::Ok(__DeserializeWith {
                                                    value: parse_size_of_content_query(__deserializer)?,
                                                    phantom: _serde::__private::PhantomData,
                                                    lifetime: _serde::__private::PhantomData,
                                                })
                                            }
                                        }
                                        match _serde::de::MapAccess::next_value::<
                                            __DeserializeWith<'de>,
                                        >(&mut __map) {
                                            _serde::__private::Ok(__wrapper) => __wrapper.value,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        }
                                    });
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "bookmark",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<String>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("action"),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<ContentQueryActionType>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field3 => {
                                    if _serde::__private::Option::is_some(&__field3) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "description",
                                            ),
                                        );
                                    }
                                    __field3 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<String>,
                                        >(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::Default::default()
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("bookmark")?
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("action")?
                            }
                        };
                        let __field3 = match __field3 {
                            _serde::__private::Some(__field3) => __field3,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("description")?
                            }
                        };
                        _serde::__private::Ok(ContentQuery {
                            size: __field0,
                            bookmark: __field1,
                            action: __field2,
                            description: __field3,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "size",
                    "bookmark",
                    "action",
                    "description",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "ContentQuery",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<ContentQuery>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::default::Default for ContentQuery {
        #[inline]
        fn default() -> ContentQuery {
            ContentQuery {
                size: ::core::default::Default::default(),
                bookmark: ::core::default::Default::default(),
                action: ::core::default::Default::default(),
                description: ::core::default::Default::default(),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for ContentQuery {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for ContentQuery {
        #[inline]
        fn eq(&self, other: &ContentQuery) -> bool {
            self.size == other.size && self.bookmark == other.bookmark
                && self.action == other.action && self.description == other.description
        }
    }
    impl std::fmt::Display for ContentQuery {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let query = serde_urlencoded::to_string(&self).map_err(|_| std::fmt::Error)?;
            f.write_fmt(format_args!("{0}", query))
        }
    }
    impl ::validator::Validate for ContentQuery {
        fn validate(&self) -> ::std::result::Result<(), ::validator::ValidationErrors> {
            use ::validator::ValidateArgs;
            self.validate_with_args(())
        }
    }
    impl<'v_a> ::validator::ValidateArgs<'v_a> for ContentQuery {
        type Args = ();
        fn validate_with_args(
            &self,
            args: Self::Args,
        ) -> ::std::result::Result<(), ::validator::ValidationErrors> {
            let mut errors = ::validator::ValidationErrors::new();
            if errors.is_empty() {
                ::std::result::Result::Ok(())
            } else {
                ::std::result::Result::Err(errors)
            }
        }
    }
    pub fn parse_size_of_content_query<'de, D>(
        deserializer: D,
    ) -> std::result::Result<usize, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::Deserialize;
        let s: Option<String> = Option::deserialize(deserializer)?;
        s.unwrap_or_else(|| Default::default())
            .parse::<usize>()
            .map_err(serde::de::Error::custom)
    }
    impl ContentQuery {
        pub fn new(size: usize) -> Self {
            Self { size, ..Self::default() }
        }
        pub fn with_bookmark(mut self, bookmark: String) -> Self {
            self.bookmark = Some(bookmark);
            self
        }
        pub fn with_page(mut self, page: usize) -> Self {
            self.bookmark = Some(page.to_string());
            self
        }
        /// Returns the size(i32) of the query
        pub fn size(&self) -> i32 {
            self.size as i32
        }
        pub fn page(&self) -> i32 {
            self.bookmark.as_ref().unwrap_or(&"1".to_string()).parse().unwrap_or(1)
        }
        pub fn search(mut self, description: String) -> Self {
            self.description = Some(description);
            self.action = Some(ContentQueryActionType::Search);
            self
        }
    }
    #[serde(rename_all = "kebab-case")]
    pub enum ContentQueryActionType {
        Search,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for ContentQueryActionType {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Search")
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for ContentQueryActionType {
        #[inline]
        fn clone(&self) -> ContentQueryActionType {
            ContentQueryActionType::Search
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for ContentQueryActionType {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for ContentQueryActionType {
        #[inline]
        fn eq(&self, other: &ContentQueryActionType) -> bool {
            true
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for ContentQueryActionType {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    ContentQueryActionType::Search => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "ContentQueryActionType",
                            0u32,
                            "search",
                        )
                    }
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for ContentQueryActionType {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "variant identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::invalid_value(
                                        _serde::de::Unexpected::Unsigned(__value),
                                        &"variant index 0 <= i < 1",
                                    ),
                                )
                            }
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "search" => _serde::__private::Ok(__Field::__field0),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"search" => _serde::__private::Ok(__Field::__field0),
                            _ => {
                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<ContentQueryActionType>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = ContentQueryActionType;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "enum ContentQueryActionType",
                        )
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match _serde::de::EnumAccess::variant(__data)? {
                            (__Field::__field0, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(ContentQueryActionType::Search)
                            }
                        }
                    }
                }
                #[doc(hidden)]
                const VARIANTS: &'static [&'static str] = &["search"];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "ContentQueryActionType",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<ContentQueryActionType>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    impl ContentClient {
        pub async fn search(
            &self,
            size: usize,
            bookmark: Option<String>,
            description: String,
        ) -> crate::Result<by_types::QueryResponse<ContentSummary>> {
            let path = ::alloc::__export::must_use({
                let res = ::alloc::fmt::format(format_args!("/v1/contents"));
                res
            });
            let endpoint = ::alloc::__export::must_use({
                let res = ::alloc::fmt::format(
                    format_args!("{0}{1}", self.endpoint, path),
                );
                res
            });
            let params = ContentParam::Query(ContentQuery {
                size,
                bookmark,
                action: Some(ContentQueryActionType::Search),
                description: Some(description),
                ..ContentQuery::default()
            });
            let query = ::alloc::__export::must_use({
                let res = ::alloc::fmt::format(
                    format_args!("{0}?{1}", endpoint, params),
                );
                res
            });
            rest_api::get(&query).await
        }
    }
    impl Content {
        pub fn get_client(endpoint: &str) -> ContentClient {
            ContentClient {
                endpoint: endpoint.to_string(),
            }
        }
    }
    pub struct ContentClient {
        pub endpoint: String,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for ContentClient {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field1_finish(
                f,
                "ContentClient",
                "endpoint",
                &&self.endpoint,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for ContentClient {
        #[inline]
        fn clone(&self) -> ContentClient {
            ContentClient {
                endpoint: ::core::clone::Clone::clone(&self.endpoint),
            }
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for ContentClient {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "ContentClient",
                    false as usize + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "endpoint",
                    &self.endpoint,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for ContentClient {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "endpoint" => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"endpoint" => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<ContentClient>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = ContentClient;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct ContentClient",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct ContentClient with 1 element",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(ContentClient {
                            endpoint: __field0,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "endpoint",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("endpoint")?
                            }
                        };
                        _serde::__private::Ok(ContentClient {
                            endpoint: __field0,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &["endpoint"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "ContentClient",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<ContentClient>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::default::Default for ContentClient {
        #[inline]
        fn default() -> ContentClient {
            ContentClient {
                endpoint: ::core::default::Default::default(),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for ContentClient {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for ContentClient {
        #[inline]
        fn eq(&self, other: &ContentClient) -> bool {
            self.endpoint == other.endpoint
        }
    }
    impl ContentClient {
        pub async fn query(
            &self,
            params: ContentQuery,
        ) -> crate::Result<by_types::QueryResponse<ContentSummary>> {
            let path = ::alloc::__export::must_use({
                let res = ::alloc::fmt::format(format_args!("/v1/contents"));
                res
            });
            let endpoint = ::alloc::__export::must_use({
                let res = ::alloc::fmt::format(
                    format_args!("{0}{1}", self.endpoint, path),
                );
                res
            });
            let query = ::alloc::__export::must_use({
                let res = ::alloc::fmt::format(
                    format_args!("{0}?{1}", endpoint, ContentParam::Query(params)),
                );
                res
            });
            rest_api::get(&query).await
        }
        pub async fn query_by_custom(
            &self,
            params: ContentQueryBy,
        ) -> crate::Result<by_types::QueryResponse<ContentSummary>> {
            let path = ::alloc::__export::must_use({
                let res = ::alloc::fmt::format(format_args!("/v1/contents"));
                res
            });
            let endpoint = ::alloc::__export::must_use({
                let res = ::alloc::fmt::format(
                    format_args!("{0}{1}", self.endpoint, path),
                );
                res
            });
            let query = ::alloc::__export::must_use({
                let res = ::alloc::fmt::format(
                    format_args!("{0}?{1}", endpoint, ContentParam::Custom(params)),
                );
                res
            });
            rest_api::get(&query).await
        }
        pub async fn get(&self, id: i64) -> crate::Result<Content> {
            let path = ::alloc::__export::must_use({
                let res = ::alloc::fmt::format(format_args!("/v1/contents"));
                res
            });
            let endpoint = ::alloc::__export::must_use({
                let res = ::alloc::fmt::format(
                    format_args!("{0}{1}/{2}", self.endpoint, path, id),
                );
                res
            });
            rest_api::get(&endpoint).await
        }
    }
    impl Content {
        pub fn url() -> String {
            "/v1/contents".to_string()
        }
    }
    pub struct ContentReadAction {}
    #[automatically_derived]
    impl ::core::fmt::Debug for ContentReadAction {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "ContentReadAction")
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for ContentReadAction {
        #[inline]
        fn clone(&self) -> ContentReadAction {
            ContentReadAction {}
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for ContentReadAction {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "ContentReadAction",
                    false as usize,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for ContentReadAction {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<ContentReadAction>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = ContentReadAction;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct ContentReadAction",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        _: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        _serde::__private::Ok(ContentReadAction {})
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        _serde::__private::Ok(ContentReadAction {})
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "ContentReadAction",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<ContentReadAction>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::default::Default for ContentReadAction {
        #[inline]
        fn default() -> ContentReadAction {
            ContentReadAction {}
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for ContentReadAction {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for ContentReadAction {
        #[inline]
        fn eq(&self, other: &ContentReadAction) -> bool {
            true
        }
    }
    impl std::fmt::Display for ContentReadAction {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let query = serde_urlencoded::to_string(&self).map_err(|_| std::fmt::Error)?;
            f.write_fmt(format_args!("{0}", query))
        }
    }
    impl ::validator::Validate for ContentReadAction {
        fn validate(&self) -> ::std::result::Result<(), ::validator::ValidationErrors> {
            use ::validator::ValidateArgs;
            self.validate_with_args(())
        }
    }
    impl<'v_a> ::validator::ValidateArgs<'v_a> for ContentReadAction {
        type Args = ();
        fn validate_with_args(
            &self,
            args: Self::Args,
        ) -> ::std::result::Result<(), ::validator::ValidationErrors> {
            let mut errors = ::validator::ValidationErrors::new();
            if errors.is_empty() {
                ::std::result::Result::Ok(())
            } else {
                ::std::result::Result::Err(errors)
            }
        }
    }
    impl ContentReadAction {
        pub fn new() -> Self {
            Self::default()
        }
    }
    impl ContentClient {}
    #[serde(tag = "param-type", rename_all = "kebab-case")]
    pub enum ContentParam {
        Query(ContentQuery),
        Custom(ContentQueryBy),
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for ContentParam {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                ContentParam::Query(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Query",
                        &__self_0,
                    )
                }
                ContentParam::Custom(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Custom",
                        &__self_0,
                    )
                }
            }
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for ContentParam {
        #[inline]
        fn clone(&self) -> ContentParam {
            match self {
                ContentParam::Query(__self_0) => {
                    ContentParam::Query(::core::clone::Clone::clone(__self_0))
                }
                ContentParam::Custom(__self_0) => {
                    ContentParam::Custom(::core::clone::Clone::clone(__self_0))
                }
            }
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for ContentParam {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    ContentParam::Query(ref __field0) => {
                        _serde::__private::ser::serialize_tagged_newtype(
                            __serializer,
                            "ContentParam",
                            "Query",
                            "param-type",
                            "query",
                            __field0,
                        )
                    }
                    ContentParam::Custom(ref __field0) => {
                        _serde::__private::ser::serialize_tagged_newtype(
                            __serializer,
                            "ContentParam",
                            "Custom",
                            "param-type",
                            "custom",
                            __field0,
                        )
                    }
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for ContentParam {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "variant identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::invalid_value(
                                        _serde::de::Unexpected::Unsigned(__value),
                                        &"variant index 0 <= i < 2",
                                    ),
                                )
                            }
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "query" => _serde::__private::Ok(__Field::__field0),
                            "custom" => _serde::__private::Ok(__Field::__field1),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"query" => _serde::__private::Ok(__Field::__field0),
                            b"custom" => _serde::__private::Ok(__Field::__field1),
                            _ => {
                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                const VARIANTS: &'static [&'static str] = &["query", "custom"];
                let (__tag, __content) = _serde::Deserializer::deserialize_any(
                    __deserializer,
                    _serde::__private::de::TaggedContentVisitor::<
                        __Field,
                    >::new("param-type", "internally tagged enum ContentParam"),
                )?;
                let __deserializer = _serde::__private::de::ContentDeserializer::<
                    __D::Error,
                >::new(__content);
                match __tag {
                    __Field::__field0 => {
                        _serde::__private::Result::map(
                            <ContentQuery as _serde::Deserialize>::deserialize(
                                __deserializer,
                            ),
                            ContentParam::Query,
                        )
                    }
                    __Field::__field1 => {
                        _serde::__private::Result::map(
                            <ContentQueryBy as _serde::Deserialize>::deserialize(
                                __deserializer,
                            ),
                            ContentParam::Custom,
                        )
                    }
                }
            }
        }
    };
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for ContentParam {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for ContentParam {
        #[inline]
        fn eq(&self, other: &ContentParam) -> bool {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            let __arg1_discr = ::core::intrinsics::discriminant_value(other);
            __self_discr == __arg1_discr
                && match (self, other) {
                    (ContentParam::Query(__self_0), ContentParam::Query(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (ContentParam::Custom(__self_0), ContentParam::Custom(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    _ => unsafe { ::core::intrinsics::unreachable() }
                }
        }
    }
    impl std::fmt::Display for ContentParam {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let query = serde_urlencoded::to_string(&self).map_err(|_| std::fmt::Error)?;
            f.write_fmt(format_args!("{0}", query))
        }
    }
    #[serde(tag = "param_type")]
    #[serde(rename_all = "snake_case")]
    pub enum ContentGetResponse {
        Query(by_types::QueryResponse<ContentSummary>),
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for ContentGetResponse {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                ContentGetResponse::Query(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Query",
                        &__self_0,
                    )
                }
            }
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for ContentGetResponse {
        #[inline]
        fn clone(&self) -> ContentGetResponse {
            match self {
                ContentGetResponse::Query(__self_0) => {
                    ContentGetResponse::Query(::core::clone::Clone::clone(__self_0))
                }
            }
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for ContentGetResponse {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    ContentGetResponse::Query(ref __field0) => {
                        _serde::__private::ser::serialize_tagged_newtype(
                            __serializer,
                            "ContentGetResponse",
                            "Query",
                            "param_type",
                            "query",
                            __field0,
                        )
                    }
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for ContentGetResponse {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "variant identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::invalid_value(
                                        _serde::de::Unexpected::Unsigned(__value),
                                        &"variant index 0 <= i < 1",
                                    ),
                                )
                            }
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "query" => _serde::__private::Ok(__Field::__field0),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"query" => _serde::__private::Ok(__Field::__field0),
                            _ => {
                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                const VARIANTS: &'static [&'static str] = &["query"];
                let (__tag, __content) = _serde::Deserializer::deserialize_any(
                    __deserializer,
                    _serde::__private::de::TaggedContentVisitor::<
                        __Field,
                    >::new("param_type", "internally tagged enum ContentGetResponse"),
                )?;
                let __deserializer = _serde::__private::de::ContentDeserializer::<
                    __D::Error,
                >::new(__content);
                match __tag {
                    __Field::__field0 => {
                        _serde::__private::Result::map(
                            <by_types::QueryResponse<
                                ContentSummary,
                            > as _serde::Deserialize>::deserialize(__deserializer),
                            ContentGetResponse::Query,
                        )
                    }
                }
            }
        }
    };
    impl ::validator::Validate for Content {
        fn validate(&self) -> ::std::result::Result<(), ::validator::ValidationErrors> {
            use ::validator::ValidateArgs;
            self.validate_with_args(())
        }
    }
    impl<'v_a> ::validator::ValidateArgs<'v_a> for Content {
        type Args = ();
        fn validate_with_args(
            &self,
            args: Self::Args,
        ) -> ::std::result::Result<(), ::validator::ValidationErrors> {
            use ::validator::ValidateUrl;
            let mut errors = ::validator::ValidationErrors::new();
            if !self.thumbnail_image.validate_url() {
                let mut err = ::validator::ValidationError::new("url");
                err.add_param(::std::borrow::Cow::from("value"), &self.thumbnail_image);
                errors.add("thumbnail_image", err);
            }
            if !self.source.validate_url() {
                let mut err = ::validator::ValidationError::new("url");
                err.add_param(::std::borrow::Cow::from("value"), &self.source);
                errors.add("source", err);
            }
            if errors.is_empty() {
                ::std::result::Result::Ok(())
            } else {
                ::std::result::Result::Err(errors)
            }
        }
    }
    #[serde(rename_all = "snake_case")]
    pub struct ContentQueryBy {
        pub sorter: ContentSorter,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for ContentQueryBy {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field1_finish(
                f,
                "ContentQueryBy",
                "sorter",
                &&self.sorter,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for ContentQueryBy {
        #[inline]
        fn clone(&self) -> ContentQueryBy {
            let _: ::core::clone::AssertParamIsClone<ContentSorter>;
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for ContentQueryBy {}
    #[automatically_derived]
    impl ::core::cmp::Eq for ContentQueryBy {
        #[inline]
        #[doc(hidden)]
        #[coverage(off)]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<ContentSorter>;
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for ContentQueryBy {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for ContentQueryBy {
        #[inline]
        fn eq(&self, other: &ContentQueryBy) -> bool {
            self.sorter == other.sorter
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for ContentQueryBy {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "ContentQueryBy",
                    false as usize + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "sorter",
                    &self.sorter,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for ContentQueryBy {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "sorter" => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"sorter" => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<ContentQueryBy>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = ContentQueryBy;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct ContentQueryBy",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            ContentSorter,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct ContentQueryBy with 1 element",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(ContentQueryBy { sorter: __field0 })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<ContentSorter> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("sorter"),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            ContentSorter,
                                        >(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("sorter")?
                            }
                        };
                        _serde::__private::Ok(ContentQueryBy { sorter: __field0 })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &["sorter"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "ContentQueryBy",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<ContentQueryBy>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::default::Default for ContentQueryBy {
        #[inline]
        fn default() -> ContentQueryBy {
            ContentQueryBy {
                sorter: ::core::default::Default::default(),
            }
        }
    }
    #[serde(rename_all = "snake_case")]
    pub enum ContentSorter {
        #[default]
        #[translate(ko = >"인기순")]
        Popular,
        #[translate(ko = >"최신순")]
        Newest,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for ContentSorter {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(
                f,
                match self {
                    ContentSorter::Popular => "Popular",
                    ContentSorter::Newest => "Newest",
                },
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for ContentSorter {
        #[inline]
        fn clone(&self) -> ContentSorter {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for ContentSorter {}
    #[automatically_derived]
    impl ::core::cmp::Eq for ContentSorter {
        #[inline]
        #[doc(hidden)]
        #[coverage(off)]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for ContentSorter {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for ContentSorter {
        #[inline]
        fn eq(&self, other: &ContentSorter) -> bool {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            let __arg1_discr = ::core::intrinsics::discriminant_value(other);
            __self_discr == __arg1_discr
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for ContentSorter {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    ContentSorter::Popular => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "ContentSorter",
                            0u32,
                            "popular",
                        )
                    }
                    ContentSorter::Newest => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "ContentSorter",
                            1u32,
                            "newest",
                        )
                    }
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for ContentSorter {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "variant identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::invalid_value(
                                        _serde::de::Unexpected::Unsigned(__value),
                                        &"variant index 0 <= i < 2",
                                    ),
                                )
                            }
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "popular" => _serde::__private::Ok(__Field::__field0),
                            "newest" => _serde::__private::Ok(__Field::__field1),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"popular" => _serde::__private::Ok(__Field::__field0),
                            b"newest" => _serde::__private::Ok(__Field::__field1),
                            _ => {
                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<ContentSorter>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = ContentSorter;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "enum ContentSorter",
                        )
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match _serde::de::EnumAccess::variant(__data)? {
                            (__Field::__field0, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(ContentSorter::Popular)
                            }
                            (__Field::__field1, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(ContentSorter::Newest)
                            }
                        }
                    }
                }
                #[doc(hidden)]
                const VARIANTS: &'static [&'static str] = &["popular", "newest"];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "ContentSorter",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<ContentSorter>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    impl ContentSorter {
        pub fn translate(&self, lang: &dioxus_translate::Language) -> &'static str {
            match lang {
                dioxus_translate::Language::En => {
                    match self {
                        ContentSorter::Popular => "Popular",
                        ContentSorter::Newest => "Newest",
                    }
                }
                dioxus_translate::Language::Ko => {
                    match self {
                        ContentSorter::Popular => "Popular",
                        ContentSorter::Newest => "Newest",
                    }
                }
            }
        }
        pub const VARIANTS: &'static [Self] = &[
            ContentSorter::Popular,
            ContentSorter::Newest,
        ];
        pub fn variants(lang: &dioxus_translate::Language) -> Vec<String> {
            Self::VARIANTS
                .iter()
                .map(|v| v.translate(&lang).to_string())
                .collect::<Vec<_>>()
        }
    }
    impl std::fmt::Display for ContentSorter {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match self {
                ContentSorter::Popular => f.write_fmt(format_args!("popular")),
                ContentSorter::Newest => f.write_fmt(format_args!("newest")),
            }
        }
    }
    impl std::str::FromStr for ContentSorter {
        type Err = String;
        fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
            match s {
                "Popular" | "popular" => Ok(ContentSorter::Popular),
                "Popular" => Ok(ContentSorter::Popular),
                "Newest" | "newest" => Ok(ContentSorter::Newest),
                "Newest" => Ok(ContentSorter::Newest),
                _ => {
                    Err(
                        ::alloc::__export::must_use({
                            let res = ::alloc::fmt::format(
                                format_args!("invalid field"),
                            );
                            res
                        }),
                    )
                }
            }
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for ContentSorter {
        #[inline]
        fn default() -> ContentSorter {
            Self::Popular
        }
    }
}
pub mod content_downloads {
    use by_macros::api_model;
    use validator::Validate;
    /// ContentDownload is a generated struct that represents the model
    ///
    /// For making API calls related to this model, use `ContentDownload::get_client(endpoint: &str)`.
    /// It will returns ContentDownloadClient struct that implements the API calls.
    ///
    /// In server side, you can use `ContentDownload::get_repository()` to interact with the database.
    /// Recommend to use `ContentDownloadRepository` to insert or update the model.
    /// To query the model, use `ContentDownload::query_builder()`.
    /// For more detail, refer to the documentation of the query builder.
    pub struct ContentDownload {
        pub id: i64,
        pub created_at: i64,
        pub updated_at: i64,
        pub user_id: i64,
        pub content_id: i64,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for ContentDownload {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field5_finish(
                f,
                "ContentDownload",
                "id",
                &self.id,
                "created_at",
                &self.created_at,
                "updated_at",
                &self.updated_at,
                "user_id",
                &self.user_id,
                "content_id",
                &&self.content_id,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for ContentDownload {
        #[inline]
        fn clone(&self) -> ContentDownload {
            ContentDownload {
                id: ::core::clone::Clone::clone(&self.id),
                created_at: ::core::clone::Clone::clone(&self.created_at),
                updated_at: ::core::clone::Clone::clone(&self.updated_at),
                user_id: ::core::clone::Clone::clone(&self.user_id),
                content_id: ::core::clone::Clone::clone(&self.content_id),
            }
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for ContentDownload {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __field4,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            4u64 => _serde::__private::Ok(__Field::__field4),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "id" => _serde::__private::Ok(__Field::__field0),
                            "created_at" => _serde::__private::Ok(__Field::__field1),
                            "updated_at" => _serde::__private::Ok(__Field::__field2),
                            "user_id" => _serde::__private::Ok(__Field::__field3),
                            "content_id" => _serde::__private::Ok(__Field::__field4),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"id" => _serde::__private::Ok(__Field::__field0),
                            b"created_at" => _serde::__private::Ok(__Field::__field1),
                            b"updated_at" => _serde::__private::Ok(__Field::__field2),
                            b"user_id" => _serde::__private::Ok(__Field::__field3),
                            b"content_id" => _serde::__private::Ok(__Field::__field4),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<ContentDownload>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = ContentDownload;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct ContentDownload",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            i64,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct ContentDownload with 5 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            i64,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct ContentDownload with 5 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match _serde::de::SeqAccess::next_element::<
                            i64,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct ContentDownload with 5 elements",
                                    ),
                                );
                            }
                        };
                        let __field3 = match _serde::de::SeqAccess::next_element::<
                            i64,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        3usize,
                                        &"struct ContentDownload with 5 elements",
                                    ),
                                );
                            }
                        };
                        let __field4 = match _serde::de::SeqAccess::next_element::<
                            i64,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        4usize,
                                        &"struct ContentDownload with 5 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(ContentDownload {
                            id: __field0,
                            created_at: __field1,
                            updated_at: __field2,
                            user_id: __field3,
                            content_id: __field4,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<i64> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<i64> = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<i64> = _serde::__private::None;
                        let mut __field3: _serde::__private::Option<i64> = _serde::__private::None;
                        let mut __field4: _serde::__private::Option<i64> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("id"),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<i64>(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "created_at",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<i64>(&mut __map)?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "updated_at",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<i64>(&mut __map)?,
                                    );
                                }
                                __Field::__field3 => {
                                    if _serde::__private::Option::is_some(&__field3) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "user_id",
                                            ),
                                        );
                                    }
                                    __field3 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<i64>(&mut __map)?,
                                    );
                                }
                                __Field::__field4 => {
                                    if _serde::__private::Option::is_some(&__field4) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "content_id",
                                            ),
                                        );
                                    }
                                    __field4 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<i64>(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("id")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("created_at")?
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("updated_at")?
                            }
                        };
                        let __field3 = match __field3 {
                            _serde::__private::Some(__field3) => __field3,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("user_id")?
                            }
                        };
                        let __field4 = match __field4 {
                            _serde::__private::Some(__field4) => __field4,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("content_id")?
                            }
                        };
                        _serde::__private::Ok(ContentDownload {
                            id: __field0,
                            created_at: __field1,
                            updated_at: __field2,
                            user_id: __field3,
                            content_id: __field4,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "id",
                    "created_at",
                    "updated_at",
                    "user_id",
                    "content_id",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "ContentDownload",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<ContentDownload>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for ContentDownload {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "ContentDownload",
                    false as usize + 1 + 1 + 1 + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "id",
                    &self.id,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "created_at",
                    &self.created_at,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "updated_at",
                    &self.updated_at,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "user_id",
                    &self.user_id,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "content_id",
                    &self.content_id,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[automatically_derived]
    impl ::core::default::Default for ContentDownload {
        #[inline]
        fn default() -> ContentDownload {
            ContentDownload {
                id: ::core::default::Default::default(),
                created_at: ::core::default::Default::default(),
                updated_at: ::core::default::Default::default(),
                user_id: ::core::default::Default::default(),
                content_id: ::core::default::Default::default(),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for ContentDownload {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for ContentDownload {
        #[inline]
        fn eq(&self, other: &ContentDownload) -> bool {
            self.id == other.id && self.created_at == other.created_at
                && self.updated_at == other.updated_at && self.user_id == other.user_id
                && self.content_id == other.content_id
        }
    }
    pub struct ContentDownloadSummary {
        pub id: i64,
        pub created_at: i64,
        pub updated_at: i64,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for ContentDownloadSummary {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "ContentDownloadSummary",
                "id",
                &self.id,
                "created_at",
                &self.created_at,
                "updated_at",
                &&self.updated_at,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for ContentDownloadSummary {
        #[inline]
        fn clone(&self) -> ContentDownloadSummary {
            ContentDownloadSummary {
                id: ::core::clone::Clone::clone(&self.id),
                created_at: ::core::clone::Clone::clone(&self.created_at),
                updated_at: ::core::clone::Clone::clone(&self.updated_at),
            }
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for ContentDownloadSummary {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "ContentDownloadSummary",
                    false as usize + 1 + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "id",
                    &self.id,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "created_at",
                    &self.created_at,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "updated_at",
                    &self.updated_at,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for ContentDownloadSummary {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "id" => _serde::__private::Ok(__Field::__field0),
                            "created_at" => _serde::__private::Ok(__Field::__field1),
                            "updated_at" => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"id" => _serde::__private::Ok(__Field::__field0),
                            b"created_at" => _serde::__private::Ok(__Field::__field1),
                            b"updated_at" => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<ContentDownloadSummary>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = ContentDownloadSummary;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct ContentDownloadSummary",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            i64,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct ContentDownloadSummary with 3 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            i64,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct ContentDownloadSummary with 3 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match _serde::de::SeqAccess::next_element::<
                            i64,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct ContentDownloadSummary with 3 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(ContentDownloadSummary {
                            id: __field0,
                            created_at: __field1,
                            updated_at: __field2,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<i64> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<i64> = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<i64> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("id"),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<i64>(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "created_at",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<i64>(&mut __map)?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "updated_at",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<i64>(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("id")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("created_at")?
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("updated_at")?
                            }
                        };
                        _serde::__private::Ok(ContentDownloadSummary {
                            id: __field0,
                            created_at: __field1,
                            updated_at: __field2,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "id",
                    "created_at",
                    "updated_at",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "ContentDownloadSummary",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<ContentDownloadSummary>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::default::Default for ContentDownloadSummary {
        #[inline]
        fn default() -> ContentDownloadSummary {
            ContentDownloadSummary {
                id: ::core::default::Default::default(),
                created_at: ::core::default::Default::default(),
                updated_at: ::core::default::Default::default(),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for ContentDownloadSummary {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for ContentDownloadSummary {
        #[inline]
        fn eq(&self, other: &ContentDownloadSummary) -> bool {
            self.id == other.id && self.created_at == other.created_at
                && self.updated_at == other.updated_at
        }
    }
    impl From<ContentDownload> for ContentDownloadSummary {
        fn from(item: ContentDownload) -> Self {
            Self {
                id: item.id,
                created_at: item.created_at,
                updated_at: item.updated_at,
            }
        }
    }
    impl Into<ContentDownload> for ContentDownloadSummary {
        fn into(self) -> ContentDownload {
            ContentDownload {
                id: self.id,
                created_at: self.created_at,
                updated_at: self.updated_at,
                ..Default::default()
            }
        }
    }
    #[serde(rename_all = "kebab-case")]
    pub struct ContentDownloadQuery {
        #[serde(deserialize_with = "parse_size_of_content_download_query", default)]
        pub size: usize,
        pub bookmark: Option<String>,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for ContentDownloadQuery {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(
                f,
                "ContentDownloadQuery",
                "size",
                &self.size,
                "bookmark",
                &&self.bookmark,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for ContentDownloadQuery {
        #[inline]
        fn clone(&self) -> ContentDownloadQuery {
            ContentDownloadQuery {
                size: ::core::clone::Clone::clone(&self.size),
                bookmark: ::core::clone::Clone::clone(&self.bookmark),
            }
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for ContentDownloadQuery {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "ContentDownloadQuery",
                    false as usize + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "size",
                    &self.size,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "bookmark",
                    &self.bookmark,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for ContentDownloadQuery {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "size" => _serde::__private::Ok(__Field::__field0),
                            "bookmark" => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"size" => _serde::__private::Ok(__Field::__field0),
                            b"bookmark" => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<ContentDownloadQuery>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = ContentDownloadQuery;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct ContentDownloadQuery",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match {
                            #[doc(hidden)]
                            struct __DeserializeWith<'de> {
                                value: usize,
                                phantom: _serde::__private::PhantomData<
                                    ContentDownloadQuery,
                                >,
                                lifetime: _serde::__private::PhantomData<&'de ()>,
                            }
                            #[automatically_derived]
                            impl<'de> _serde::Deserialize<'de>
                            for __DeserializeWith<'de> {
                                fn deserialize<__D>(
                                    __deserializer: __D,
                                ) -> _serde::__private::Result<Self, __D::Error>
                                where
                                    __D: _serde::Deserializer<'de>,
                                {
                                    _serde::__private::Ok(__DeserializeWith {
                                        value: parse_size_of_content_download_query(
                                            __deserializer,
                                        )?,
                                        phantom: _serde::__private::PhantomData,
                                        lifetime: _serde::__private::PhantomData,
                                    })
                                }
                            }
                            _serde::__private::Option::map(
                                _serde::de::SeqAccess::next_element::<
                                    __DeserializeWith<'de>,
                                >(&mut __seq)?,
                                |__wrap| __wrap.value,
                            )
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                _serde::__private::Default::default()
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            Option<String>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct ContentDownloadQuery with 2 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(ContentDownloadQuery {
                            size: __field0,
                            bookmark: __field1,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<usize> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<Option<String>> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("size"),
                                        );
                                    }
                                    __field0 = _serde::__private::Some({
                                        #[doc(hidden)]
                                        struct __DeserializeWith<'de> {
                                            value: usize,
                                            phantom: _serde::__private::PhantomData<
                                                ContentDownloadQuery,
                                            >,
                                            lifetime: _serde::__private::PhantomData<&'de ()>,
                                        }
                                        #[automatically_derived]
                                        impl<'de> _serde::Deserialize<'de>
                                        for __DeserializeWith<'de> {
                                            fn deserialize<__D>(
                                                __deserializer: __D,
                                            ) -> _serde::__private::Result<Self, __D::Error>
                                            where
                                                __D: _serde::Deserializer<'de>,
                                            {
                                                _serde::__private::Ok(__DeserializeWith {
                                                    value: parse_size_of_content_download_query(
                                                        __deserializer,
                                                    )?,
                                                    phantom: _serde::__private::PhantomData,
                                                    lifetime: _serde::__private::PhantomData,
                                                })
                                            }
                                        }
                                        match _serde::de::MapAccess::next_value::<
                                            __DeserializeWith<'de>,
                                        >(&mut __map) {
                                            _serde::__private::Ok(__wrapper) => __wrapper.value,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        }
                                    });
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "bookmark",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<String>,
                                        >(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::Default::default()
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("bookmark")?
                            }
                        };
                        _serde::__private::Ok(ContentDownloadQuery {
                            size: __field0,
                            bookmark: __field1,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &["size", "bookmark"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "ContentDownloadQuery",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<ContentDownloadQuery>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::default::Default for ContentDownloadQuery {
        #[inline]
        fn default() -> ContentDownloadQuery {
            ContentDownloadQuery {
                size: ::core::default::Default::default(),
                bookmark: ::core::default::Default::default(),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for ContentDownloadQuery {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for ContentDownloadQuery {
        #[inline]
        fn eq(&self, other: &ContentDownloadQuery) -> bool {
            self.size == other.size && self.bookmark == other.bookmark
        }
    }
    impl std::fmt::Display for ContentDownloadQuery {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let query = serde_urlencoded::to_string(&self).map_err(|_| std::fmt::Error)?;
            f.write_fmt(format_args!("{0}", query))
        }
    }
    pub fn parse_size_of_content_download_query<'de, D>(
        deserializer: D,
    ) -> std::result::Result<usize, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::Deserialize;
        let s: Option<String> = Option::deserialize(deserializer)?;
        s.unwrap_or_else(|| Default::default())
            .parse::<usize>()
            .map_err(serde::de::Error::custom)
    }
    impl ContentDownloadQuery {
        pub fn new(size: usize) -> Self {
            Self { size, ..Self::default() }
        }
        pub fn with_bookmark(mut self, bookmark: String) -> Self {
            self.bookmark = Some(bookmark);
            self
        }
        pub fn with_page(mut self, page: usize) -> Self {
            self.bookmark = Some(page.to_string());
            self
        }
        /// Returns the size(i32) of the query
        pub fn size(&self) -> i32 {
            self.size as i32
        }
        pub fn page(&self) -> i32 {
            self.bookmark.as_ref().unwrap_or(&"1".to_string()).parse().unwrap_or(1)
        }
    }
    impl ContentDownloadClient {}
    impl ContentDownload {
        pub fn get_client(endpoint: &str) -> ContentDownloadClient {
            ContentDownloadClient {
                endpoint: endpoint.to_string(),
            }
        }
    }
    pub struct ContentDownloadClient {
        pub endpoint: String,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for ContentDownloadClient {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field1_finish(
                f,
                "ContentDownloadClient",
                "endpoint",
                &&self.endpoint,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for ContentDownloadClient {
        #[inline]
        fn clone(&self) -> ContentDownloadClient {
            ContentDownloadClient {
                endpoint: ::core::clone::Clone::clone(&self.endpoint),
            }
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for ContentDownloadClient {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "ContentDownloadClient",
                    false as usize + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "endpoint",
                    &self.endpoint,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for ContentDownloadClient {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "endpoint" => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"endpoint" => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<ContentDownloadClient>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = ContentDownloadClient;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct ContentDownloadClient",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct ContentDownloadClient with 1 element",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(ContentDownloadClient {
                            endpoint: __field0,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "endpoint",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("endpoint")?
                            }
                        };
                        _serde::__private::Ok(ContentDownloadClient {
                            endpoint: __field0,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &["endpoint"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "ContentDownloadClient",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<ContentDownloadClient>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::default::Default for ContentDownloadClient {
        #[inline]
        fn default() -> ContentDownloadClient {
            ContentDownloadClient {
                endpoint: ::core::default::Default::default(),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for ContentDownloadClient {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for ContentDownloadClient {
        #[inline]
        fn eq(&self, other: &ContentDownloadClient) -> bool {
            self.endpoint == other.endpoint
        }
    }
    impl ContentDownloadClient {
        pub async fn query(
            &self,
            params: ContentDownloadQuery,
        ) -> crate::Result<by_types::QueryResponse<ContentDownloadSummary>> {
            let path = ::alloc::__export::must_use({
                let res = ::alloc::fmt::format(format_args!("/"));
                res
            });
            let endpoint = ::alloc::__export::must_use({
                let res = ::alloc::fmt::format(
                    format_args!("{0}{1}", self.endpoint, path),
                );
                res
            });
            let query = ::alloc::__export::must_use({
                let res = ::alloc::fmt::format(
                    format_args!(
                        "{0}?{1}",
                        endpoint,
                        ContentDownloadParam::Query(params),
                    ),
                );
                res
            });
            rest_api::get(&query).await
        }
        pub async fn get(&self, id: i64) -> crate::Result<ContentDownload> {
            let path = ::alloc::__export::must_use({
                let res = ::alloc::fmt::format(format_args!("/"));
                res
            });
            let endpoint = ::alloc::__export::must_use({
                let res = ::alloc::fmt::format(
                    format_args!("{0}{1}/{2}", self.endpoint, path, id),
                );
                res
            });
            rest_api::get(&endpoint).await
        }
    }
    impl ContentDownload {
        pub fn url() -> String {
            "/".to_string()
        }
    }
    pub struct ContentDownloadReadAction {}
    #[automatically_derived]
    impl ::core::fmt::Debug for ContentDownloadReadAction {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "ContentDownloadReadAction")
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for ContentDownloadReadAction {
        #[inline]
        fn clone(&self) -> ContentDownloadReadAction {
            ContentDownloadReadAction {}
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for ContentDownloadReadAction {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "ContentDownloadReadAction",
                    false as usize,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for ContentDownloadReadAction {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<ContentDownloadReadAction>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = ContentDownloadReadAction;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct ContentDownloadReadAction",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        _: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        _serde::__private::Ok(ContentDownloadReadAction {})
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        _serde::__private::Ok(ContentDownloadReadAction {})
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "ContentDownloadReadAction",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<
                            ContentDownloadReadAction,
                        >,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::default::Default for ContentDownloadReadAction {
        #[inline]
        fn default() -> ContentDownloadReadAction {
            ContentDownloadReadAction {}
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for ContentDownloadReadAction {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for ContentDownloadReadAction {
        #[inline]
        fn eq(&self, other: &ContentDownloadReadAction) -> bool {
            true
        }
    }
    impl std::fmt::Display for ContentDownloadReadAction {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let query = serde_urlencoded::to_string(&self).map_err(|_| std::fmt::Error)?;
            f.write_fmt(format_args!("{0}", query))
        }
    }
    impl ContentDownloadReadAction {
        pub fn new() -> Self {
            Self::default()
        }
    }
    impl ContentDownloadClient {}
    #[serde(tag = "param-type", rename_all = "kebab-case")]
    pub enum ContentDownloadParam {
        Query(ContentDownloadQuery),
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for ContentDownloadParam {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                ContentDownloadParam::Query(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Query",
                        &__self_0,
                    )
                }
            }
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for ContentDownloadParam {
        #[inline]
        fn clone(&self) -> ContentDownloadParam {
            match self {
                ContentDownloadParam::Query(__self_0) => {
                    ContentDownloadParam::Query(::core::clone::Clone::clone(__self_0))
                }
            }
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for ContentDownloadParam {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    ContentDownloadParam::Query(ref __field0) => {
                        _serde::__private::ser::serialize_tagged_newtype(
                            __serializer,
                            "ContentDownloadParam",
                            "Query",
                            "param-type",
                            "query",
                            __field0,
                        )
                    }
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for ContentDownloadParam {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "variant identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::invalid_value(
                                        _serde::de::Unexpected::Unsigned(__value),
                                        &"variant index 0 <= i < 1",
                                    ),
                                )
                            }
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "query" => _serde::__private::Ok(__Field::__field0),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"query" => _serde::__private::Ok(__Field::__field0),
                            _ => {
                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                const VARIANTS: &'static [&'static str] = &["query"];
                let (__tag, __content) = _serde::Deserializer::deserialize_any(
                    __deserializer,
                    _serde::__private::de::TaggedContentVisitor::<
                        __Field,
                    >::new("param-type", "internally tagged enum ContentDownloadParam"),
                )?;
                let __deserializer = _serde::__private::de::ContentDeserializer::<
                    __D::Error,
                >::new(__content);
                match __tag {
                    __Field::__field0 => {
                        _serde::__private::Result::map(
                            <ContentDownloadQuery as _serde::Deserialize>::deserialize(
                                __deserializer,
                            ),
                            ContentDownloadParam::Query,
                        )
                    }
                }
            }
        }
    };
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for ContentDownloadParam {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for ContentDownloadParam {
        #[inline]
        fn eq(&self, other: &ContentDownloadParam) -> bool {
            match (self, other) {
                (
                    ContentDownloadParam::Query(__self_0),
                    ContentDownloadParam::Query(__arg1_0),
                ) => __self_0 == __arg1_0,
            }
        }
    }
    impl std::fmt::Display for ContentDownloadParam {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let query = serde_urlencoded::to_string(&self).map_err(|_| std::fmt::Error)?;
            f.write_fmt(format_args!("{0}", query))
        }
    }
    #[serde(tag = "param_type")]
    #[serde(rename_all = "snake_case")]
    pub enum ContentDownloadGetResponse {
        Query(by_types::QueryResponse<ContentDownloadSummary>),
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for ContentDownloadGetResponse {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                ContentDownloadGetResponse::Query(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Query",
                        &__self_0,
                    )
                }
            }
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for ContentDownloadGetResponse {
        #[inline]
        fn clone(&self) -> ContentDownloadGetResponse {
            match self {
                ContentDownloadGetResponse::Query(__self_0) => {
                    ContentDownloadGetResponse::Query(
                        ::core::clone::Clone::clone(__self_0),
                    )
                }
            }
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for ContentDownloadGetResponse {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    ContentDownloadGetResponse::Query(ref __field0) => {
                        _serde::__private::ser::serialize_tagged_newtype(
                            __serializer,
                            "ContentDownloadGetResponse",
                            "Query",
                            "param_type",
                            "query",
                            __field0,
                        )
                    }
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for ContentDownloadGetResponse {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "variant identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::invalid_value(
                                        _serde::de::Unexpected::Unsigned(__value),
                                        &"variant index 0 <= i < 1",
                                    ),
                                )
                            }
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "query" => _serde::__private::Ok(__Field::__field0),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"query" => _serde::__private::Ok(__Field::__field0),
                            _ => {
                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                const VARIANTS: &'static [&'static str] = &["query"];
                let (__tag, __content) = _serde::Deserializer::deserialize_any(
                    __deserializer,
                    _serde::__private::de::TaggedContentVisitor::<
                        __Field,
                    >::new(
                        "param_type",
                        "internally tagged enum ContentDownloadGetResponse",
                    ),
                )?;
                let __deserializer = _serde::__private::de::ContentDeserializer::<
                    __D::Error,
                >::new(__content);
                match __tag {
                    __Field::__field0 => {
                        _serde::__private::Result::map(
                            <by_types::QueryResponse<
                                ContentDownloadSummary,
                            > as _serde::Deserialize>::deserialize(__deserializer),
                            ContentDownloadGetResponse::Query,
                        )
                    }
                }
            }
        }
    };
    impl ::validator::Validate for ContentDownload {
        fn validate(&self) -> ::std::result::Result<(), ::validator::ValidationErrors> {
            use ::validator::ValidateArgs;
            self.validate_with_args(())
        }
    }
    impl<'v_a> ::validator::ValidateArgs<'v_a> for ContentDownload {
        type Args = ();
        fn validate_with_args(
            &self,
            args: Self::Args,
        ) -> ::std::result::Result<(), ::validator::ValidationErrors> {
            let mut errors = ::validator::ValidationErrors::new();
            if errors.is_empty() {
                ::std::result::Result::Ok(())
            } else {
                ::std::result::Result::Err(errors)
            }
        }
    }
}
pub mod content_likes {
    use by_macros::api_model;
    use validator::Validate;
    /// ContentLike is a generated struct that represents the model
    ///
    /// For making API calls related to this model, use `ContentLike::get_client(endpoint: &str)`.
    /// It will returns ContentLikeClient struct that implements the API calls.
    ///
    /// In server side, you can use `ContentLike::get_repository()` to interact with the database.
    /// Recommend to use `ContentLikeRepository` to insert or update the model.
    /// To query the model, use `ContentLike::query_builder()`.
    /// For more detail, refer to the documentation of the query builder.
    pub struct ContentLike {
        pub id: i64,
        pub created_at: i64,
        pub updated_at: i64,
        pub user_id: i64,
        pub content_id: i64,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for ContentLike {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field5_finish(
                f,
                "ContentLike",
                "id",
                &self.id,
                "created_at",
                &self.created_at,
                "updated_at",
                &self.updated_at,
                "user_id",
                &self.user_id,
                "content_id",
                &&self.content_id,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for ContentLike {
        #[inline]
        fn clone(&self) -> ContentLike {
            ContentLike {
                id: ::core::clone::Clone::clone(&self.id),
                created_at: ::core::clone::Clone::clone(&self.created_at),
                updated_at: ::core::clone::Clone::clone(&self.updated_at),
                user_id: ::core::clone::Clone::clone(&self.user_id),
                content_id: ::core::clone::Clone::clone(&self.content_id),
            }
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for ContentLike {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __field4,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            4u64 => _serde::__private::Ok(__Field::__field4),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "id" => _serde::__private::Ok(__Field::__field0),
                            "created_at" => _serde::__private::Ok(__Field::__field1),
                            "updated_at" => _serde::__private::Ok(__Field::__field2),
                            "user_id" => _serde::__private::Ok(__Field::__field3),
                            "content_id" => _serde::__private::Ok(__Field::__field4),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"id" => _serde::__private::Ok(__Field::__field0),
                            b"created_at" => _serde::__private::Ok(__Field::__field1),
                            b"updated_at" => _serde::__private::Ok(__Field::__field2),
                            b"user_id" => _serde::__private::Ok(__Field::__field3),
                            b"content_id" => _serde::__private::Ok(__Field::__field4),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<ContentLike>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = ContentLike;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct ContentLike",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            i64,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct ContentLike with 5 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            i64,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct ContentLike with 5 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match _serde::de::SeqAccess::next_element::<
                            i64,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct ContentLike with 5 elements",
                                    ),
                                );
                            }
                        };
                        let __field3 = match _serde::de::SeqAccess::next_element::<
                            i64,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        3usize,
                                        &"struct ContentLike with 5 elements",
                                    ),
                                );
                            }
                        };
                        let __field4 = match _serde::de::SeqAccess::next_element::<
                            i64,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        4usize,
                                        &"struct ContentLike with 5 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(ContentLike {
                            id: __field0,
                            created_at: __field1,
                            updated_at: __field2,
                            user_id: __field3,
                            content_id: __field4,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<i64> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<i64> = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<i64> = _serde::__private::None;
                        let mut __field3: _serde::__private::Option<i64> = _serde::__private::None;
                        let mut __field4: _serde::__private::Option<i64> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("id"),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<i64>(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "created_at",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<i64>(&mut __map)?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "updated_at",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<i64>(&mut __map)?,
                                    );
                                }
                                __Field::__field3 => {
                                    if _serde::__private::Option::is_some(&__field3) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "user_id",
                                            ),
                                        );
                                    }
                                    __field3 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<i64>(&mut __map)?,
                                    );
                                }
                                __Field::__field4 => {
                                    if _serde::__private::Option::is_some(&__field4) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "content_id",
                                            ),
                                        );
                                    }
                                    __field4 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<i64>(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("id")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("created_at")?
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("updated_at")?
                            }
                        };
                        let __field3 = match __field3 {
                            _serde::__private::Some(__field3) => __field3,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("user_id")?
                            }
                        };
                        let __field4 = match __field4 {
                            _serde::__private::Some(__field4) => __field4,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("content_id")?
                            }
                        };
                        _serde::__private::Ok(ContentLike {
                            id: __field0,
                            created_at: __field1,
                            updated_at: __field2,
                            user_id: __field3,
                            content_id: __field4,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "id",
                    "created_at",
                    "updated_at",
                    "user_id",
                    "content_id",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "ContentLike",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<ContentLike>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for ContentLike {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "ContentLike",
                    false as usize + 1 + 1 + 1 + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "id",
                    &self.id,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "created_at",
                    &self.created_at,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "updated_at",
                    &self.updated_at,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "user_id",
                    &self.user_id,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "content_id",
                    &self.content_id,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[automatically_derived]
    impl ::core::default::Default for ContentLike {
        #[inline]
        fn default() -> ContentLike {
            ContentLike {
                id: ::core::default::Default::default(),
                created_at: ::core::default::Default::default(),
                updated_at: ::core::default::Default::default(),
                user_id: ::core::default::Default::default(),
                content_id: ::core::default::Default::default(),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for ContentLike {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for ContentLike {
        #[inline]
        fn eq(&self, other: &ContentLike) -> bool {
            self.id == other.id && self.created_at == other.created_at
                && self.updated_at == other.updated_at && self.user_id == other.user_id
                && self.content_id == other.content_id
        }
    }
    pub struct ContentLikeSummary {
        pub id: i64,
        pub created_at: i64,
        pub updated_at: i64,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for ContentLikeSummary {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "ContentLikeSummary",
                "id",
                &self.id,
                "created_at",
                &self.created_at,
                "updated_at",
                &&self.updated_at,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for ContentLikeSummary {
        #[inline]
        fn clone(&self) -> ContentLikeSummary {
            ContentLikeSummary {
                id: ::core::clone::Clone::clone(&self.id),
                created_at: ::core::clone::Clone::clone(&self.created_at),
                updated_at: ::core::clone::Clone::clone(&self.updated_at),
            }
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for ContentLikeSummary {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "ContentLikeSummary",
                    false as usize + 1 + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "id",
                    &self.id,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "created_at",
                    &self.created_at,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "updated_at",
                    &self.updated_at,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for ContentLikeSummary {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "id" => _serde::__private::Ok(__Field::__field0),
                            "created_at" => _serde::__private::Ok(__Field::__field1),
                            "updated_at" => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"id" => _serde::__private::Ok(__Field::__field0),
                            b"created_at" => _serde::__private::Ok(__Field::__field1),
                            b"updated_at" => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<ContentLikeSummary>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = ContentLikeSummary;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct ContentLikeSummary",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            i64,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct ContentLikeSummary with 3 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            i64,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct ContentLikeSummary with 3 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match _serde::de::SeqAccess::next_element::<
                            i64,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct ContentLikeSummary with 3 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(ContentLikeSummary {
                            id: __field0,
                            created_at: __field1,
                            updated_at: __field2,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<i64> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<i64> = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<i64> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("id"),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<i64>(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "created_at",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<i64>(&mut __map)?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "updated_at",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<i64>(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("id")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("created_at")?
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("updated_at")?
                            }
                        };
                        _serde::__private::Ok(ContentLikeSummary {
                            id: __field0,
                            created_at: __field1,
                            updated_at: __field2,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "id",
                    "created_at",
                    "updated_at",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "ContentLikeSummary",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<ContentLikeSummary>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::default::Default for ContentLikeSummary {
        #[inline]
        fn default() -> ContentLikeSummary {
            ContentLikeSummary {
                id: ::core::default::Default::default(),
                created_at: ::core::default::Default::default(),
                updated_at: ::core::default::Default::default(),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for ContentLikeSummary {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for ContentLikeSummary {
        #[inline]
        fn eq(&self, other: &ContentLikeSummary) -> bool {
            self.id == other.id && self.created_at == other.created_at
                && self.updated_at == other.updated_at
        }
    }
    impl From<ContentLike> for ContentLikeSummary {
        fn from(item: ContentLike) -> Self {
            Self {
                id: item.id,
                created_at: item.created_at,
                updated_at: item.updated_at,
            }
        }
    }
    impl Into<ContentLike> for ContentLikeSummary {
        fn into(self) -> ContentLike {
            ContentLike {
                id: self.id,
                created_at: self.created_at,
                updated_at: self.updated_at,
                ..Default::default()
            }
        }
    }
    #[serde(rename_all = "kebab-case")]
    pub struct ContentLikeQuery {
        #[serde(deserialize_with = "parse_size_of_content_like_query", default)]
        pub size: usize,
        pub bookmark: Option<String>,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for ContentLikeQuery {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(
                f,
                "ContentLikeQuery",
                "size",
                &self.size,
                "bookmark",
                &&self.bookmark,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for ContentLikeQuery {
        #[inline]
        fn clone(&self) -> ContentLikeQuery {
            ContentLikeQuery {
                size: ::core::clone::Clone::clone(&self.size),
                bookmark: ::core::clone::Clone::clone(&self.bookmark),
            }
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for ContentLikeQuery {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "ContentLikeQuery",
                    false as usize + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "size",
                    &self.size,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "bookmark",
                    &self.bookmark,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for ContentLikeQuery {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "size" => _serde::__private::Ok(__Field::__field0),
                            "bookmark" => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"size" => _serde::__private::Ok(__Field::__field0),
                            b"bookmark" => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<ContentLikeQuery>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = ContentLikeQuery;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct ContentLikeQuery",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match {
                            #[doc(hidden)]
                            struct __DeserializeWith<'de> {
                                value: usize,
                                phantom: _serde::__private::PhantomData<ContentLikeQuery>,
                                lifetime: _serde::__private::PhantomData<&'de ()>,
                            }
                            #[automatically_derived]
                            impl<'de> _serde::Deserialize<'de>
                            for __DeserializeWith<'de> {
                                fn deserialize<__D>(
                                    __deserializer: __D,
                                ) -> _serde::__private::Result<Self, __D::Error>
                                where
                                    __D: _serde::Deserializer<'de>,
                                {
                                    _serde::__private::Ok(__DeserializeWith {
                                        value: parse_size_of_content_like_query(__deserializer)?,
                                        phantom: _serde::__private::PhantomData,
                                        lifetime: _serde::__private::PhantomData,
                                    })
                                }
                            }
                            _serde::__private::Option::map(
                                _serde::de::SeqAccess::next_element::<
                                    __DeserializeWith<'de>,
                                >(&mut __seq)?,
                                |__wrap| __wrap.value,
                            )
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                _serde::__private::Default::default()
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            Option<String>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct ContentLikeQuery with 2 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(ContentLikeQuery {
                            size: __field0,
                            bookmark: __field1,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<usize> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<Option<String>> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("size"),
                                        );
                                    }
                                    __field0 = _serde::__private::Some({
                                        #[doc(hidden)]
                                        struct __DeserializeWith<'de> {
                                            value: usize,
                                            phantom: _serde::__private::PhantomData<ContentLikeQuery>,
                                            lifetime: _serde::__private::PhantomData<&'de ()>,
                                        }
                                        #[automatically_derived]
                                        impl<'de> _serde::Deserialize<'de>
                                        for __DeserializeWith<'de> {
                                            fn deserialize<__D>(
                                                __deserializer: __D,
                                            ) -> _serde::__private::Result<Self, __D::Error>
                                            where
                                                __D: _serde::Deserializer<'de>,
                                            {
                                                _serde::__private::Ok(__DeserializeWith {
                                                    value: parse_size_of_content_like_query(__deserializer)?,
                                                    phantom: _serde::__private::PhantomData,
                                                    lifetime: _serde::__private::PhantomData,
                                                })
                                            }
                                        }
                                        match _serde::de::MapAccess::next_value::<
                                            __DeserializeWith<'de>,
                                        >(&mut __map) {
                                            _serde::__private::Ok(__wrapper) => __wrapper.value,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        }
                                    });
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "bookmark",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<String>,
                                        >(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::Default::default()
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("bookmark")?
                            }
                        };
                        _serde::__private::Ok(ContentLikeQuery {
                            size: __field0,
                            bookmark: __field1,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &["size", "bookmark"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "ContentLikeQuery",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<ContentLikeQuery>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::default::Default for ContentLikeQuery {
        #[inline]
        fn default() -> ContentLikeQuery {
            ContentLikeQuery {
                size: ::core::default::Default::default(),
                bookmark: ::core::default::Default::default(),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for ContentLikeQuery {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for ContentLikeQuery {
        #[inline]
        fn eq(&self, other: &ContentLikeQuery) -> bool {
            self.size == other.size && self.bookmark == other.bookmark
        }
    }
    impl std::fmt::Display for ContentLikeQuery {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let query = serde_urlencoded::to_string(&self).map_err(|_| std::fmt::Error)?;
            f.write_fmt(format_args!("{0}", query))
        }
    }
    pub fn parse_size_of_content_like_query<'de, D>(
        deserializer: D,
    ) -> std::result::Result<usize, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::Deserialize;
        let s: Option<String> = Option::deserialize(deserializer)?;
        s.unwrap_or_else(|| Default::default())
            .parse::<usize>()
            .map_err(serde::de::Error::custom)
    }
    impl ContentLikeQuery {
        pub fn new(size: usize) -> Self {
            Self { size, ..Self::default() }
        }
        pub fn with_bookmark(mut self, bookmark: String) -> Self {
            self.bookmark = Some(bookmark);
            self
        }
        pub fn with_page(mut self, page: usize) -> Self {
            self.bookmark = Some(page.to_string());
            self
        }
        /// Returns the size(i32) of the query
        pub fn size(&self) -> i32 {
            self.size as i32
        }
        pub fn page(&self) -> i32 {
            self.bookmark.as_ref().unwrap_or(&"1".to_string()).parse().unwrap_or(1)
        }
    }
    impl ContentLikeClient {}
    impl ContentLike {
        pub fn get_client(endpoint: &str) -> ContentLikeClient {
            ContentLikeClient {
                endpoint: endpoint.to_string(),
            }
        }
    }
    pub struct ContentLikeClient {
        pub endpoint: String,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for ContentLikeClient {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field1_finish(
                f,
                "ContentLikeClient",
                "endpoint",
                &&self.endpoint,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for ContentLikeClient {
        #[inline]
        fn clone(&self) -> ContentLikeClient {
            ContentLikeClient {
                endpoint: ::core::clone::Clone::clone(&self.endpoint),
            }
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for ContentLikeClient {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "ContentLikeClient",
                    false as usize + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "endpoint",
                    &self.endpoint,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for ContentLikeClient {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "endpoint" => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"endpoint" => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<ContentLikeClient>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = ContentLikeClient;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct ContentLikeClient",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct ContentLikeClient with 1 element",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(ContentLikeClient {
                            endpoint: __field0,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "endpoint",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("endpoint")?
                            }
                        };
                        _serde::__private::Ok(ContentLikeClient {
                            endpoint: __field0,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &["endpoint"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "ContentLikeClient",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<ContentLikeClient>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::default::Default for ContentLikeClient {
        #[inline]
        fn default() -> ContentLikeClient {
            ContentLikeClient {
                endpoint: ::core::default::Default::default(),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for ContentLikeClient {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for ContentLikeClient {
        #[inline]
        fn eq(&self, other: &ContentLikeClient) -> bool {
            self.endpoint == other.endpoint
        }
    }
    impl ContentLikeClient {
        pub async fn query(
            &self,
            params: ContentLikeQuery,
        ) -> crate::Result<by_types::QueryResponse<ContentLikeSummary>> {
            let path = ::alloc::__export::must_use({
                let res = ::alloc::fmt::format(format_args!("/"));
                res
            });
            let endpoint = ::alloc::__export::must_use({
                let res = ::alloc::fmt::format(
                    format_args!("{0}{1}", self.endpoint, path),
                );
                res
            });
            let query = ::alloc::__export::must_use({
                let res = ::alloc::fmt::format(
                    format_args!("{0}?{1}", endpoint, ContentLikeParam::Query(params)),
                );
                res
            });
            rest_api::get(&query).await
        }
        pub async fn get(&self, id: i64) -> crate::Result<ContentLike> {
            let path = ::alloc::__export::must_use({
                let res = ::alloc::fmt::format(format_args!("/"));
                res
            });
            let endpoint = ::alloc::__export::must_use({
                let res = ::alloc::fmt::format(
                    format_args!("{0}{1}/{2}", self.endpoint, path, id),
                );
                res
            });
            rest_api::get(&endpoint).await
        }
    }
    impl ContentLike {
        pub fn url() -> String {
            "/".to_string()
        }
    }
    pub struct ContentLikeReadAction {}
    #[automatically_derived]
    impl ::core::fmt::Debug for ContentLikeReadAction {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "ContentLikeReadAction")
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for ContentLikeReadAction {
        #[inline]
        fn clone(&self) -> ContentLikeReadAction {
            ContentLikeReadAction {}
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for ContentLikeReadAction {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "ContentLikeReadAction",
                    false as usize,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for ContentLikeReadAction {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<ContentLikeReadAction>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = ContentLikeReadAction;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct ContentLikeReadAction",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        _: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        _serde::__private::Ok(ContentLikeReadAction {})
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        _serde::__private::Ok(ContentLikeReadAction {})
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "ContentLikeReadAction",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<ContentLikeReadAction>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::default::Default for ContentLikeReadAction {
        #[inline]
        fn default() -> ContentLikeReadAction {
            ContentLikeReadAction {}
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for ContentLikeReadAction {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for ContentLikeReadAction {
        #[inline]
        fn eq(&self, other: &ContentLikeReadAction) -> bool {
            true
        }
    }
    impl std::fmt::Display for ContentLikeReadAction {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let query = serde_urlencoded::to_string(&self).map_err(|_| std::fmt::Error)?;
            f.write_fmt(format_args!("{0}", query))
        }
    }
    impl ContentLikeReadAction {
        pub fn new() -> Self {
            Self::default()
        }
    }
    impl ContentLikeClient {}
    #[serde(tag = "param-type", rename_all = "kebab-case")]
    pub enum ContentLikeParam {
        Query(ContentLikeQuery),
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for ContentLikeParam {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                ContentLikeParam::Query(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Query",
                        &__self_0,
                    )
                }
            }
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for ContentLikeParam {
        #[inline]
        fn clone(&self) -> ContentLikeParam {
            match self {
                ContentLikeParam::Query(__self_0) => {
                    ContentLikeParam::Query(::core::clone::Clone::clone(__self_0))
                }
            }
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for ContentLikeParam {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    ContentLikeParam::Query(ref __field0) => {
                        _serde::__private::ser::serialize_tagged_newtype(
                            __serializer,
                            "ContentLikeParam",
                            "Query",
                            "param-type",
                            "query",
                            __field0,
                        )
                    }
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for ContentLikeParam {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "variant identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::invalid_value(
                                        _serde::de::Unexpected::Unsigned(__value),
                                        &"variant index 0 <= i < 1",
                                    ),
                                )
                            }
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "query" => _serde::__private::Ok(__Field::__field0),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"query" => _serde::__private::Ok(__Field::__field0),
                            _ => {
                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                const VARIANTS: &'static [&'static str] = &["query"];
                let (__tag, __content) = _serde::Deserializer::deserialize_any(
                    __deserializer,
                    _serde::__private::de::TaggedContentVisitor::<
                        __Field,
                    >::new("param-type", "internally tagged enum ContentLikeParam"),
                )?;
                let __deserializer = _serde::__private::de::ContentDeserializer::<
                    __D::Error,
                >::new(__content);
                match __tag {
                    __Field::__field0 => {
                        _serde::__private::Result::map(
                            <ContentLikeQuery as _serde::Deserialize>::deserialize(
                                __deserializer,
                            ),
                            ContentLikeParam::Query,
                        )
                    }
                }
            }
        }
    };
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for ContentLikeParam {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for ContentLikeParam {
        #[inline]
        fn eq(&self, other: &ContentLikeParam) -> bool {
            match (self, other) {
                (
                    ContentLikeParam::Query(__self_0),
                    ContentLikeParam::Query(__arg1_0),
                ) => __self_0 == __arg1_0,
            }
        }
    }
    impl std::fmt::Display for ContentLikeParam {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let query = serde_urlencoded::to_string(&self).map_err(|_| std::fmt::Error)?;
            f.write_fmt(format_args!("{0}", query))
        }
    }
    #[serde(tag = "param_type")]
    #[serde(rename_all = "snake_case")]
    pub enum ContentLikeGetResponse {
        Query(by_types::QueryResponse<ContentLikeSummary>),
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for ContentLikeGetResponse {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                ContentLikeGetResponse::Query(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Query",
                        &__self_0,
                    )
                }
            }
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for ContentLikeGetResponse {
        #[inline]
        fn clone(&self) -> ContentLikeGetResponse {
            match self {
                ContentLikeGetResponse::Query(__self_0) => {
                    ContentLikeGetResponse::Query(::core::clone::Clone::clone(__self_0))
                }
            }
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for ContentLikeGetResponse {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    ContentLikeGetResponse::Query(ref __field0) => {
                        _serde::__private::ser::serialize_tagged_newtype(
                            __serializer,
                            "ContentLikeGetResponse",
                            "Query",
                            "param_type",
                            "query",
                            __field0,
                        )
                    }
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for ContentLikeGetResponse {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "variant identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::invalid_value(
                                        _serde::de::Unexpected::Unsigned(__value),
                                        &"variant index 0 <= i < 1",
                                    ),
                                )
                            }
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "query" => _serde::__private::Ok(__Field::__field0),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"query" => _serde::__private::Ok(__Field::__field0),
                            _ => {
                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                const VARIANTS: &'static [&'static str] = &["query"];
                let (__tag, __content) = _serde::Deserializer::deserialize_any(
                    __deserializer,
                    _serde::__private::de::TaggedContentVisitor::<
                        __Field,
                    >::new("param_type", "internally tagged enum ContentLikeGetResponse"),
                )?;
                let __deserializer = _serde::__private::de::ContentDeserializer::<
                    __D::Error,
                >::new(__content);
                match __tag {
                    __Field::__field0 => {
                        _serde::__private::Result::map(
                            <by_types::QueryResponse<
                                ContentLikeSummary,
                            > as _serde::Deserialize>::deserialize(__deserializer),
                            ContentLikeGetResponse::Query,
                        )
                    }
                }
            }
        }
    };
    impl ::validator::Validate for ContentLike {
        fn validate(&self) -> ::std::result::Result<(), ::validator::ValidationErrors> {
            use ::validator::ValidateArgs;
            self.validate_with_args(())
        }
    }
    impl<'v_a> ::validator::ValidateArgs<'v_a> for ContentLike {
        type Args = ();
        fn validate_with_args(
            &self,
            args: Self::Args,
        ) -> ::std::result::Result<(), ::validator::ValidationErrors> {
            let mut errors = ::validator::ValidationErrors::new();
            if errors.is_empty() {
                ::std::result::Result::Ok(())
            } else {
                ::std::result::Result::Err(errors)
            }
        }
    }
}
pub mod contracts {
    pub mod common_contract {
        use std::sync::Arc;
        use std::time::Duration;
        use wasm_timer::Delay;
        use abi::Abi;
        use ethers::prelude::*;
        use ethers::utils::{parse_units, ParseUnits};
        use crate::wallets::KaiaWallet;
        use crate::{Error, Result};
        use super::klaytn_transaction::{KlaytnTransaction, TransactionType};
        pub struct CommonContract<FeePayerWallet: KaiaWallet, UserWallet: KaiaWallet> {
            pub contract: ContractInstance<Arc<Provider<Http>>, Provider<Http>>,
            pub provider: Arc<Provider<Http>>,
            pub wallet: Option<UserWallet>,
            pub fee_payer: Option<FeePayerWallet>,
        }
        #[automatically_derived]
        impl<
            FeePayerWallet: ::core::fmt::Debug + KaiaWallet,
            UserWallet: ::core::fmt::Debug + KaiaWallet,
        > ::core::fmt::Debug for CommonContract<FeePayerWallet, UserWallet> {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field4_finish(
                    f,
                    "CommonContract",
                    "contract",
                    &self.contract,
                    "provider",
                    &self.provider,
                    "wallet",
                    &self.wallet,
                    "fee_payer",
                    &&self.fee_payer,
                )
            }
        }
        #[automatically_derived]
        impl<
            FeePayerWallet: ::core::clone::Clone + KaiaWallet,
            UserWallet: ::core::clone::Clone + KaiaWallet,
        > ::core::clone::Clone for CommonContract<FeePayerWallet, UserWallet> {
            #[inline]
            fn clone(&self) -> CommonContract<FeePayerWallet, UserWallet> {
                CommonContract {
                    contract: ::core::clone::Clone::clone(&self.contract),
                    provider: ::core::clone::Clone::clone(&self.provider),
                    wallet: ::core::clone::Clone::clone(&self.wallet),
                    fee_payer: ::core::clone::Clone::clone(&self.fee_payer),
                }
            }
        }
        impl<T: KaiaWallet, W: KaiaWallet> CommonContract<T, W> {
            pub fn new(
                contract_address: &str,
                abi: &'static str,
                provider: Arc<Provider<Http>>,
            ) -> Self {
                let contract = Contract::new(
                    contract_address.parse::<Address>().unwrap(),
                    serde_json::from_str::<Abi>(abi).unwrap(),
                    provider.clone(),
                );
                Self {
                    contract,
                    provider,
                    wallet: None,
                    fee_payer: None,
                }
            }
            pub fn set_wallet(&mut self, wallet: W) {
                self.wallet = Some(wallet);
            }
            pub fn set_fee_payer(&mut self, fee_payer: T) {
                self.fee_payer = Some(fee_payer);
            }
            pub async fn sign_and_send_transaction_with_feepayer(
                &self,
                input: Bytes,
            ) -> Result<String> {
                let chain_id = self.provider.get_chainid().await?;
                {
                    use ::tracing::__macro_support::Callsite as _;
                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "event packages/dto/src/contracts/common_contract.rs:48",
                                "dto::contracts::common_contract",
                                ::tracing::Level::DEBUG,
                                ::tracing_core::__macro_support::Option::Some(
                                    "packages/dto/src/contracts/common_contract.rs",
                                ),
                                ::tracing_core::__macro_support::Option::Some(48u32),
                                ::tracing_core::__macro_support::Option::Some(
                                    "dto::contracts::common_contract",
                                ),
                                ::tracing_core::field::FieldSet::new(
                                    &["message"],
                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                ),
                                ::tracing::metadata::Kind::EVENT,
                            )
                        };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                    let enabled = ::tracing::Level::DEBUG
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && ::tracing::Level::DEBUG
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            let interest = __CALLSITE.interest();
                            !interest.is_never()
                                && ::tracing::__macro_support::__is_enabled(
                                    __CALLSITE.metadata(),
                                    interest,
                                )
                        };
                    if enabled {
                        (|value_set: ::tracing::field::ValueSet| {
                            let meta = __CALLSITE.metadata();
                            ::tracing::Event::dispatch(meta, &value_set);
                        })({
                            #[allow(unused_imports)]
                            use ::tracing::field::{debug, display, Value};
                            let mut iter = __CALLSITE.metadata().fields().iter();
                            __CALLSITE
                                .metadata()
                                .fields()
                                .value_set(
                                    &[
                                        (
                                            &::tracing::__macro_support::Iterator::next(&mut iter)
                                                .expect("FieldSet corrupted (this is a bug)"),
                                            ::tracing::__macro_support::Option::Some(
                                                &format_args!("chain id: {0}", chain_id) as &dyn Value,
                                            ),
                                        ),
                                    ],
                                )
                        });
                    } else {
                    }
                };
                let gas = 9000000;
                let gas_price = match parse_units("750", "gwei")? {
                    ParseUnits::U256(x) => x,
                    ParseUnits::I256(_) => {
                        return Err(Error::Klaytn("parse_units error".to_string()));
                    }
                };
                let value = U256::from(0);
                let w = match self.wallet.as_ref() {
                    Some(w) => w,
                    None => return Err(Error::Klaytn("wallet is None".to_string())),
                };
                let from = w.address();
                let to = self.contract.address();
                let tx_type = TransactionType::FeeDelegatedSmartContractExecution;
                let nonce = self.provider.get_transaction_count(from, None).await?;
                let tx = KlaytnTransaction::new(
                    tx_type,
                    Some(from),
                    Some(to),
                    Some(U256::from(gas)),
                    Some(gas_price),
                    Some(value),
                    Some(input.to_vec()),
                    Some(nonce),
                );
                let fp = self.fee_payer.as_ref().unwrap();
                let fp_sig = fp.sign_transaction(&tx).await?;
                let sig = w.sign_transaction(&tx).await?;
                {
                    use ::tracing::__macro_support::Callsite as _;
                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "event packages/dto/src/contracts/common_contract.rs:80",
                                "dto::contracts::common_contract",
                                ::tracing::Level::DEBUG,
                                ::tracing_core::__macro_support::Option::Some(
                                    "packages/dto/src/contracts/common_contract.rs",
                                ),
                                ::tracing_core::__macro_support::Option::Some(80u32),
                                ::tracing_core::__macro_support::Option::Some(
                                    "dto::contracts::common_contract",
                                ),
                                ::tracing_core::field::FieldSet::new(
                                    &["message"],
                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                ),
                                ::tracing::metadata::Kind::EVENT,
                            )
                        };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                    let enabled = ::tracing::Level::DEBUG
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && ::tracing::Level::DEBUG
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            let interest = __CALLSITE.interest();
                            !interest.is_never()
                                && ::tracing::__macro_support::__is_enabled(
                                    __CALLSITE.metadata(),
                                    interest,
                                )
                        };
                    if enabled {
                        (|value_set: ::tracing::field::ValueSet| {
                            let meta = __CALLSITE.metadata();
                            ::tracing::Event::dispatch(meta, &value_set);
                        })({
                            #[allow(unused_imports)]
                            use ::tracing::field::{debug, display, Value};
                            let mut iter = __CALLSITE.metadata().fields().iter();
                            __CALLSITE
                                .metadata()
                                .fields()
                                .value_set(
                                    &[
                                        (
                                            &::tracing::__macro_support::Iterator::next(&mut iter)
                                                .expect("FieldSet corrupted (this is a bug)"),
                                            ::tracing::__macro_support::Option::Some(
                                                &format_args!("sig: {0:?}", sig) as &dyn Value,
                                            ),
                                        ),
                                    ],
                                )
                        });
                    } else {
                    }
                };
                let rlp = tx.to_tx_hash_rlp(sig, fp.address(), fp_sig);
                let rlp = ::alloc::__export::must_use({
                    let res = ::alloc::fmt::format(
                        format_args!("0x{0}", hex::encode(rlp).to_string()),
                    );
                    res
                });
                {
                    use ::tracing::__macro_support::Callsite as _;
                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "event packages/dto/src/contracts/common_contract.rs:85",
                                "dto::contracts::common_contract",
                                ::tracing::Level::DEBUG,
                                ::tracing_core::__macro_support::Option::Some(
                                    "packages/dto/src/contracts/common_contract.rs",
                                ),
                                ::tracing_core::__macro_support::Option::Some(85u32),
                                ::tracing_core::__macro_support::Option::Some(
                                    "dto::contracts::common_contract",
                                ),
                                ::tracing_core::field::FieldSet::new(
                                    &["message"],
                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                ),
                                ::tracing::metadata::Kind::EVENT,
                            )
                        };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                    let enabled = ::tracing::Level::DEBUG
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && ::tracing::Level::DEBUG
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            let interest = __CALLSITE.interest();
                            !interest.is_never()
                                && ::tracing::__macro_support::__is_enabled(
                                    __CALLSITE.metadata(),
                                    interest,
                                )
                        };
                    if enabled {
                        (|value_set: ::tracing::field::ValueSet| {
                            let meta = __CALLSITE.metadata();
                            ::tracing::Event::dispatch(meta, &value_set);
                        })({
                            #[allow(unused_imports)]
                            use ::tracing::field::{debug, display, Value};
                            let mut iter = __CALLSITE.metadata().fields().iter();
                            __CALLSITE
                                .metadata()
                                .fields()
                                .value_set(
                                    &[
                                        (
                                            &::tracing::__macro_support::Iterator::next(&mut iter)
                                                .expect("FieldSet corrupted (this is a bug)"),
                                            ::tracing::__macro_support::Option::Some(
                                                &format_args!("rlp: {0}", rlp) as &dyn Value,
                                            ),
                                        ),
                                    ],
                                )
                        });
                    } else {
                    }
                };
                let res: std::result::Result<JsonRpcResponse<String>, Error> = rest_api::post(
                        self.provider.url().as_str(),
                        ::serde_json::Value::Object({
                            let mut object = ::serde_json::Map::new();
                            let _ = object
                                .insert(
                                    ("jsonrpc").into(),
                                    ::serde_json::to_value(&"2.0").unwrap(),
                                );
                            let _ = object
                                .insert(
                                    ("method").into(),
                                    ::serde_json::to_value(&"kaia_sendRawTransaction").unwrap(),
                                );
                            let _ = object
                                .insert(("id").into(), ::serde_json::to_value(&1).unwrap());
                            let _ = object
                                .insert(
                                    ("params").into(),
                                    ::serde_json::Value::Array(
                                        <[_]>::into_vec(
                                            #[rustc_box]
                                            ::alloc::boxed::Box::new([
                                                ::serde_json::to_value(&rlp).unwrap(),
                                            ]),
                                        ),
                                    ),
                                );
                            object
                        }),
                    )
                    .await;
                let tx_hash = match res {
                    Ok(res) => {
                        if res.result.is_none() {
                            return Err(
                                Error::Klaytn("sendRawTransaction error".to_string()),
                            );
                        }
                        res.result.unwrap()
                    }
                    Err(e) => {
                        {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "event packages/dto/src/contracts/common_contract.rs:106",
                                        "dto::contracts::common_contract",
                                        ::tracing::Level::ERROR,
                                        ::tracing_core::__macro_support::Option::Some(
                                            "packages/dto/src/contracts/common_contract.rs",
                                        ),
                                        ::tracing_core::__macro_support::Option::Some(106u32),
                                        ::tracing_core::__macro_support::Option::Some(
                                            "dto::contracts::common_contract",
                                        ),
                                        ::tracing_core::field::FieldSet::new(
                                            &["message"],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::EVENT,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let enabled = ::tracing::Level::ERROR
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && ::tracing::Level::ERROR
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    let interest = __CALLSITE.interest();
                                    !interest.is_never()
                                        && ::tracing::__macro_support::__is_enabled(
                                            __CALLSITE.metadata(),
                                            interest,
                                        )
                                };
                            if enabled {
                                (|value_set: ::tracing::field::ValueSet| {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Event::dispatch(meta, &value_set);
                                })({
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                    __CALLSITE
                                        .metadata()
                                        .fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::tracing::__macro_support::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::tracing::__macro_support::Option::Some(
                                                        &format_args!("sendRawTransaction error: {0}", e)
                                                            as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                });
                            } else {
                            }
                        };
                        return Err(
                            Error::Klaytn("sendRawTransaction error".to_string()),
                        );
                    }
                };
                {
                    use ::tracing::__macro_support::Callsite as _;
                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "event packages/dto/src/contracts/common_contract.rs:111",
                                "dto::contracts::common_contract",
                                ::tracing::Level::DEBUG,
                                ::tracing_core::__macro_support::Option::Some(
                                    "packages/dto/src/contracts/common_contract.rs",
                                ),
                                ::tracing_core::__macro_support::Option::Some(111u32),
                                ::tracing_core::__macro_support::Option::Some(
                                    "dto::contracts::common_contract",
                                ),
                                ::tracing_core::field::FieldSet::new(
                                    &["message"],
                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                ),
                                ::tracing::metadata::Kind::EVENT,
                            )
                        };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                    let enabled = ::tracing::Level::DEBUG
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && ::tracing::Level::DEBUG
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            let interest = __CALLSITE.interest();
                            !interest.is_never()
                                && ::tracing::__macro_support::__is_enabled(
                                    __CALLSITE.metadata(),
                                    interest,
                                )
                        };
                    if enabled {
                        (|value_set: ::tracing::field::ValueSet| {
                            let meta = __CALLSITE.metadata();
                            ::tracing::Event::dispatch(meta, &value_set);
                        })({
                            #[allow(unused_imports)]
                            use ::tracing::field::{debug, display, Value};
                            let mut iter = __CALLSITE.metadata().fields().iter();
                            __CALLSITE
                                .metadata()
                                .fields()
                                .value_set(
                                    &[
                                        (
                                            &::tracing::__macro_support::Iterator::next(&mut iter)
                                                .expect("FieldSet corrupted (this is a bug)"),
                                            ::tracing::__macro_support::Option::Some(
                                                &format_args!("tx hash: {0}", tx_hash) as &dyn Value,
                                            ),
                                        ),
                                    ],
                                )
                        });
                    } else {
                    }
                };
                let mut status = "".to_string();
                for _ in 0..3 {
                    let _ = Delay::new(Duration::from_secs(1)).await;
                    let res: std::result::Result<
                        JsonRpcResponse<TransactionReceipt>,
                        Error,
                    > = rest_api::post(
                            self.provider.url().as_str(),
                            ::serde_json::Value::Object({
                                let mut object = ::serde_json::Map::new();
                                let _ = object
                                    .insert(
                                        ("jsonrpc").into(),
                                        ::serde_json::to_value(&"2.0").unwrap(),
                                    );
                                let _ = object
                                    .insert(("id").into(), ::serde_json::to_value(&1).unwrap());
                                let _ = object
                                    .insert(
                                        ("method").into(),
                                        ::serde_json::to_value(&"kaia_getTransactionReceipt")
                                            .unwrap(),
                                    );
                                let _ = object
                                    .insert(
                                        ("params").into(),
                                        ::serde_json::Value::Array(
                                            <[_]>::into_vec(
                                                #[rustc_box]
                                                ::alloc::boxed::Box::new([
                                                    ::serde_json::to_value(&tx_hash).unwrap(),
                                                ]),
                                            ),
                                        ),
                                    );
                                object
                            }),
                        )
                        .await;
                    let res = match res {
                        Ok(res) => res,
                        Err(e) => {
                            {
                                use ::tracing::__macro_support::Callsite as _;
                                static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                    static META: ::tracing::Metadata<'static> = {
                                        ::tracing_core::metadata::Metadata::new(
                                            "event packages/dto/src/contracts/common_contract.rs:131",
                                            "dto::contracts::common_contract",
                                            ::tracing::Level::WARN,
                                            ::tracing_core::__macro_support::Option::Some(
                                                "packages/dto/src/contracts/common_contract.rs",
                                            ),
                                            ::tracing_core::__macro_support::Option::Some(131u32),
                                            ::tracing_core::__macro_support::Option::Some(
                                                "dto::contracts::common_contract",
                                            ),
                                            ::tracing_core::field::FieldSet::new(
                                                &["message"],
                                                ::tracing_core::callsite::Identifier(&__CALLSITE),
                                            ),
                                            ::tracing::metadata::Kind::EVENT,
                                        )
                                    };
                                    ::tracing::callsite::DefaultCallsite::new(&META)
                                };
                                let enabled = ::tracing::Level::WARN
                                    <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                    && ::tracing::Level::WARN
                                        <= ::tracing::level_filters::LevelFilter::current()
                                    && {
                                        let interest = __CALLSITE.interest();
                                        !interest.is_never()
                                            && ::tracing::__macro_support::__is_enabled(
                                                __CALLSITE.metadata(),
                                                interest,
                                            )
                                    };
                                if enabled {
                                    (|value_set: ::tracing::field::ValueSet| {
                                        let meta = __CALLSITE.metadata();
                                        ::tracing::Event::dispatch(meta, &value_set);
                                    })({
                                        #[allow(unused_imports)]
                                        use ::tracing::field::{debug, display, Value};
                                        let mut iter = __CALLSITE.metadata().fields().iter();
                                        __CALLSITE
                                            .metadata()
                                            .fields()
                                            .value_set(
                                                &[
                                                    (
                                                        &::tracing::__macro_support::Iterator::next(&mut iter)
                                                            .expect("FieldSet corrupted (this is a bug)"),
                                                        ::tracing::__macro_support::Option::Some(
                                                            &format_args!("getTransactionReceipt error: {0}", e)
                                                                as &dyn Value,
                                                        ),
                                                    ),
                                                ],
                                            )
                                    });
                                } else {
                                }
                            };
                            continue;
                        }
                    };
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event packages/dto/src/contracts/common_contract.rs:136",
                                    "dto::contracts::common_contract",
                                    ::tracing::Level::DEBUG,
                                    ::tracing_core::__macro_support::Option::Some(
                                        "packages/dto/src/contracts/common_contract.rs",
                                    ),
                                    ::tracing_core::__macro_support::Option::Some(136u32),
                                    ::tracing_core::__macro_support::Option::Some(
                                        "dto::contracts::common_contract",
                                    ),
                                    ::tracing_core::field::FieldSet::new(
                                        &["message"],
                                        ::tracing_core::callsite::Identifier(&__CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            ::tracing::callsite::DefaultCallsite::new(&META)
                        };
                        let enabled = ::tracing::Level::DEBUG
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && ::tracing::Level::DEBUG
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = __CALLSITE.interest();
                                !interest.is_never()
                                    && ::tracing::__macro_support::__is_enabled(
                                        __CALLSITE.metadata(),
                                        interest,
                                    )
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = __CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = __CALLSITE.metadata().fields().iter();
                                __CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &::tracing::__macro_support::Iterator::next(&mut iter)
                                                    .expect("FieldSet corrupted (this is a bug)"),
                                                ::tracing::__macro_support::Option::Some(
                                                    &format_args!("receipt {0:?}", res) as &dyn Value,
                                                ),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                        }
                    };
                    match res.result {
                        Some(v) => {
                            status = v.status;
                            break;
                        }
                        None => "".to_string(),
                    };
                }
                if status == "0x1" {
                    Ok(tx_hash)
                } else {
                    Err(Error::Klaytn("internal error".to_string()))
                }
            }
        }
        pub struct JsonRpcResponse<T> {
            pub jsonrpc: String,
            pub id: u64,
            pub result: Option<T>,
            pub error: Option<JsonRpcError>,
        }
        #[automatically_derived]
        impl<T: ::core::fmt::Debug> ::core::fmt::Debug for JsonRpcResponse<T> {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field4_finish(
                    f,
                    "JsonRpcResponse",
                    "jsonrpc",
                    &self.jsonrpc,
                    "id",
                    &self.id,
                    "result",
                    &self.result,
                    "error",
                    &&self.error,
                )
            }
        }
        #[automatically_derived]
        impl<T: ::core::clone::Clone> ::core::clone::Clone for JsonRpcResponse<T> {
            #[inline]
            fn clone(&self) -> JsonRpcResponse<T> {
                JsonRpcResponse {
                    jsonrpc: ::core::clone::Clone::clone(&self.jsonrpc),
                    id: ::core::clone::Clone::clone(&self.id),
                    result: ::core::clone::Clone::clone(&self.result),
                    error: ::core::clone::Clone::clone(&self.error),
                }
            }
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de, T> _serde::Deserialize<'de> for JsonRpcResponse<T>
            where
                T: _serde::Deserialize<'de>,
            {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __field3,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                3u64 => _serde::__private::Ok(__Field::__field3),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "jsonrpc" => _serde::__private::Ok(__Field::__field0),
                                "id" => _serde::__private::Ok(__Field::__field1),
                                "result" => _serde::__private::Ok(__Field::__field2),
                                "error" => _serde::__private::Ok(__Field::__field3),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"jsonrpc" => _serde::__private::Ok(__Field::__field0),
                                b"id" => _serde::__private::Ok(__Field::__field1),
                                b"result" => _serde::__private::Ok(__Field::__field2),
                                b"error" => _serde::__private::Ok(__Field::__field3),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de, T>
                    where
                        T: _serde::Deserialize<'de>,
                    {
                        marker: _serde::__private::PhantomData<JsonRpcResponse<T>>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de, T> _serde::de::Visitor<'de> for __Visitor<'de, T>
                    where
                        T: _serde::Deserialize<'de>,
                    {
                        type Value = JsonRpcResponse<T>;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct JsonRpcResponse",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct JsonRpcResponse with 4 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                u64,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct JsonRpcResponse with 4 elements",
                                        ),
                                    );
                                }
                            };
                            let __field2 = match _serde::de::SeqAccess::next_element::<
                                Option<T>,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            2usize,
                                            &"struct JsonRpcResponse with 4 elements",
                                        ),
                                    );
                                }
                            };
                            let __field3 = match _serde::de::SeqAccess::next_element::<
                                Option<JsonRpcError>,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            3usize,
                                            &"struct JsonRpcResponse with 4 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(JsonRpcResponse {
                                jsonrpc: __field0,
                                id: __field1,
                                result: __field2,
                                error: __field3,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<u64> = _serde::__private::None;
                            let mut __field2: _serde::__private::Option<Option<T>> = _serde::__private::None;
                            let mut __field3: _serde::__private::Option<
                                Option<JsonRpcError>,
                            > = _serde::__private::None;
                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "jsonrpc",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("id"),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<u64>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field2 => {
                                        if _serde::__private::Option::is_some(&__field2) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("result"),
                                            );
                                        }
                                        __field2 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<Option<T>>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field3 => {
                                        if _serde::__private::Option::is_some(&__field3) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("error"),
                                            );
                                        }
                                        __field3 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                Option<JsonRpcError>,
                                            >(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("jsonrpc")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("id")?
                                }
                            };
                            let __field2 = match __field2 {
                                _serde::__private::Some(__field2) => __field2,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("result")?
                                }
                            };
                            let __field3 = match __field3 {
                                _serde::__private::Some(__field3) => __field3,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("error")?
                                }
                            };
                            _serde::__private::Ok(JsonRpcResponse {
                                jsonrpc: __field0,
                                id: __field1,
                                result: __field2,
                                error: __field3,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &[
                        "jsonrpc",
                        "id",
                        "result",
                        "error",
                    ];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "JsonRpcResponse",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<JsonRpcResponse<T>>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[serde(rename_all = "camelCase")]
        pub struct TransactionReceipt {
            pub block_number: String,
            pub status: String,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for TransactionReceipt {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(
                    f,
                    "TransactionReceipt",
                    "block_number",
                    &self.block_number,
                    "status",
                    &&self.status,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for TransactionReceipt {
            #[inline]
            fn clone(&self) -> TransactionReceipt {
                TransactionReceipt {
                    block_number: ::core::clone::Clone::clone(&self.block_number),
                    status: ::core::clone::Clone::clone(&self.status),
                }
            }
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for TransactionReceipt {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "blockNumber" => _serde::__private::Ok(__Field::__field0),
                                "status" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"blockNumber" => _serde::__private::Ok(__Field::__field0),
                                b"status" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<TransactionReceipt>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = TransactionReceipt;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct TransactionReceipt",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct TransactionReceipt with 2 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct TransactionReceipt with 2 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(TransactionReceipt {
                                block_number: __field0,
                                status: __field1,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<String> = _serde::__private::None;
                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "blockNumber",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("status"),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("blockNumber")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("status")?
                                }
                            };
                            _serde::__private::Ok(TransactionReceipt {
                                block_number: __field0,
                                status: __field1,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &["blockNumber", "status"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "TransactionReceipt",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<TransactionReceipt>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
    }
    pub mod incheon_contents {
        use ethers::prelude::*;
        use std::sync::Arc;
        use crate::wallets::KaiaWallet;
        use crate::{Error, Result};
        use super::common_contract::CommonContract;
        pub struct IncheonContentsContract<
            FeePayerWallet: KaiaWallet,
            UserWallet: KaiaWallet,
        > {
            pub contract: CommonContract<FeePayerWallet, UserWallet>,
        }
        #[automatically_derived]
        impl<
            FeePayerWallet: ::core::fmt::Debug + KaiaWallet,
            UserWallet: ::core::fmt::Debug + KaiaWallet,
        > ::core::fmt::Debug for IncheonContentsContract<FeePayerWallet, UserWallet> {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field1_finish(
                    f,
                    "IncheonContentsContract",
                    "contract",
                    &&self.contract,
                )
            }
        }
        #[automatically_derived]
        impl<
            FeePayerWallet: ::core::clone::Clone + KaiaWallet,
            UserWallet: ::core::clone::Clone + KaiaWallet,
        > ::core::clone::Clone for IncheonContentsContract<FeePayerWallet, UserWallet> {
            #[inline]
            fn clone(&self) -> IncheonContentsContract<FeePayerWallet, UserWallet> {
                IncheonContentsContract {
                    contract: ::core::clone::Clone::clone(&self.contract),
                }
            }
        }
        impl<T: KaiaWallet, W: KaiaWallet> IncheonContentsContract<T, W> {
            pub fn new(contract_address: &str, provider: Arc<Provider<Http>>) -> Self {
                let contract = CommonContract::new(
                    contract_address,
                    "[\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"owner\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"string\",\n        \"name\": \"name_\",\n        \"type\": \"string\"\n      },\n      {\n        \"internalType\": \"string\",\n        \"name\": \"symbol_\",\n        \"type\": \"string\"\n      },\n      {\n        \"internalType\": \"string\",\n        \"name\": \"uri_\",\n        \"type\": \"string\"\n      }\n    ],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"constructor\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"sender\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"balance\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"needed\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"tokenId\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"ERC1155InsufficientBalance\",\n    \"type\": \"error\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"approver\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"ERC1155InvalidApprover\",\n    \"type\": \"error\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"idsLength\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"valuesLength\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"ERC1155InvalidArrayLength\",\n    \"type\": \"error\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"operator\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"ERC1155InvalidOperator\",\n    \"type\": \"error\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"receiver\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"ERC1155InvalidReceiver\",\n    \"type\": \"error\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"sender\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"ERC1155InvalidSender\",\n    \"type\": \"error\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"operator\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"address\",\n        \"name\": \"owner\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"ERC1155MissingApprovalForAll\",\n    \"type\": \"error\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"owner\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"OwnableInvalidOwner\",\n    \"type\": \"error\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"account\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"OwnableUnauthorizedAccount\",\n    \"type\": \"error\"\n  },\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"account\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"operator\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"bool\",\n        \"name\": \"approved\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"name\": \"ApprovalForAll\",\n    \"type\": \"event\"\n  },\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"previousOwner\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"newOwner\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"OwnershipTransferred\",\n    \"type\": \"event\"\n  },\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"operator\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"from\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"to\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"uint256[]\",\n        \"name\": \"ids\",\n        \"type\": \"uint256[]\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"uint256[]\",\n        \"name\": \"values\",\n        \"type\": \"uint256[]\"\n      }\n    ],\n    \"name\": \"TransferBatch\",\n    \"type\": \"event\"\n  },\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"operator\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"from\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"to\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"uint256\",\n        \"name\": \"id\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"uint256\",\n        \"name\": \"value\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"TransferSingle\",\n    \"type\": \"event\"\n  },\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": false,\n        \"internalType\": \"string\",\n        \"name\": \"value\",\n        \"type\": \"string\"\n      },\n      {\n        \"indexed\": true,\n        \"internalType\": \"uint256\",\n        \"name\": \"id\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"URI\",\n    \"type\": \"event\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"account\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"id\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"balanceOf\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address[]\",\n        \"name\": \"accounts\",\n        \"type\": \"address[]\"\n      },\n      {\n        \"internalType\": \"uint256[]\",\n        \"name\": \"ids\",\n        \"type\": \"uint256[]\"\n      }\n    ],\n    \"name\": \"balanceOfBatch\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256[]\",\n        \"name\": \"\",\n        \"type\": \"uint256[]\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"account\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"address\",\n        \"name\": \"operator\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"isApprovedForAll\",\n    \"outputs\": [\n      {\n        \"internalType\": \"bool\",\n        \"name\": \"\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"to\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"id\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"value\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"mint\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"to\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"uint256[]\",\n        \"name\": \"ids\",\n        \"type\": \"uint256[]\"\n      },\n      {\n        \"internalType\": \"uint256[]\",\n        \"name\": \"values\",\n        \"type\": \"uint256[]\"\n      }\n    ],\n    \"name\": \"mintBatch\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"name\",\n    \"outputs\": [\n      {\n        \"internalType\": \"string\",\n        \"name\": \"\",\n        \"type\": \"string\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"owner\",\n    \"outputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"\",\n        \"type\": \"address\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"renounceOwnership\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"from\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"address\",\n        \"name\": \"to\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"uint256[]\",\n        \"name\": \"ids\",\n        \"type\": \"uint256[]\"\n      },\n      {\n        \"internalType\": \"uint256[]\",\n        \"name\": \"values\",\n        \"type\": \"uint256[]\"\n      },\n      {\n        \"internalType\": \"bytes\",\n        \"name\": \"data\",\n        \"type\": \"bytes\"\n      }\n    ],\n    \"name\": \"safeBatchTransferFrom\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"from\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"address\",\n        \"name\": \"to\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"id\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"value\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"bytes\",\n        \"name\": \"data\",\n        \"type\": \"bytes\"\n      }\n    ],\n    \"name\": \"safeTransferFrom\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"operator\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"bool\",\n        \"name\": \"approved\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"name\": \"setApprovalForAll\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"string\",\n        \"name\": \"newuri\",\n        \"type\": \"string\"\n      }\n    ],\n    \"name\": \"setURI\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"bytes4\",\n        \"name\": \"interfaceId\",\n        \"type\": \"bytes4\"\n      }\n    ],\n    \"name\": \"supportsInterface\",\n    \"outputs\": [\n      {\n        \"internalType\": \"bool\",\n        \"name\": \"\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"symbol\",\n    \"outputs\": [\n      {\n        \"internalType\": \"string\",\n        \"name\": \"\",\n        \"type\": \"string\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"newOwner\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"transferOwnership\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"uri\",\n    \"outputs\": [\n      {\n        \"internalType\": \"string\",\n        \"name\": \"\",\n        \"type\": \"string\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  }\n]\n",
                    provider,
                );
                Self { contract }
            }
            pub async fn mint_batch(
                &self,
                addr: String,
                ids: Vec<u64>,
                values: Vec<u64>,
            ) -> Result<String> {
                let addr = addr
                    .parse::<Address>()
                    .map_err(|e| Error::Klaytn(e.to_string()))?;
                let ids: Vec<U256> = ids.into_iter().map(|e| U256::from(e)).collect();
                let values: Vec<U256> = values
                    .into_iter()
                    .map(|e| U256::from(e))
                    .collect();
                let input = self
                    .contract
                    .contract
                    .method::<
                        (H160, Vec<U256>, Vec<U256>),
                        (),
                    >("mintBatch", (addr, ids, values))?
                    .calldata()
                    .ok_or(Error::Klaytn("calldata error".to_string()))?;
                let tx_hash = self
                    .contract
                    .sign_and_send_transaction_with_feepayer(input)
                    .await?;
                Ok(tx_hash)
            }
            pub async fn mint(&self, addr: String, id: u64) -> Result<String> {
                let addr = addr
                    .parse::<Address>()
                    .map_err(|e| Error::Klaytn(e.to_string()))?;
                let ids: U256 = U256::from(id);
                let values = U256::from(1);
                let input = self
                    .contract
                    .contract
                    .method::<_, ()>("mint", (addr, ids, values))?
                    .calldata()
                    .ok_or(Error::Klaytn("calldata error".to_string()))?;
                let tx_hash = self
                    .contract
                    .sign_and_send_transaction_with_feepayer(input)
                    .await?;
                Ok(tx_hash)
            }
            pub fn set_wallet(&mut self, wallet: W) {
                self.contract.set_wallet(wallet);
            }
            pub fn set_fee_payer(&mut self, fee_payer: T) {
                self.contract.set_fee_payer(fee_payer);
            }
        }
        pub struct JsonRpcResponse<T> {
            pub jsonrpc: String,
            pub id: u64,
            pub result: Option<T>,
            pub error: Option<JsonRpcError>,
        }
        #[automatically_derived]
        impl<T: ::core::fmt::Debug> ::core::fmt::Debug for JsonRpcResponse<T> {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field4_finish(
                    f,
                    "JsonRpcResponse",
                    "jsonrpc",
                    &self.jsonrpc,
                    "id",
                    &self.id,
                    "result",
                    &self.result,
                    "error",
                    &&self.error,
                )
            }
        }
        #[automatically_derived]
        impl<T: ::core::clone::Clone> ::core::clone::Clone for JsonRpcResponse<T> {
            #[inline]
            fn clone(&self) -> JsonRpcResponse<T> {
                JsonRpcResponse {
                    jsonrpc: ::core::clone::Clone::clone(&self.jsonrpc),
                    id: ::core::clone::Clone::clone(&self.id),
                    result: ::core::clone::Clone::clone(&self.result),
                    error: ::core::clone::Clone::clone(&self.error),
                }
            }
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de, T> _serde::Deserialize<'de> for JsonRpcResponse<T>
            where
                T: _serde::Deserialize<'de>,
            {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __field3,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                3u64 => _serde::__private::Ok(__Field::__field3),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "jsonrpc" => _serde::__private::Ok(__Field::__field0),
                                "id" => _serde::__private::Ok(__Field::__field1),
                                "result" => _serde::__private::Ok(__Field::__field2),
                                "error" => _serde::__private::Ok(__Field::__field3),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"jsonrpc" => _serde::__private::Ok(__Field::__field0),
                                b"id" => _serde::__private::Ok(__Field::__field1),
                                b"result" => _serde::__private::Ok(__Field::__field2),
                                b"error" => _serde::__private::Ok(__Field::__field3),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de, T>
                    where
                        T: _serde::Deserialize<'de>,
                    {
                        marker: _serde::__private::PhantomData<JsonRpcResponse<T>>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de, T> _serde::de::Visitor<'de> for __Visitor<'de, T>
                    where
                        T: _serde::Deserialize<'de>,
                    {
                        type Value = JsonRpcResponse<T>;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct JsonRpcResponse",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct JsonRpcResponse with 4 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                u64,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct JsonRpcResponse with 4 elements",
                                        ),
                                    );
                                }
                            };
                            let __field2 = match _serde::de::SeqAccess::next_element::<
                                Option<T>,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            2usize,
                                            &"struct JsonRpcResponse with 4 elements",
                                        ),
                                    );
                                }
                            };
                            let __field3 = match _serde::de::SeqAccess::next_element::<
                                Option<JsonRpcError>,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            3usize,
                                            &"struct JsonRpcResponse with 4 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(JsonRpcResponse {
                                jsonrpc: __field0,
                                id: __field1,
                                result: __field2,
                                error: __field3,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<u64> = _serde::__private::None;
                            let mut __field2: _serde::__private::Option<Option<T>> = _serde::__private::None;
                            let mut __field3: _serde::__private::Option<
                                Option<JsonRpcError>,
                            > = _serde::__private::None;
                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "jsonrpc",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("id"),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<u64>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field2 => {
                                        if _serde::__private::Option::is_some(&__field2) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("result"),
                                            );
                                        }
                                        __field2 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<Option<T>>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field3 => {
                                        if _serde::__private::Option::is_some(&__field3) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("error"),
                                            );
                                        }
                                        __field3 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                Option<JsonRpcError>,
                                            >(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("jsonrpc")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("id")?
                                }
                            };
                            let __field2 = match __field2 {
                                _serde::__private::Some(__field2) => __field2,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("result")?
                                }
                            };
                            let __field3 = match __field3 {
                                _serde::__private::Some(__field3) => __field3,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("error")?
                                }
                            };
                            _serde::__private::Ok(JsonRpcResponse {
                                jsonrpc: __field0,
                                id: __field1,
                                result: __field2,
                                error: __field3,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &[
                        "jsonrpc",
                        "id",
                        "result",
                        "error",
                    ];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "JsonRpcResponse",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<JsonRpcResponse<T>>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[serde(rename_all = "camelCase")]
        pub struct TransactionReceipt {
            pub block_number: String,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for TransactionReceipt {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field1_finish(
                    f,
                    "TransactionReceipt",
                    "block_number",
                    &&self.block_number,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for TransactionReceipt {
            #[inline]
            fn clone(&self) -> TransactionReceipt {
                TransactionReceipt {
                    block_number: ::core::clone::Clone::clone(&self.block_number),
                }
            }
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for TransactionReceipt {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "blockNumber" => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"blockNumber" => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<TransactionReceipt>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = TransactionReceipt;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct TransactionReceipt",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct TransactionReceipt with 1 element",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(TransactionReceipt {
                                block_number: __field0,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "blockNumber",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("blockNumber")?
                                }
                            };
                            _serde::__private::Ok(TransactionReceipt {
                                block_number: __field0,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &["blockNumber"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "TransactionReceipt",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<TransactionReceipt>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
    }
    pub mod klaytn_transaction {
        use ethers::prelude::*;
        use rlp::RlpStream;
        use std::convert::TryFrom;
        #[serde(rename_all = "snake_case")]
        pub enum TransactionType {
            #[default]
            Legacy,
            ValueTransfer,
            FeeDelegatedValueTransfer,
            ValueTransferMemo,
            FeeDelegatedValueTransferMemo,
            SmartContractDeploy,
            FeeDelegatedSmartContractDeploy,
            SmartContractExecution,
            FeeDelegatedSmartContractExecution,
            AccountUpdate,
            FeeDelegatedAccountUpdate,
            Cancel,
            FeeDelegatedCancel,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for TransactionType {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::write_str(
                    f,
                    match self {
                        TransactionType::Legacy => "Legacy",
                        TransactionType::ValueTransfer => "ValueTransfer",
                        TransactionType::FeeDelegatedValueTransfer => {
                            "FeeDelegatedValueTransfer"
                        }
                        TransactionType::ValueTransferMemo => "ValueTransferMemo",
                        TransactionType::FeeDelegatedValueTransferMemo => {
                            "FeeDelegatedValueTransferMemo"
                        }
                        TransactionType::SmartContractDeploy => "SmartContractDeploy",
                        TransactionType::FeeDelegatedSmartContractDeploy => {
                            "FeeDelegatedSmartContractDeploy"
                        }
                        TransactionType::SmartContractExecution => {
                            "SmartContractExecution"
                        }
                        TransactionType::FeeDelegatedSmartContractExecution => {
                            "FeeDelegatedSmartContractExecution"
                        }
                        TransactionType::AccountUpdate => "AccountUpdate",
                        TransactionType::FeeDelegatedAccountUpdate => {
                            "FeeDelegatedAccountUpdate"
                        }
                        TransactionType::Cancel => "Cancel",
                        TransactionType::FeeDelegatedCancel => "FeeDelegatedCancel",
                    },
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for TransactionType {
            #[inline]
            fn clone(&self) -> TransactionType {
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for TransactionType {}
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for TransactionType {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for TransactionType {
            #[inline]
            fn eq(&self, other: &TransactionType) -> bool {
                let __self_discr = ::core::intrinsics::discriminant_value(self);
                let __arg1_discr = ::core::intrinsics::discriminant_value(other);
                __self_discr == __arg1_discr
            }
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for TransactionType {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    match *self {
                        TransactionType::Legacy => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "TransactionType",
                                0u32,
                                "legacy",
                            )
                        }
                        TransactionType::ValueTransfer => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "TransactionType",
                                1u32,
                                "value_transfer",
                            )
                        }
                        TransactionType::FeeDelegatedValueTransfer => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "TransactionType",
                                2u32,
                                "fee_delegated_value_transfer",
                            )
                        }
                        TransactionType::ValueTransferMemo => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "TransactionType",
                                3u32,
                                "value_transfer_memo",
                            )
                        }
                        TransactionType::FeeDelegatedValueTransferMemo => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "TransactionType",
                                4u32,
                                "fee_delegated_value_transfer_memo",
                            )
                        }
                        TransactionType::SmartContractDeploy => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "TransactionType",
                                5u32,
                                "smart_contract_deploy",
                            )
                        }
                        TransactionType::FeeDelegatedSmartContractDeploy => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "TransactionType",
                                6u32,
                                "fee_delegated_smart_contract_deploy",
                            )
                        }
                        TransactionType::SmartContractExecution => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "TransactionType",
                                7u32,
                                "smart_contract_execution",
                            )
                        }
                        TransactionType::FeeDelegatedSmartContractExecution => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "TransactionType",
                                8u32,
                                "fee_delegated_smart_contract_execution",
                            )
                        }
                        TransactionType::AccountUpdate => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "TransactionType",
                                9u32,
                                "account_update",
                            )
                        }
                        TransactionType::FeeDelegatedAccountUpdate => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "TransactionType",
                                10u32,
                                "fee_delegated_account_update",
                            )
                        }
                        TransactionType::Cancel => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "TransactionType",
                                11u32,
                                "cancel",
                            )
                        }
                        TransactionType::FeeDelegatedCancel => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "TransactionType",
                                12u32,
                                "fee_delegated_cancel",
                            )
                        }
                    }
                }
            }
        };
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for TransactionType {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __field3,
                        __field4,
                        __field5,
                        __field6,
                        __field7,
                        __field8,
                        __field9,
                        __field10,
                        __field11,
                        __field12,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "variant identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                3u64 => _serde::__private::Ok(__Field::__field3),
                                4u64 => _serde::__private::Ok(__Field::__field4),
                                5u64 => _serde::__private::Ok(__Field::__field5),
                                6u64 => _serde::__private::Ok(__Field::__field6),
                                7u64 => _serde::__private::Ok(__Field::__field7),
                                8u64 => _serde::__private::Ok(__Field::__field8),
                                9u64 => _serde::__private::Ok(__Field::__field9),
                                10u64 => _serde::__private::Ok(__Field::__field10),
                                11u64 => _serde::__private::Ok(__Field::__field11),
                                12u64 => _serde::__private::Ok(__Field::__field12),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::invalid_value(
                                            _serde::de::Unexpected::Unsigned(__value),
                                            &"variant index 0 <= i < 13",
                                        ),
                                    )
                                }
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "legacy" => _serde::__private::Ok(__Field::__field0),
                                "value_transfer" => _serde::__private::Ok(__Field::__field1),
                                "fee_delegated_value_transfer" => {
                                    _serde::__private::Ok(__Field::__field2)
                                }
                                "value_transfer_memo" => {
                                    _serde::__private::Ok(__Field::__field3)
                                }
                                "fee_delegated_value_transfer_memo" => {
                                    _serde::__private::Ok(__Field::__field4)
                                }
                                "smart_contract_deploy" => {
                                    _serde::__private::Ok(__Field::__field5)
                                }
                                "fee_delegated_smart_contract_deploy" => {
                                    _serde::__private::Ok(__Field::__field6)
                                }
                                "smart_contract_execution" => {
                                    _serde::__private::Ok(__Field::__field7)
                                }
                                "fee_delegated_smart_contract_execution" => {
                                    _serde::__private::Ok(__Field::__field8)
                                }
                                "account_update" => _serde::__private::Ok(__Field::__field9),
                                "fee_delegated_account_update" => {
                                    _serde::__private::Ok(__Field::__field10)
                                }
                                "cancel" => _serde::__private::Ok(__Field::__field11),
                                "fee_delegated_cancel" => {
                                    _serde::__private::Ok(__Field::__field12)
                                }
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"legacy" => _serde::__private::Ok(__Field::__field0),
                                b"value_transfer" => {
                                    _serde::__private::Ok(__Field::__field1)
                                }
                                b"fee_delegated_value_transfer" => {
                                    _serde::__private::Ok(__Field::__field2)
                                }
                                b"value_transfer_memo" => {
                                    _serde::__private::Ok(__Field::__field3)
                                }
                                b"fee_delegated_value_transfer_memo" => {
                                    _serde::__private::Ok(__Field::__field4)
                                }
                                b"smart_contract_deploy" => {
                                    _serde::__private::Ok(__Field::__field5)
                                }
                                b"fee_delegated_smart_contract_deploy" => {
                                    _serde::__private::Ok(__Field::__field6)
                                }
                                b"smart_contract_execution" => {
                                    _serde::__private::Ok(__Field::__field7)
                                }
                                b"fee_delegated_smart_contract_execution" => {
                                    _serde::__private::Ok(__Field::__field8)
                                }
                                b"account_update" => {
                                    _serde::__private::Ok(__Field::__field9)
                                }
                                b"fee_delegated_account_update" => {
                                    _serde::__private::Ok(__Field::__field10)
                                }
                                b"cancel" => _serde::__private::Ok(__Field::__field11),
                                b"fee_delegated_cancel" => {
                                    _serde::__private::Ok(__Field::__field12)
                                }
                                _ => {
                                    let __value = &_serde::__private::from_utf8_lossy(__value);
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<TransactionType>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = TransactionType;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "enum TransactionType",
                            )
                        }
                        fn visit_enum<__A>(
                            self,
                            __data: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::EnumAccess<'de>,
                        {
                            match _serde::de::EnumAccess::variant(__data)? {
                                (__Field::__field0, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(TransactionType::Legacy)
                                }
                                (__Field::__field1, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(TransactionType::ValueTransfer)
                                }
                                (__Field::__field2, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(
                                        TransactionType::FeeDelegatedValueTransfer,
                                    )
                                }
                                (__Field::__field3, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(TransactionType::ValueTransferMemo)
                                }
                                (__Field::__field4, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(
                                        TransactionType::FeeDelegatedValueTransferMemo,
                                    )
                                }
                                (__Field::__field5, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(TransactionType::SmartContractDeploy)
                                }
                                (__Field::__field6, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(
                                        TransactionType::FeeDelegatedSmartContractDeploy,
                                    )
                                }
                                (__Field::__field7, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(
                                        TransactionType::SmartContractExecution,
                                    )
                                }
                                (__Field::__field8, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(
                                        TransactionType::FeeDelegatedSmartContractExecution,
                                    )
                                }
                                (__Field::__field9, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(TransactionType::AccountUpdate)
                                }
                                (__Field::__field10, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(
                                        TransactionType::FeeDelegatedAccountUpdate,
                                    )
                                }
                                (__Field::__field11, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(TransactionType::Cancel)
                                }
                                (__Field::__field12, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(TransactionType::FeeDelegatedCancel)
                                }
                            }
                        }
                    }
                    #[doc(hidden)]
                    const VARIANTS: &'static [&'static str] = &[
                        "legacy",
                        "value_transfer",
                        "fee_delegated_value_transfer",
                        "value_transfer_memo",
                        "fee_delegated_value_transfer_memo",
                        "smart_contract_deploy",
                        "fee_delegated_smart_contract_deploy",
                        "smart_contract_execution",
                        "fee_delegated_smart_contract_execution",
                        "account_update",
                        "fee_delegated_account_update",
                        "cancel",
                        "fee_delegated_cancel",
                    ];
                    _serde::Deserializer::deserialize_enum(
                        __deserializer,
                        "TransactionType",
                        VARIANTS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<TransactionType>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        impl ::core::default::Default for TransactionType {
            #[inline]
            fn default() -> TransactionType {
                Self::Legacy
            }
        }
        impl TransactionType {
            pub fn to_tx_type_string(&self) -> String {
                match self {
                    TransactionType::Legacy => "LEGACY".to_string(),
                    TransactionType::ValueTransfer => "VALUE_TRANSFER".to_string(),
                    TransactionType::FeeDelegatedValueTransfer => {
                        "FEE_DELEGATED_VALUE_TRANSFER".to_string()
                    }
                    TransactionType::ValueTransferMemo => {
                        "VALUE_TRANSFER_MEMO".to_string()
                    }
                    TransactionType::FeeDelegatedValueTransferMemo => {
                        "FEE_DELEGATED_VALUE_TRANSFER_MEMO".to_string()
                    }
                    TransactionType::SmartContractDeploy => {
                        "SMART_CONTRACT_DEPLOY".to_string()
                    }
                    TransactionType::FeeDelegatedSmartContractDeploy => {
                        "FEE_DELEGATED_SMART_CONTRACT_DEPLOY".to_string()
                    }
                    TransactionType::SmartContractExecution => {
                        "SMART_CONTRACT_EXECUTION".to_string()
                    }
                    TransactionType::FeeDelegatedSmartContractExecution => {
                        "FEE_DELEGATED_SMART_CONTRACT_EXECUTION".to_string()
                    }
                    TransactionType::AccountUpdate => "ACCOUNT_UPDATE".to_string(),
                    TransactionType::FeeDelegatedAccountUpdate => {
                        "FEE_DELEGATED_ACCOUNT_UPDATE".to_string()
                    }
                    TransactionType::Cancel => "CANCEL".to_string(),
                    TransactionType::FeeDelegatedCancel => {
                        "FEE_DELEGATED_CANCEL".to_string()
                    }
                }
            }
            pub fn to_tx_type_code(&self) -> u8 {
                match self {
                    TransactionType::Legacy => 0x0,
                    TransactionType::ValueTransfer => 0x8,
                    TransactionType::FeeDelegatedValueTransfer => 0x9,
                    TransactionType::ValueTransferMemo => 0x10,
                    TransactionType::FeeDelegatedValueTransferMemo => 0x11,
                    TransactionType::AccountUpdate => 0x20,
                    TransactionType::FeeDelegatedAccountUpdate => 0x21,
                    TransactionType::SmartContractDeploy => 0x28,
                    TransactionType::FeeDelegatedSmartContractDeploy => 0x29,
                    TransactionType::SmartContractExecution => 0x30,
                    TransactionType::FeeDelegatedSmartContractExecution => 0x31,
                    TransactionType::Cancel => 0x38,
                    TransactionType::FeeDelegatedCancel => 0x39,
                }
            }
        }
        impl TryFrom<&str> for TransactionType {
            type Error = String;
            fn try_from(value: &str) -> Result<Self, Self::Error> {
                match value {
                    "VALUE_TRANSFER" => Ok(TransactionType::ValueTransfer),
                    "FEE_DELEGATED_VALUE_TRANSFER" => {
                        Ok(TransactionType::FeeDelegatedValueTransfer)
                    }
                    "VALUE_TRANSFER_MEMO" => Ok(TransactionType::ValueTransferMemo),
                    "FEE_DELEGATED_VALUE_TRANSFER_MEMO" => {
                        Ok(TransactionType::FeeDelegatedValueTransferMemo)
                    }
                    "SMART_CONTRACT_DEPLOY" => Ok(TransactionType::SmartContractDeploy),
                    "FEE_DELEGATED_SMART_CONTRACT_DEPLOY" => {
                        Ok(TransactionType::FeeDelegatedSmartContractDeploy)
                    }
                    "SMART_CONTRACT_EXECUTION" => {
                        Ok(TransactionType::SmartContractExecution)
                    }
                    "FEE_DELEGATED_SMART_CONTRACT_EXECUTION" => {
                        Ok(TransactionType::FeeDelegatedSmartContractExecution)
                    }
                    "ACCOUNT_UPDATE" => Ok(TransactionType::AccountUpdate),
                    "FEE_DELEGATED_ACCOUNT_UPDATE" => {
                        Ok(TransactionType::FeeDelegatedAccountUpdate)
                    }
                    "CANCEL" => Ok(TransactionType::Cancel),
                    "FEE_DELEGATED_CANCEL" => Ok(TransactionType::FeeDelegatedCancel),
                    "LEGACY" => Ok(TransactionType::Legacy),
                    _ => {
                        Err(
                            ::alloc::__export::must_use({
                                let res = ::alloc::fmt::format(
                                    format_args!("Unknown transaction type: {0}", value),
                                );
                                res
                            }),
                        )
                    }
                }
            }
        }
        pub struct KlaytnTransaction {
            pub tx_type: TransactionType,
            pub nonce: Option<U256>,
            pub gas_price: Option<U256>,
            pub gas: Option<U256>,
            pub from: Option<Address>,
            pub to: Option<Address>,
            pub value: Option<U256>,
            pub input: Option<Vec<u8>>,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for KlaytnTransaction {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let names: &'static _ = &[
                    "tx_type",
                    "nonce",
                    "gas_price",
                    "gas",
                    "from",
                    "to",
                    "value",
                    "input",
                ];
                let values: &[&dyn ::core::fmt::Debug] = &[
                    &self.tx_type,
                    &self.nonce,
                    &self.gas_price,
                    &self.gas,
                    &self.from,
                    &self.to,
                    &self.value,
                    &&self.input,
                ];
                ::core::fmt::Formatter::debug_struct_fields_finish(
                    f,
                    "KlaytnTransaction",
                    names,
                    values,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for KlaytnTransaction {
            #[inline]
            fn clone(&self) -> KlaytnTransaction {
                KlaytnTransaction {
                    tx_type: ::core::clone::Clone::clone(&self.tx_type),
                    nonce: ::core::clone::Clone::clone(&self.nonce),
                    gas_price: ::core::clone::Clone::clone(&self.gas_price),
                    gas: ::core::clone::Clone::clone(&self.gas),
                    from: ::core::clone::Clone::clone(&self.from),
                    to: ::core::clone::Clone::clone(&self.to),
                    value: ::core::clone::Clone::clone(&self.value),
                    input: ::core::clone::Clone::clone(&self.input),
                }
            }
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for KlaytnTransaction {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "KlaytnTransaction",
                        false as usize + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "tx_type",
                        &self.tx_type,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "nonce",
                        &self.nonce,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "gas_price",
                        &self.gas_price,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "gas",
                        &self.gas,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "from",
                        &self.from,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "to",
                        &self.to,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "value",
                        &self.value,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "input",
                        &self.input,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for KlaytnTransaction {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __field3,
                        __field4,
                        __field5,
                        __field6,
                        __field7,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                3u64 => _serde::__private::Ok(__Field::__field3),
                                4u64 => _serde::__private::Ok(__Field::__field4),
                                5u64 => _serde::__private::Ok(__Field::__field5),
                                6u64 => _serde::__private::Ok(__Field::__field6),
                                7u64 => _serde::__private::Ok(__Field::__field7),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "tx_type" => _serde::__private::Ok(__Field::__field0),
                                "nonce" => _serde::__private::Ok(__Field::__field1),
                                "gas_price" => _serde::__private::Ok(__Field::__field2),
                                "gas" => _serde::__private::Ok(__Field::__field3),
                                "from" => _serde::__private::Ok(__Field::__field4),
                                "to" => _serde::__private::Ok(__Field::__field5),
                                "value" => _serde::__private::Ok(__Field::__field6),
                                "input" => _serde::__private::Ok(__Field::__field7),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"tx_type" => _serde::__private::Ok(__Field::__field0),
                                b"nonce" => _serde::__private::Ok(__Field::__field1),
                                b"gas_price" => _serde::__private::Ok(__Field::__field2),
                                b"gas" => _serde::__private::Ok(__Field::__field3),
                                b"from" => _serde::__private::Ok(__Field::__field4),
                                b"to" => _serde::__private::Ok(__Field::__field5),
                                b"value" => _serde::__private::Ok(__Field::__field6),
                                b"input" => _serde::__private::Ok(__Field::__field7),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<KlaytnTransaction>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = KlaytnTransaction;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct KlaytnTransaction",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                TransactionType,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct KlaytnTransaction with 8 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                Option<U256>,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct KlaytnTransaction with 8 elements",
                                        ),
                                    );
                                }
                            };
                            let __field2 = match _serde::de::SeqAccess::next_element::<
                                Option<U256>,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            2usize,
                                            &"struct KlaytnTransaction with 8 elements",
                                        ),
                                    );
                                }
                            };
                            let __field3 = match _serde::de::SeqAccess::next_element::<
                                Option<U256>,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            3usize,
                                            &"struct KlaytnTransaction with 8 elements",
                                        ),
                                    );
                                }
                            };
                            let __field4 = match _serde::de::SeqAccess::next_element::<
                                Option<Address>,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            4usize,
                                            &"struct KlaytnTransaction with 8 elements",
                                        ),
                                    );
                                }
                            };
                            let __field5 = match _serde::de::SeqAccess::next_element::<
                                Option<Address>,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            5usize,
                                            &"struct KlaytnTransaction with 8 elements",
                                        ),
                                    );
                                }
                            };
                            let __field6 = match _serde::de::SeqAccess::next_element::<
                                Option<U256>,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            6usize,
                                            &"struct KlaytnTransaction with 8 elements",
                                        ),
                                    );
                                }
                            };
                            let __field7 = match _serde::de::SeqAccess::next_element::<
                                Option<Vec<u8>>,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            7usize,
                                            &"struct KlaytnTransaction with 8 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(KlaytnTransaction {
                                tx_type: __field0,
                                nonce: __field1,
                                gas_price: __field2,
                                gas: __field3,
                                from: __field4,
                                to: __field5,
                                value: __field6,
                                input: __field7,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<
                                TransactionType,
                            > = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<Option<U256>> = _serde::__private::None;
                            let mut __field2: _serde::__private::Option<Option<U256>> = _serde::__private::None;
                            let mut __field3: _serde::__private::Option<Option<U256>> = _serde::__private::None;
                            let mut __field4: _serde::__private::Option<
                                Option<Address>,
                            > = _serde::__private::None;
                            let mut __field5: _serde::__private::Option<
                                Option<Address>,
                            > = _serde::__private::None;
                            let mut __field6: _serde::__private::Option<Option<U256>> = _serde::__private::None;
                            let mut __field7: _serde::__private::Option<
                                Option<Vec<u8>>,
                            > = _serde::__private::None;
                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "tx_type",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                TransactionType,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("nonce"),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                Option<U256>,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field2 => {
                                        if _serde::__private::Option::is_some(&__field2) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "gas_price",
                                                ),
                                            );
                                        }
                                        __field2 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                Option<U256>,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field3 => {
                                        if _serde::__private::Option::is_some(&__field3) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("gas"),
                                            );
                                        }
                                        __field3 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                Option<U256>,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field4 => {
                                        if _serde::__private::Option::is_some(&__field4) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("from"),
                                            );
                                        }
                                        __field4 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                Option<Address>,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field5 => {
                                        if _serde::__private::Option::is_some(&__field5) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("to"),
                                            );
                                        }
                                        __field5 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                Option<Address>,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field6 => {
                                        if _serde::__private::Option::is_some(&__field6) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("value"),
                                            );
                                        }
                                        __field6 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                Option<U256>,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field7 => {
                                        if _serde::__private::Option::is_some(&__field7) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("input"),
                                            );
                                        }
                                        __field7 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                Option<Vec<u8>>,
                                            >(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("tx_type")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("nonce")?
                                }
                            };
                            let __field2 = match __field2 {
                                _serde::__private::Some(__field2) => __field2,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("gas_price")?
                                }
                            };
                            let __field3 = match __field3 {
                                _serde::__private::Some(__field3) => __field3,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("gas")?
                                }
                            };
                            let __field4 = match __field4 {
                                _serde::__private::Some(__field4) => __field4,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("from")?
                                }
                            };
                            let __field5 = match __field5 {
                                _serde::__private::Some(__field5) => __field5,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("to")?
                                }
                            };
                            let __field6 = match __field6 {
                                _serde::__private::Some(__field6) => __field6,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("value")?
                                }
                            };
                            let __field7 = match __field7 {
                                _serde::__private::Some(__field7) => __field7,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("input")?
                                }
                            };
                            _serde::__private::Ok(KlaytnTransaction {
                                tx_type: __field0,
                                nonce: __field1,
                                gas_price: __field2,
                                gas: __field3,
                                from: __field4,
                                to: __field5,
                                value: __field6,
                                input: __field7,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &[
                        "tx_type",
                        "nonce",
                        "gas_price",
                        "gas",
                        "from",
                        "to",
                        "value",
                        "input",
                    ];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "KlaytnTransaction",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<KlaytnTransaction>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for KlaytnTransaction {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for KlaytnTransaction {
            #[inline]
            fn eq(&self, other: &KlaytnTransaction) -> bool {
                self.tx_type == other.tx_type && self.nonce == other.nonce
                    && self.gas_price == other.gas_price && self.gas == other.gas
                    && self.from == other.from && self.to == other.to
                    && self.value == other.value && self.input == other.input
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for KlaytnTransaction {
            #[inline]
            fn default() -> KlaytnTransaction {
                KlaytnTransaction {
                    tx_type: ::core::default::Default::default(),
                    nonce: ::core::default::Default::default(),
                    gas_price: ::core::default::Default::default(),
                    gas: ::core::default::Default::default(),
                    from: ::core::default::Default::default(),
                    to: ::core::default::Default::default(),
                    value: ::core::default::Default::default(),
                    input: ::core::default::Default::default(),
                }
            }
        }
        impl KlaytnTransaction {
            pub fn new(
                tx_type: TransactionType,
                from: Option<Address>,
                to: Option<Address>,
                gas: Option<U256>,
                gas_price: Option<U256>,
                value: Option<U256>,
                input: Option<Vec<u8>>,
                nonce: Option<U256>,
            ) -> Self {
                KlaytnTransaction {
                    tx_type,
                    nonce,
                    gas_price,
                    gas,
                    from,
                    to,
                    value,
                    input,
                }
            }
            pub fn value_with_default_zero(&self) -> U256 {
                self.value.unwrap_or(U256::from(0))
            }
            pub fn to_tx_hash_rlp(
                &self,
                signature: Signature,
                fee_payer: H160,
                fee_payer_signature: Signature,
            ) -> Vec<u8> {
                let mut rlp = RlpStream::new();
                match self.tx_type {
                    TransactionType::FeeDelegatedSmartContractExecution => {
                        rlp.append(&self.tx_type.to_tx_type_code());
                        rlp.begin_list(10);
                        rlp_opt(&mut rlp, &self.nonce);
                        rlp_opt(&mut rlp, &self.gas_price);
                        rlp_opt(&mut rlp, &self.gas);
                        rlp_opt(&mut rlp, &self.to);
                        rlp_opt(&mut rlp, &self.value);
                        rlp_opt(&mut rlp, &self.from);
                        rlp_opt(&mut rlp, &self.input);
                        rlp_sig(&mut rlp, &signature);
                        rlp.append(&fee_payer);
                        rlp_sig(&mut rlp, &fee_payer_signature);
                    }
                    _ => {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "not implemented: {0}",
                                format_args!("unsupported type"),
                            ),
                        );
                    }
                }
                rlp.out().to_vec()
            }
            pub fn to_sig_fee_payer_rlp(
                &self,
                fee_payer: H160,
                chain_id: u64,
            ) -> Vec<u8> {
                let mut rlp = RlpStream::new();
                match self.tx_type {
                    TransactionType::FeeDelegatedSmartContractExecution => {
                        rlp.begin_list(5);
                        let mut inner = RlpStream::new_list(8);
                        inner.append(&self.tx_type.to_tx_type_code());
                        rlp_opt(&mut inner, &self.nonce);
                        rlp_opt(&mut inner, &self.gas_price);
                        rlp_opt(&mut inner, &self.gas);
                        rlp_opt(&mut inner, &self.to);
                        rlp_opt(&mut inner, &self.value);
                        rlp_opt(&mut inner, &self.from);
                        rlp_opt(&mut inner, &self.input);
                        rlp.append(&inner.out());
                        rlp.append(&fee_payer);
                        rlp.append(&chain_id);
                        rlp.append(&0u8);
                        rlp.append(&0u8);
                    }
                    _ => {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "not implemented: {0}",
                                format_args!("unsupported type"),
                            ),
                        );
                    }
                }
                rlp.out().to_vec()
            }
            pub fn to_sig_rlp(&self, chain_id: u64) -> Vec<u8> {
                let mut rlp = RlpStream::new();
                match self.tx_type {
                    TransactionType::FeeDelegatedSmartContractExecution => {
                        rlp.begin_unbounded_list();
                        let mut inner = RlpStream::new_list(8);
                        inner.append(&self.tx_type.to_tx_type_code());
                        rlp_opt(&mut inner, &self.nonce);
                        rlp_opt(&mut inner, &self.gas_price);
                        rlp_opt(&mut inner, &self.gas);
                        rlp_opt(&mut inner, &self.to);
                        rlp_opt(&mut inner, &self.value);
                        rlp_opt(&mut inner, &self.from);
                        rlp_opt(&mut inner, &self.input);
                        rlp.append(&inner.out());
                        rlp.append(&chain_id);
                        rlp.append(&0u8);
                        rlp.append(&0u8);
                        rlp.finalize_unbounded_list();
                    }
                    _ => {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "not implemented: {0}",
                                format_args!("unsupported type"),
                            ),
                        );
                    }
                }
                rlp.out().to_vec()
            }
            pub fn to_sig_hash(&self, chain_id: u64) -> H256 {
                let sig_rlp = self.to_sig_rlp(chain_id);
                let hash = ethers::utils::keccak256(&sig_rlp);
                H256::from_slice(&hash)
            }
            pub fn to_sig_fee_payer_hash(&self, fee_payer: H160, chain_id: u64) -> H256 {
                let sig_rlp = self.to_sig_fee_payer_rlp(fee_payer, chain_id);
                let hash = ethers::utils::keccak256(&sig_rlp);
                H256::from_slice(&hash)
            }
        }
        pub fn rlp_opt<T: rlp::Encodable>(rlp: &mut rlp::RlpStream, opt: &Option<T>) {
            if let Some(inner) = opt {
                rlp.append(inner);
            } else {
                rlp.append(&"");
            }
        }
        pub fn rlp_sig(rlp: &mut rlp::RlpStream, sig: &Signature) {
            rlp.begin_list(1);
            rlp.begin_list(3);
            rlp.append(&sig.v);
            rlp.append(&sig.r);
            rlp.append(&sig.s);
        }
    }
}
pub mod dao {
    use candid::{CandidType, Principal};
    use serde::{Deserialize, Serialize};
    pub struct ProposalSummary {
        pub id: u64,
        pub proposer: Principal,
        pub proposal_type: u64,
        pub title: String,
        pub status: ProposalStatus,
        pub result: Option<ProposalResult>,
        pub votes: u64,
        pub deadline: u64,
        pub total_comments: Option<u64>,
    }
    impl ::candid::types::CandidType for ProposalSummary {
        fn _ty() -> ::candid::types::Type {
            ::candid::types::TypeInner::Record(
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named("id".to_string()).into(),
                                ty: <u64 as ::candid::types::CandidType>::ty(),
                            },
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named("status".to_string())
                                    .into(),
                                ty: <ProposalStatus as ::candid::types::CandidType>::ty(),
                            },
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named("result".to_string())
                                    .into(),
                                ty: <Option<
                                    ProposalResult,
                                > as ::candid::types::CandidType>::ty(),
                            },
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named("title".to_string())
                                    .into(),
                                ty: <String as ::candid::types::CandidType>::ty(),
                            },
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named("votes".to_string())
                                    .into(),
                                ty: <u64 as ::candid::types::CandidType>::ty(),
                            },
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named(
                                        "total_comments".to_string(),
                                    )
                                    .into(),
                                ty: <Option<u64> as ::candid::types::CandidType>::ty(),
                            },
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named("deadline".to_string())
                                    .into(),
                                ty: <u64 as ::candid::types::CandidType>::ty(),
                            },
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named("proposer".to_string())
                                    .into(),
                                ty: <Principal as ::candid::types::CandidType>::ty(),
                            },
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named(
                                        "proposal_type".to_string(),
                                    )
                                    .into(),
                                ty: <u64 as ::candid::types::CandidType>::ty(),
                            },
                        ]),
                    ),
                )
                .into()
        }
        fn id() -> ::candid::types::TypeId {
            ::candid::types::TypeId::of::<ProposalSummary>()
        }
        fn idl_serialize<__S>(
            &self,
            __serializer: __S,
        ) -> ::std::result::Result<(), __S::Error>
        where
            __S: ::candid::types::Serializer,
        {
            let mut ser = __serializer.serialize_struct()?;
            ::candid::types::Compound::serialize_element(&mut ser, &self.id)?;
            ::candid::types::Compound::serialize_element(&mut ser, &self.status)?;
            ::candid::types::Compound::serialize_element(&mut ser, &self.result)?;
            ::candid::types::Compound::serialize_element(&mut ser, &self.title)?;
            ::candid::types::Compound::serialize_element(&mut ser, &self.votes)?;
            ::candid::types::Compound::serialize_element(
                &mut ser,
                &self.total_comments,
            )?;
            ::candid::types::Compound::serialize_element(&mut ser, &self.deadline)?;
            ::candid::types::Compound::serialize_element(&mut ser, &self.proposer)?;
            ::candid::types::Compound::serialize_element(&mut ser, &self.proposal_type)?;
            Ok(())
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for ProposalSummary {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let names: &'static _ = &[
                "id",
                "proposer",
                "proposal_type",
                "title",
                "status",
                "result",
                "votes",
                "deadline",
                "total_comments",
            ];
            let values: &[&dyn ::core::fmt::Debug] = &[
                &self.id,
                &self.proposer,
                &self.proposal_type,
                &self.title,
                &self.status,
                &self.result,
                &self.votes,
                &self.deadline,
                &&self.total_comments,
            ];
            ::core::fmt::Formatter::debug_struct_fields_finish(
                f,
                "ProposalSummary",
                names,
                values,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for ProposalSummary {
        #[inline]
        fn clone(&self) -> ProposalSummary {
            ProposalSummary {
                id: ::core::clone::Clone::clone(&self.id),
                proposer: ::core::clone::Clone::clone(&self.proposer),
                proposal_type: ::core::clone::Clone::clone(&self.proposal_type),
                title: ::core::clone::Clone::clone(&self.title),
                status: ::core::clone::Clone::clone(&self.status),
                result: ::core::clone::Clone::clone(&self.result),
                votes: ::core::clone::Clone::clone(&self.votes),
                deadline: ::core::clone::Clone::clone(&self.deadline),
                total_comments: ::core::clone::Clone::clone(&self.total_comments),
            }
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for ProposalSummary {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "ProposalSummary",
                    false as usize + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "id",
                    &self.id,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "proposer",
                    &self.proposer,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "proposal_type",
                    &self.proposal_type,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "title",
                    &self.title,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "status",
                    &self.status,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "result",
                    &self.result,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "votes",
                    &self.votes,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "deadline",
                    &self.deadline,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "total_comments",
                    &self.total_comments,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for ProposalSummary {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __field4,
                    __field5,
                    __field6,
                    __field7,
                    __field8,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            4u64 => _serde::__private::Ok(__Field::__field4),
                            5u64 => _serde::__private::Ok(__Field::__field5),
                            6u64 => _serde::__private::Ok(__Field::__field6),
                            7u64 => _serde::__private::Ok(__Field::__field7),
                            8u64 => _serde::__private::Ok(__Field::__field8),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "id" => _serde::__private::Ok(__Field::__field0),
                            "proposer" => _serde::__private::Ok(__Field::__field1),
                            "proposal_type" => _serde::__private::Ok(__Field::__field2),
                            "title" => _serde::__private::Ok(__Field::__field3),
                            "status" => _serde::__private::Ok(__Field::__field4),
                            "result" => _serde::__private::Ok(__Field::__field5),
                            "votes" => _serde::__private::Ok(__Field::__field6),
                            "deadline" => _serde::__private::Ok(__Field::__field7),
                            "total_comments" => _serde::__private::Ok(__Field::__field8),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"id" => _serde::__private::Ok(__Field::__field0),
                            b"proposer" => _serde::__private::Ok(__Field::__field1),
                            b"proposal_type" => _serde::__private::Ok(__Field::__field2),
                            b"title" => _serde::__private::Ok(__Field::__field3),
                            b"status" => _serde::__private::Ok(__Field::__field4),
                            b"result" => _serde::__private::Ok(__Field::__field5),
                            b"votes" => _serde::__private::Ok(__Field::__field6),
                            b"deadline" => _serde::__private::Ok(__Field::__field7),
                            b"total_comments" => _serde::__private::Ok(__Field::__field8),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<ProposalSummary>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = ProposalSummary;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct ProposalSummary",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            u64,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct ProposalSummary with 9 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            Principal,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct ProposalSummary with 9 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match _serde::de::SeqAccess::next_element::<
                            u64,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct ProposalSummary with 9 elements",
                                    ),
                                );
                            }
                        };
                        let __field3 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        3usize,
                                        &"struct ProposalSummary with 9 elements",
                                    ),
                                );
                            }
                        };
                        let __field4 = match _serde::de::SeqAccess::next_element::<
                            ProposalStatus,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        4usize,
                                        &"struct ProposalSummary with 9 elements",
                                    ),
                                );
                            }
                        };
                        let __field5 = match _serde::de::SeqAccess::next_element::<
                            Option<ProposalResult>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        5usize,
                                        &"struct ProposalSummary with 9 elements",
                                    ),
                                );
                            }
                        };
                        let __field6 = match _serde::de::SeqAccess::next_element::<
                            u64,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        6usize,
                                        &"struct ProposalSummary with 9 elements",
                                    ),
                                );
                            }
                        };
                        let __field7 = match _serde::de::SeqAccess::next_element::<
                            u64,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        7usize,
                                        &"struct ProposalSummary with 9 elements",
                                    ),
                                );
                            }
                        };
                        let __field8 = match _serde::de::SeqAccess::next_element::<
                            Option<u64>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        8usize,
                                        &"struct ProposalSummary with 9 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(ProposalSummary {
                            id: __field0,
                            proposer: __field1,
                            proposal_type: __field2,
                            title: __field3,
                            status: __field4,
                            result: __field5,
                            votes: __field6,
                            deadline: __field7,
                            total_comments: __field8,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<u64> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<Principal> = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<u64> = _serde::__private::None;
                        let mut __field3: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field4: _serde::__private::Option<ProposalStatus> = _serde::__private::None;
                        let mut __field5: _serde::__private::Option<
                            Option<ProposalResult>,
                        > = _serde::__private::None;
                        let mut __field6: _serde::__private::Option<u64> = _serde::__private::None;
                        let mut __field7: _serde::__private::Option<u64> = _serde::__private::None;
                        let mut __field8: _serde::__private::Option<Option<u64>> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("id"),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<u64>(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "proposer",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<Principal>(&mut __map)?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "proposal_type",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<u64>(&mut __map)?,
                                    );
                                }
                                __Field::__field3 => {
                                    if _serde::__private::Option::is_some(&__field3) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("title"),
                                        );
                                    }
                                    __field3 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field4 => {
                                    if _serde::__private::Option::is_some(&__field4) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("status"),
                                        );
                                    }
                                    __field4 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            ProposalStatus,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field5 => {
                                    if _serde::__private::Option::is_some(&__field5) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("result"),
                                        );
                                    }
                                    __field5 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<ProposalResult>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field6 => {
                                    if _serde::__private::Option::is_some(&__field6) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("votes"),
                                        );
                                    }
                                    __field6 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<u64>(&mut __map)?,
                                    );
                                }
                                __Field::__field7 => {
                                    if _serde::__private::Option::is_some(&__field7) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "deadline",
                                            ),
                                        );
                                    }
                                    __field7 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<u64>(&mut __map)?,
                                    );
                                }
                                __Field::__field8 => {
                                    if _serde::__private::Option::is_some(&__field8) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "total_comments",
                                            ),
                                        );
                                    }
                                    __field8 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<u64>,
                                        >(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("id")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("proposer")?
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("proposal_type")?
                            }
                        };
                        let __field3 = match __field3 {
                            _serde::__private::Some(__field3) => __field3,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("title")?
                            }
                        };
                        let __field4 = match __field4 {
                            _serde::__private::Some(__field4) => __field4,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("status")?
                            }
                        };
                        let __field5 = match __field5 {
                            _serde::__private::Some(__field5) => __field5,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("result")?
                            }
                        };
                        let __field6 = match __field6 {
                            _serde::__private::Some(__field6) => __field6,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("votes")?
                            }
                        };
                        let __field7 = match __field7 {
                            _serde::__private::Some(__field7) => __field7,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("deadline")?
                            }
                        };
                        let __field8 = match __field8 {
                            _serde::__private::Some(__field8) => __field8,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("total_comments")?
                            }
                        };
                        _serde::__private::Ok(ProposalSummary {
                            id: __field0,
                            proposer: __field1,
                            proposal_type: __field2,
                            title: __field3,
                            status: __field4,
                            result: __field5,
                            votes: __field6,
                            deadline: __field7,
                            total_comments: __field8,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "id",
                    "proposer",
                    "proposal_type",
                    "title",
                    "status",
                    "result",
                    "votes",
                    "deadline",
                    "total_comments",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "ProposalSummary",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<ProposalSummary>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    pub enum ProposalType {
        EventProposalType = 0,
        DiscussionProposalType = 1,
    }
    impl ::candid::types::CandidType for ProposalType {
        fn _ty() -> ::candid::types::Type {
            ::candid::types::TypeInner::Variant(
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named(
                                        "EventProposalType".to_owned(),
                                    )
                                    .into(),
                                ty: ::candid::types::TypeInner::Null.into(),
                            },
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named(
                                        "DiscussionProposalType".to_owned(),
                                    )
                                    .into(),
                                ty: ::candid::types::TypeInner::Null.into(),
                            },
                        ]),
                    ),
                )
                .into()
        }
        fn id() -> ::candid::types::TypeId {
            ::candid::types::TypeId::of::<ProposalType>()
        }
        fn idl_serialize<__S>(
            &self,
            __serializer: __S,
        ) -> ::std::result::Result<(), __S::Error>
        where
            __S: ::candid::types::Serializer,
        {
            match *self {
                ProposalType::EventProposalType => {
                    let mut ser = __serializer.serialize_variant(0u64)?;
                }
                ProposalType::DiscussionProposalType => {
                    let mut ser = __serializer.serialize_variant(1u64)?;
                }
            };
            Ok(())
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for ProposalType {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(
                f,
                match self {
                    ProposalType::EventProposalType => "EventProposalType",
                    ProposalType::DiscussionProposalType => "DiscussionProposalType",
                },
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for ProposalType {}
    #[automatically_derived]
    impl ::core::clone::Clone for ProposalType {
        #[inline]
        fn clone(&self) -> ProposalType {
            *self
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for ProposalType {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    ProposalType::EventProposalType => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "ProposalType",
                            0u32,
                            "EventProposalType",
                        )
                    }
                    ProposalType::DiscussionProposalType => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "ProposalType",
                            1u32,
                            "DiscussionProposalType",
                        )
                    }
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for ProposalType {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "variant identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::invalid_value(
                                        _serde::de::Unexpected::Unsigned(__value),
                                        &"variant index 0 <= i < 2",
                                    ),
                                )
                            }
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "EventProposalType" => {
                                _serde::__private::Ok(__Field::__field0)
                            }
                            "DiscussionProposalType" => {
                                _serde::__private::Ok(__Field::__field1)
                            }
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"EventProposalType" => {
                                _serde::__private::Ok(__Field::__field0)
                            }
                            b"DiscussionProposalType" => {
                                _serde::__private::Ok(__Field::__field1)
                            }
                            _ => {
                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<ProposalType>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = ProposalType;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "enum ProposalType",
                        )
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match _serde::de::EnumAccess::variant(__data)? {
                            (__Field::__field0, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(ProposalType::EventProposalType)
                            }
                            (__Field::__field1, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(ProposalType::DiscussionProposalType)
                            }
                        }
                    }
                }
                #[doc(hidden)]
                const VARIANTS: &'static [&'static str] = &[
                    "EventProposalType",
                    "DiscussionProposalType",
                ];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "ProposalType",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<ProposalType>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for ProposalType {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for ProposalType {
        #[inline]
        fn eq(&self, other: &ProposalType) -> bool {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            let __arg1_discr = ::core::intrinsics::discriminant_value(other);
            __self_discr == __arg1_discr
        }
    }
    impl ProposalType {
        pub fn from_u64(value: u64) -> Option<Self> {
            match value {
                0 => Some(ProposalType::EventProposalType),
                1 => Some(ProposalType::DiscussionProposalType),
                _ => None,
            }
        }
    }
    pub enum ProposalStatus {
        #[serde(rename = "active")]
        Active,
        #[serde(rename = "finished")]
        Finished,
    }
    impl ::candid::types::CandidType for ProposalStatus {
        fn _ty() -> ::candid::types::Type {
            ::candid::types::TypeInner::Variant(
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named("active".to_owned())
                                    .into(),
                                ty: ::candid::types::TypeInner::Null.into(),
                            },
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named("finished".to_owned())
                                    .into(),
                                ty: ::candid::types::TypeInner::Null.into(),
                            },
                        ]),
                    ),
                )
                .into()
        }
        fn id() -> ::candid::types::TypeId {
            ::candid::types::TypeId::of::<ProposalStatus>()
        }
        fn idl_serialize<__S>(
            &self,
            __serializer: __S,
        ) -> ::std::result::Result<(), __S::Error>
        where
            __S: ::candid::types::Serializer,
        {
            match *self {
                ProposalStatus::Active => {
                    let mut ser = __serializer.serialize_variant(0u64)?;
                }
                ProposalStatus::Finished => {
                    let mut ser = __serializer.serialize_variant(1u64)?;
                }
            };
            Ok(())
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for ProposalStatus {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(
                f,
                match self {
                    ProposalStatus::Active => "Active",
                    ProposalStatus::Finished => "Finished",
                },
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for ProposalStatus {
        #[inline]
        fn clone(&self) -> ProposalStatus {
            match self {
                ProposalStatus::Active => ProposalStatus::Active,
                ProposalStatus::Finished => ProposalStatus::Finished,
            }
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for ProposalStatus {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    ProposalStatus::Active => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "ProposalStatus",
                            0u32,
                            "active",
                        )
                    }
                    ProposalStatus::Finished => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "ProposalStatus",
                            1u32,
                            "finished",
                        )
                    }
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for ProposalStatus {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "variant identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::invalid_value(
                                        _serde::de::Unexpected::Unsigned(__value),
                                        &"variant index 0 <= i < 2",
                                    ),
                                )
                            }
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "active" => _serde::__private::Ok(__Field::__field0),
                            "finished" => _serde::__private::Ok(__Field::__field1),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"active" => _serde::__private::Ok(__Field::__field0),
                            b"finished" => _serde::__private::Ok(__Field::__field1),
                            _ => {
                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<ProposalStatus>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = ProposalStatus;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "enum ProposalStatus",
                        )
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match _serde::de::EnumAccess::variant(__data)? {
                            (__Field::__field0, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(ProposalStatus::Active)
                            }
                            (__Field::__field1, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(ProposalStatus::Finished)
                            }
                        }
                    }
                }
                #[doc(hidden)]
                const VARIANTS: &'static [&'static str] = &["active", "finished"];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "ProposalStatus",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<ProposalStatus>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for ProposalStatus {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for ProposalStatus {
        #[inline]
        fn eq(&self, other: &ProposalStatus) -> bool {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            let __arg1_discr = ::core::intrinsics::discriminant_value(other);
            __self_discr == __arg1_discr
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Eq for ProposalStatus {
        #[inline]
        #[doc(hidden)]
        #[coverage(off)]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    pub enum ProposalResult {
        #[serde(rename = "accepted")]
        Accepted,
        #[serde(rename = "rejected")]
        Rejected,
        #[serde(rename = "pending")]
        Pending,
    }
    impl ::candid::types::CandidType for ProposalResult {
        fn _ty() -> ::candid::types::Type {
            ::candid::types::TypeInner::Variant(
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named("pending".to_owned())
                                    .into(),
                                ty: ::candid::types::TypeInner::Null.into(),
                            },
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named("rejected".to_owned())
                                    .into(),
                                ty: ::candid::types::TypeInner::Null.into(),
                            },
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named("accepted".to_owned())
                                    .into(),
                                ty: ::candid::types::TypeInner::Null.into(),
                            },
                        ]),
                    ),
                )
                .into()
        }
        fn id() -> ::candid::types::TypeId {
            ::candid::types::TypeId::of::<ProposalResult>()
        }
        fn idl_serialize<__S>(
            &self,
            __serializer: __S,
        ) -> ::std::result::Result<(), __S::Error>
        where
            __S: ::candid::types::Serializer,
        {
            match *self {
                ProposalResult::Pending => {
                    let mut ser = __serializer.serialize_variant(0u64)?;
                }
                ProposalResult::Rejected => {
                    let mut ser = __serializer.serialize_variant(1u64)?;
                }
                ProposalResult::Accepted => {
                    let mut ser = __serializer.serialize_variant(2u64)?;
                }
            };
            Ok(())
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for ProposalResult {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(
                f,
                match self {
                    ProposalResult::Accepted => "Accepted",
                    ProposalResult::Rejected => "Rejected",
                    ProposalResult::Pending => "Pending",
                },
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for ProposalResult {
        #[inline]
        fn clone(&self) -> ProposalResult {
            match self {
                ProposalResult::Accepted => ProposalResult::Accepted,
                ProposalResult::Rejected => ProposalResult::Rejected,
                ProposalResult::Pending => ProposalResult::Pending,
            }
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for ProposalResult {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    ProposalResult::Accepted => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "ProposalResult",
                            0u32,
                            "accepted",
                        )
                    }
                    ProposalResult::Rejected => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "ProposalResult",
                            1u32,
                            "rejected",
                        )
                    }
                    ProposalResult::Pending => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "ProposalResult",
                            2u32,
                            "pending",
                        )
                    }
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for ProposalResult {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "variant identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::invalid_value(
                                        _serde::de::Unexpected::Unsigned(__value),
                                        &"variant index 0 <= i < 3",
                                    ),
                                )
                            }
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "accepted" => _serde::__private::Ok(__Field::__field0),
                            "rejected" => _serde::__private::Ok(__Field::__field1),
                            "pending" => _serde::__private::Ok(__Field::__field2),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"accepted" => _serde::__private::Ok(__Field::__field0),
                            b"rejected" => _serde::__private::Ok(__Field::__field1),
                            b"pending" => _serde::__private::Ok(__Field::__field2),
                            _ => {
                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<ProposalResult>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = ProposalResult;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "enum ProposalResult",
                        )
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match _serde::de::EnumAccess::variant(__data)? {
                            (__Field::__field0, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(ProposalResult::Accepted)
                            }
                            (__Field::__field1, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(ProposalResult::Rejected)
                            }
                            (__Field::__field2, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(ProposalResult::Pending)
                            }
                        }
                    }
                }
                #[doc(hidden)]
                const VARIANTS: &'static [&'static str] = &[
                    "accepted",
                    "rejected",
                    "pending",
                ];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "ProposalResult",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<ProposalResult>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for ProposalResult {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for ProposalResult {
        #[inline]
        fn eq(&self, other: &ProposalResult) -> bool {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            let __arg1_discr = ::core::intrinsics::discriminant_value(other);
            __self_discr == __arg1_discr
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Eq for ProposalResult {
        #[inline]
        #[doc(hidden)]
        #[coverage(off)]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    pub struct ProposalDetail {
        pub id: u64,
        pub description: String,
        pub external_link: Option<String>,
        pub metadata: ProposalMetadata,
        pub created_at: u64,
        pub accepts: u64,
        pub rejects: u64,
        pub abstains: u64,
        pub voting_powers: u64,
        pub adopted_comment_id: Option<u64>,
    }
    impl ::candid::types::CandidType for ProposalDetail {
        fn _ty() -> ::candid::types::Type {
            ::candid::types::TypeInner::Record(
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named("id".to_string()).into(),
                                ty: <u64 as ::candid::types::CandidType>::ty(),
                            },
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named(
                                        "voting_powers".to_string(),
                                    )
                                    .into(),
                                ty: <u64 as ::candid::types::CandidType>::ty(),
                            },
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named(
                                        "external_link".to_string(),
                                    )
                                    .into(),
                                ty: <Option<String> as ::candid::types::CandidType>::ty(),
                            },
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named("rejects".to_string())
                                    .into(),
                                ty: <u64 as ::candid::types::CandidType>::ty(),
                            },
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named("metadata".to_string())
                                    .into(),
                                ty: <ProposalMetadata as ::candid::types::CandidType>::ty(),
                            },
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named("description".to_string())
                                    .into(),
                                ty: <String as ::candid::types::CandidType>::ty(),
                            },
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named("created_at".to_string())
                                    .into(),
                                ty: <u64 as ::candid::types::CandidType>::ty(),
                            },
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named("accepts".to_string())
                                    .into(),
                                ty: <u64 as ::candid::types::CandidType>::ty(),
                            },
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named("abstains".to_string())
                                    .into(),
                                ty: <u64 as ::candid::types::CandidType>::ty(),
                            },
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named(
                                        "adopted_comment_id".to_string(),
                                    )
                                    .into(),
                                ty: <Option<u64> as ::candid::types::CandidType>::ty(),
                            },
                        ]),
                    ),
                )
                .into()
        }
        fn id() -> ::candid::types::TypeId {
            ::candid::types::TypeId::of::<ProposalDetail>()
        }
        fn idl_serialize<__S>(
            &self,
            __serializer: __S,
        ) -> ::std::result::Result<(), __S::Error>
        where
            __S: ::candid::types::Serializer,
        {
            let mut ser = __serializer.serialize_struct()?;
            ::candid::types::Compound::serialize_element(&mut ser, &self.id)?;
            ::candid::types::Compound::serialize_element(&mut ser, &self.voting_powers)?;
            ::candid::types::Compound::serialize_element(&mut ser, &self.external_link)?;
            ::candid::types::Compound::serialize_element(&mut ser, &self.rejects)?;
            ::candid::types::Compound::serialize_element(&mut ser, &self.metadata)?;
            ::candid::types::Compound::serialize_element(&mut ser, &self.description)?;
            ::candid::types::Compound::serialize_element(&mut ser, &self.created_at)?;
            ::candid::types::Compound::serialize_element(&mut ser, &self.accepts)?;
            ::candid::types::Compound::serialize_element(&mut ser, &self.abstains)?;
            ::candid::types::Compound::serialize_element(
                &mut ser,
                &self.adopted_comment_id,
            )?;
            Ok(())
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for ProposalDetail {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let names: &'static _ = &[
                "id",
                "description",
                "external_link",
                "metadata",
                "created_at",
                "accepts",
                "rejects",
                "abstains",
                "voting_powers",
                "adopted_comment_id",
            ];
            let values: &[&dyn ::core::fmt::Debug] = &[
                &self.id,
                &self.description,
                &self.external_link,
                &self.metadata,
                &self.created_at,
                &self.accepts,
                &self.rejects,
                &self.abstains,
                &self.voting_powers,
                &&self.adopted_comment_id,
            ];
            ::core::fmt::Formatter::debug_struct_fields_finish(
                f,
                "ProposalDetail",
                names,
                values,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for ProposalDetail {
        #[inline]
        fn clone(&self) -> ProposalDetail {
            ProposalDetail {
                id: ::core::clone::Clone::clone(&self.id),
                description: ::core::clone::Clone::clone(&self.description),
                external_link: ::core::clone::Clone::clone(&self.external_link),
                metadata: ::core::clone::Clone::clone(&self.metadata),
                created_at: ::core::clone::Clone::clone(&self.created_at),
                accepts: ::core::clone::Clone::clone(&self.accepts),
                rejects: ::core::clone::Clone::clone(&self.rejects),
                abstains: ::core::clone::Clone::clone(&self.abstains),
                voting_powers: ::core::clone::Clone::clone(&self.voting_powers),
                adopted_comment_id: ::core::clone::Clone::clone(&self.adopted_comment_id),
            }
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for ProposalDetail {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "ProposalDetail",
                    false as usize + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "id",
                    &self.id,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "description",
                    &self.description,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "external_link",
                    &self.external_link,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "metadata",
                    &self.metadata,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "created_at",
                    &self.created_at,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "accepts",
                    &self.accepts,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "rejects",
                    &self.rejects,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "abstains",
                    &self.abstains,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "voting_powers",
                    &self.voting_powers,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "adopted_comment_id",
                    &self.adopted_comment_id,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for ProposalDetail {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __field4,
                    __field5,
                    __field6,
                    __field7,
                    __field8,
                    __field9,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            4u64 => _serde::__private::Ok(__Field::__field4),
                            5u64 => _serde::__private::Ok(__Field::__field5),
                            6u64 => _serde::__private::Ok(__Field::__field6),
                            7u64 => _serde::__private::Ok(__Field::__field7),
                            8u64 => _serde::__private::Ok(__Field::__field8),
                            9u64 => _serde::__private::Ok(__Field::__field9),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "id" => _serde::__private::Ok(__Field::__field0),
                            "description" => _serde::__private::Ok(__Field::__field1),
                            "external_link" => _serde::__private::Ok(__Field::__field2),
                            "metadata" => _serde::__private::Ok(__Field::__field3),
                            "created_at" => _serde::__private::Ok(__Field::__field4),
                            "accepts" => _serde::__private::Ok(__Field::__field5),
                            "rejects" => _serde::__private::Ok(__Field::__field6),
                            "abstains" => _serde::__private::Ok(__Field::__field7),
                            "voting_powers" => _serde::__private::Ok(__Field::__field8),
                            "adopted_comment_id" => {
                                _serde::__private::Ok(__Field::__field9)
                            }
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"id" => _serde::__private::Ok(__Field::__field0),
                            b"description" => _serde::__private::Ok(__Field::__field1),
                            b"external_link" => _serde::__private::Ok(__Field::__field2),
                            b"metadata" => _serde::__private::Ok(__Field::__field3),
                            b"created_at" => _serde::__private::Ok(__Field::__field4),
                            b"accepts" => _serde::__private::Ok(__Field::__field5),
                            b"rejects" => _serde::__private::Ok(__Field::__field6),
                            b"abstains" => _serde::__private::Ok(__Field::__field7),
                            b"voting_powers" => _serde::__private::Ok(__Field::__field8),
                            b"adopted_comment_id" => {
                                _serde::__private::Ok(__Field::__field9)
                            }
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<ProposalDetail>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = ProposalDetail;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct ProposalDetail",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            u64,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct ProposalDetail with 10 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct ProposalDetail with 10 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match _serde::de::SeqAccess::next_element::<
                            Option<String>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct ProposalDetail with 10 elements",
                                    ),
                                );
                            }
                        };
                        let __field3 = match _serde::de::SeqAccess::next_element::<
                            ProposalMetadata,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        3usize,
                                        &"struct ProposalDetail with 10 elements",
                                    ),
                                );
                            }
                        };
                        let __field4 = match _serde::de::SeqAccess::next_element::<
                            u64,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        4usize,
                                        &"struct ProposalDetail with 10 elements",
                                    ),
                                );
                            }
                        };
                        let __field5 = match _serde::de::SeqAccess::next_element::<
                            u64,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        5usize,
                                        &"struct ProposalDetail with 10 elements",
                                    ),
                                );
                            }
                        };
                        let __field6 = match _serde::de::SeqAccess::next_element::<
                            u64,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        6usize,
                                        &"struct ProposalDetail with 10 elements",
                                    ),
                                );
                            }
                        };
                        let __field7 = match _serde::de::SeqAccess::next_element::<
                            u64,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        7usize,
                                        &"struct ProposalDetail with 10 elements",
                                    ),
                                );
                            }
                        };
                        let __field8 = match _serde::de::SeqAccess::next_element::<
                            u64,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        8usize,
                                        &"struct ProposalDetail with 10 elements",
                                    ),
                                );
                            }
                        };
                        let __field9 = match _serde::de::SeqAccess::next_element::<
                            Option<u64>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        9usize,
                                        &"struct ProposalDetail with 10 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(ProposalDetail {
                            id: __field0,
                            description: __field1,
                            external_link: __field2,
                            metadata: __field3,
                            created_at: __field4,
                            accepts: __field5,
                            rejects: __field6,
                            abstains: __field7,
                            voting_powers: __field8,
                            adopted_comment_id: __field9,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<u64> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<Option<String>> = _serde::__private::None;
                        let mut __field3: _serde::__private::Option<ProposalMetadata> = _serde::__private::None;
                        let mut __field4: _serde::__private::Option<u64> = _serde::__private::None;
                        let mut __field5: _serde::__private::Option<u64> = _serde::__private::None;
                        let mut __field6: _serde::__private::Option<u64> = _serde::__private::None;
                        let mut __field7: _serde::__private::Option<u64> = _serde::__private::None;
                        let mut __field8: _serde::__private::Option<u64> = _serde::__private::None;
                        let mut __field9: _serde::__private::Option<Option<u64>> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("id"),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<u64>(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "description",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "external_link",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<String>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field3 => {
                                    if _serde::__private::Option::is_some(&__field3) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "metadata",
                                            ),
                                        );
                                    }
                                    __field3 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            ProposalMetadata,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field4 => {
                                    if _serde::__private::Option::is_some(&__field4) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "created_at",
                                            ),
                                        );
                                    }
                                    __field4 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<u64>(&mut __map)?,
                                    );
                                }
                                __Field::__field5 => {
                                    if _serde::__private::Option::is_some(&__field5) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "accepts",
                                            ),
                                        );
                                    }
                                    __field5 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<u64>(&mut __map)?,
                                    );
                                }
                                __Field::__field6 => {
                                    if _serde::__private::Option::is_some(&__field6) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "rejects",
                                            ),
                                        );
                                    }
                                    __field6 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<u64>(&mut __map)?,
                                    );
                                }
                                __Field::__field7 => {
                                    if _serde::__private::Option::is_some(&__field7) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "abstains",
                                            ),
                                        );
                                    }
                                    __field7 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<u64>(&mut __map)?,
                                    );
                                }
                                __Field::__field8 => {
                                    if _serde::__private::Option::is_some(&__field8) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "voting_powers",
                                            ),
                                        );
                                    }
                                    __field8 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<u64>(&mut __map)?,
                                    );
                                }
                                __Field::__field9 => {
                                    if _serde::__private::Option::is_some(&__field9) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "adopted_comment_id",
                                            ),
                                        );
                                    }
                                    __field9 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<u64>,
                                        >(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("id")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("description")?
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("external_link")?
                            }
                        };
                        let __field3 = match __field3 {
                            _serde::__private::Some(__field3) => __field3,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("metadata")?
                            }
                        };
                        let __field4 = match __field4 {
                            _serde::__private::Some(__field4) => __field4,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("created_at")?
                            }
                        };
                        let __field5 = match __field5 {
                            _serde::__private::Some(__field5) => __field5,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("accepts")?
                            }
                        };
                        let __field6 = match __field6 {
                            _serde::__private::Some(__field6) => __field6,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("rejects")?
                            }
                        };
                        let __field7 = match __field7 {
                            _serde::__private::Some(__field7) => __field7,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("abstains")?
                            }
                        };
                        let __field8 = match __field8 {
                            _serde::__private::Some(__field8) => __field8,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("voting_powers")?
                            }
                        };
                        let __field9 = match __field9 {
                            _serde::__private::Some(__field9) => __field9,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("adopted_comment_id")?
                            }
                        };
                        _serde::__private::Ok(ProposalDetail {
                            id: __field0,
                            description: __field1,
                            external_link: __field2,
                            metadata: __field3,
                            created_at: __field4,
                            accepts: __field5,
                            rejects: __field6,
                            abstains: __field7,
                            voting_powers: __field8,
                            adopted_comment_id: __field9,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "id",
                    "description",
                    "external_link",
                    "metadata",
                    "created_at",
                    "accepts",
                    "rejects",
                    "abstains",
                    "voting_powers",
                    "adopted_comment_id",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "ProposalDetail",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<ProposalDetail>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    pub enum ProposalMetadata {
        #[serde(rename = "event_proposal")]
        EventProposal(EventProposalMetadata),
        #[serde(rename = "discussion_proposal")]
        DiscussionProposal(DiscussionProposalMetadata),
    }
    impl ::candid::types::CandidType for ProposalMetadata {
        fn _ty() -> ::candid::types::Type {
            ::candid::types::TypeInner::Variant(
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named(
                                        "event_proposal".to_owned(),
                                    )
                                    .into(),
                                ty: <EventProposalMetadata as ::candid::types::CandidType>::ty(),
                            },
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named(
                                        "discussion_proposal".to_owned(),
                                    )
                                    .into(),
                                ty: <DiscussionProposalMetadata as ::candid::types::CandidType>::ty(),
                            },
                        ]),
                    ),
                )
                .into()
        }
        fn id() -> ::candid::types::TypeId {
            ::candid::types::TypeId::of::<ProposalMetadata>()
        }
        fn idl_serialize<__S>(
            &self,
            __serializer: __S,
        ) -> ::std::result::Result<(), __S::Error>
        where
            __S: ::candid::types::Serializer,
        {
            match *self {
                ProposalMetadata::EventProposal(ref __field0) => {
                    let mut ser = __serializer.serialize_variant(0u64)?;
                    ::candid::types::Compound::serialize_element(&mut ser, __field0)?;
                }
                ProposalMetadata::DiscussionProposal(ref __field0) => {
                    let mut ser = __serializer.serialize_variant(1u64)?;
                    ::candid::types::Compound::serialize_element(&mut ser, __field0)?;
                }
            };
            Ok(())
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for ProposalMetadata {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                ProposalMetadata::EventProposal(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "EventProposal",
                        &__self_0,
                    )
                }
                ProposalMetadata::DiscussionProposal(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "DiscussionProposal",
                        &__self_0,
                    )
                }
            }
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for ProposalMetadata {
        #[inline]
        fn clone(&self) -> ProposalMetadata {
            match self {
                ProposalMetadata::EventProposal(__self_0) => {
                    ProposalMetadata::EventProposal(
                        ::core::clone::Clone::clone(__self_0),
                    )
                }
                ProposalMetadata::DiscussionProposal(__self_0) => {
                    ProposalMetadata::DiscussionProposal(
                        ::core::clone::Clone::clone(__self_0),
                    )
                }
            }
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for ProposalMetadata {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    ProposalMetadata::EventProposal(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "ProposalMetadata",
                            0u32,
                            "event_proposal",
                            __field0,
                        )
                    }
                    ProposalMetadata::DiscussionProposal(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "ProposalMetadata",
                            1u32,
                            "discussion_proposal",
                            __field0,
                        )
                    }
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for ProposalMetadata {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "variant identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::invalid_value(
                                        _serde::de::Unexpected::Unsigned(__value),
                                        &"variant index 0 <= i < 2",
                                    ),
                                )
                            }
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "event_proposal" => _serde::__private::Ok(__Field::__field0),
                            "discussion_proposal" => {
                                _serde::__private::Ok(__Field::__field1)
                            }
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"event_proposal" => _serde::__private::Ok(__Field::__field0),
                            b"discussion_proposal" => {
                                _serde::__private::Ok(__Field::__field1)
                            }
                            _ => {
                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<ProposalMetadata>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = ProposalMetadata;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "enum ProposalMetadata",
                        )
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match _serde::de::EnumAccess::variant(__data)? {
                            (__Field::__field0, __variant) => {
                                _serde::__private::Result::map(
                                    _serde::de::VariantAccess::newtype_variant::<
                                        EventProposalMetadata,
                                    >(__variant),
                                    ProposalMetadata::EventProposal,
                                )
                            }
                            (__Field::__field1, __variant) => {
                                _serde::__private::Result::map(
                                    _serde::de::VariantAccess::newtype_variant::<
                                        DiscussionProposalMetadata,
                                    >(__variant),
                                    ProposalMetadata::DiscussionProposal,
                                )
                            }
                        }
                    }
                }
                #[doc(hidden)]
                const VARIANTS: &'static [&'static str] = &[
                    "event_proposal",
                    "discussion_proposal",
                ];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "ProposalMetadata",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<ProposalMetadata>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    pub struct EventProposalMetadata {
        pub name: String,
        pub start_date: u64,
        pub end_date: u64,
    }
    impl ::candid::types::CandidType for EventProposalMetadata {
        fn _ty() -> ::candid::types::Type {
            ::candid::types::TypeInner::Record(
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named("name".to_string())
                                    .into(),
                                ty: <String as ::candid::types::CandidType>::ty(),
                            },
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named("end_date".to_string())
                                    .into(),
                                ty: <u64 as ::candid::types::CandidType>::ty(),
                            },
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named("start_date".to_string())
                                    .into(),
                                ty: <u64 as ::candid::types::CandidType>::ty(),
                            },
                        ]),
                    ),
                )
                .into()
        }
        fn id() -> ::candid::types::TypeId {
            ::candid::types::TypeId::of::<EventProposalMetadata>()
        }
        fn idl_serialize<__S>(
            &self,
            __serializer: __S,
        ) -> ::std::result::Result<(), __S::Error>
        where
            __S: ::candid::types::Serializer,
        {
            let mut ser = __serializer.serialize_struct()?;
            ::candid::types::Compound::serialize_element(&mut ser, &self.name)?;
            ::candid::types::Compound::serialize_element(&mut ser, &self.end_date)?;
            ::candid::types::Compound::serialize_element(&mut ser, &self.start_date)?;
            Ok(())
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for EventProposalMetadata {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "EventProposalMetadata",
                "name",
                &self.name,
                "start_date",
                &self.start_date,
                "end_date",
                &&self.end_date,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for EventProposalMetadata {
        #[inline]
        fn clone(&self) -> EventProposalMetadata {
            EventProposalMetadata {
                name: ::core::clone::Clone::clone(&self.name),
                start_date: ::core::clone::Clone::clone(&self.start_date),
                end_date: ::core::clone::Clone::clone(&self.end_date),
            }
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for EventProposalMetadata {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "EventProposalMetadata",
                    false as usize + 1 + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "name",
                    &self.name,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "start_date",
                    &self.start_date,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "end_date",
                    &self.end_date,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for EventProposalMetadata {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "name" => _serde::__private::Ok(__Field::__field0),
                            "start_date" => _serde::__private::Ok(__Field::__field1),
                            "end_date" => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"name" => _serde::__private::Ok(__Field::__field0),
                            b"start_date" => _serde::__private::Ok(__Field::__field1),
                            b"end_date" => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<EventProposalMetadata>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = EventProposalMetadata;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct EventProposalMetadata",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct EventProposalMetadata with 3 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            u64,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct EventProposalMetadata with 3 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match _serde::de::SeqAccess::next_element::<
                            u64,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct EventProposalMetadata with 3 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(EventProposalMetadata {
                            name: __field0,
                            start_date: __field1,
                            end_date: __field2,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<u64> = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<u64> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("name"),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "start_date",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<u64>(&mut __map)?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "end_date",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<u64>(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("name")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("start_date")?
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("end_date")?
                            }
                        };
                        _serde::__private::Ok(EventProposalMetadata {
                            name: __field0,
                            start_date: __field1,
                            end_date: __field2,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "name",
                    "start_date",
                    "end_date",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "EventProposalMetadata",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<EventProposalMetadata>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    pub struct DiscussionProposalMetadata {
        pub purpose: String,
        pub budget: Option<String>,
        pub reward: Option<Reward>,
    }
    impl ::candid::types::CandidType for DiscussionProposalMetadata {
        fn _ty() -> ::candid::types::Type {
            ::candid::types::TypeInner::Record(
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named("reward".to_string())
                                    .into(),
                                ty: <Option<Reward> as ::candid::types::CandidType>::ty(),
                            },
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named("budget".to_string())
                                    .into(),
                                ty: <Option<String> as ::candid::types::CandidType>::ty(),
                            },
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named("purpose".to_string())
                                    .into(),
                                ty: <String as ::candid::types::CandidType>::ty(),
                            },
                        ]),
                    ),
                )
                .into()
        }
        fn id() -> ::candid::types::TypeId {
            ::candid::types::TypeId::of::<DiscussionProposalMetadata>()
        }
        fn idl_serialize<__S>(
            &self,
            __serializer: __S,
        ) -> ::std::result::Result<(), __S::Error>
        where
            __S: ::candid::types::Serializer,
        {
            let mut ser = __serializer.serialize_struct()?;
            ::candid::types::Compound::serialize_element(&mut ser, &self.reward)?;
            ::candid::types::Compound::serialize_element(&mut ser, &self.budget)?;
            ::candid::types::Compound::serialize_element(&mut ser, &self.purpose)?;
            Ok(())
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for DiscussionProposalMetadata {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "DiscussionProposalMetadata",
                "purpose",
                &self.purpose,
                "budget",
                &self.budget,
                "reward",
                &&self.reward,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for DiscussionProposalMetadata {
        #[inline]
        fn clone(&self) -> DiscussionProposalMetadata {
            DiscussionProposalMetadata {
                purpose: ::core::clone::Clone::clone(&self.purpose),
                budget: ::core::clone::Clone::clone(&self.budget),
                reward: ::core::clone::Clone::clone(&self.reward),
            }
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for DiscussionProposalMetadata {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "DiscussionProposalMetadata",
                    false as usize + 1 + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "purpose",
                    &self.purpose,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "budget",
                    &self.budget,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "reward",
                    &self.reward,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for DiscussionProposalMetadata {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "purpose" => _serde::__private::Ok(__Field::__field0),
                            "budget" => _serde::__private::Ok(__Field::__field1),
                            "reward" => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"purpose" => _serde::__private::Ok(__Field::__field0),
                            b"budget" => _serde::__private::Ok(__Field::__field1),
                            b"reward" => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<DiscussionProposalMetadata>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = DiscussionProposalMetadata;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct DiscussionProposalMetadata",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct DiscussionProposalMetadata with 3 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            Option<String>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct DiscussionProposalMetadata with 3 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match _serde::de::SeqAccess::next_element::<
                            Option<Reward>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct DiscussionProposalMetadata with 3 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(DiscussionProposalMetadata {
                            purpose: __field0,
                            budget: __field1,
                            reward: __field2,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<Option<String>> = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<Option<Reward>> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "purpose",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("budget"),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<String>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("reward"),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<Reward>,
                                        >(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("purpose")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("budget")?
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("reward")?
                            }
                        };
                        _serde::__private::Ok(DiscussionProposalMetadata {
                            purpose: __field0,
                            budget: __field1,
                            reward: __field2,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &["purpose", "budget", "reward"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "DiscussionProposalMetadata",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<
                            DiscussionProposalMetadata,
                        >,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    pub enum Reward {
        Goods(Goods),
        Experience(Experience),
    }
    impl ::candid::types::CandidType for Reward {
        fn _ty() -> ::candid::types::Type {
            ::candid::types::TypeInner::Variant(
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named("Goods".to_owned())
                                    .into(),
                                ty: <Goods as ::candid::types::CandidType>::ty(),
                            },
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named("Experience".to_owned())
                                    .into(),
                                ty: <Experience as ::candid::types::CandidType>::ty(),
                            },
                        ]),
                    ),
                )
                .into()
        }
        fn id() -> ::candid::types::TypeId {
            ::candid::types::TypeId::of::<Reward>()
        }
        fn idl_serialize<__S>(
            &self,
            __serializer: __S,
        ) -> ::std::result::Result<(), __S::Error>
        where
            __S: ::candid::types::Serializer,
        {
            match *self {
                Reward::Goods(ref __field0) => {
                    let mut ser = __serializer.serialize_variant(0u64)?;
                    ::candid::types::Compound::serialize_element(&mut ser, __field0)?;
                }
                Reward::Experience(ref __field0) => {
                    let mut ser = __serializer.serialize_variant(1u64)?;
                    ::candid::types::Compound::serialize_element(&mut ser, __field0)?;
                }
            };
            Ok(())
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Reward {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                Reward::Goods(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Goods",
                        &__self_0,
                    )
                }
                Reward::Experience(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Experience",
                        &__self_0,
                    )
                }
            }
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Reward {
        #[inline]
        fn clone(&self) -> Reward {
            match self {
                Reward::Goods(__self_0) => {
                    Reward::Goods(::core::clone::Clone::clone(__self_0))
                }
                Reward::Experience(__self_0) => {
                    Reward::Experience(::core::clone::Clone::clone(__self_0))
                }
            }
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for Reward {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    Reward::Goods(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "Reward",
                            0u32,
                            "Goods",
                            __field0,
                        )
                    }
                    Reward::Experience(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "Reward",
                            1u32,
                            "Experience",
                            __field0,
                        )
                    }
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for Reward {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "variant identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::invalid_value(
                                        _serde::de::Unexpected::Unsigned(__value),
                                        &"variant index 0 <= i < 2",
                                    ),
                                )
                            }
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "Goods" => _serde::__private::Ok(__Field::__field0),
                            "Experience" => _serde::__private::Ok(__Field::__field1),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"Goods" => _serde::__private::Ok(__Field::__field0),
                            b"Experience" => _serde::__private::Ok(__Field::__field1),
                            _ => {
                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<Reward>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = Reward;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "enum Reward",
                        )
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match _serde::de::EnumAccess::variant(__data)? {
                            (__Field::__field0, __variant) => {
                                _serde::__private::Result::map(
                                    _serde::de::VariantAccess::newtype_variant::<
                                        Goods,
                                    >(__variant),
                                    Reward::Goods,
                                )
                            }
                            (__Field::__field1, __variant) => {
                                _serde::__private::Result::map(
                                    _serde::de::VariantAccess::newtype_variant::<
                                        Experience,
                                    >(__variant),
                                    Reward::Experience,
                                )
                            }
                        }
                    }
                }
                #[doc(hidden)]
                const VARIANTS: &'static [&'static str] = &["Goods", "Experience"];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "Reward",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<Reward>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    pub struct Goods {
        pub name: String,
    }
    impl ::candid::types::CandidType for Goods {
        fn _ty() -> ::candid::types::Type {
            ::candid::types::TypeInner::Record(
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named("name".to_string())
                                    .into(),
                                ty: <String as ::candid::types::CandidType>::ty(),
                            },
                        ]),
                    ),
                )
                .into()
        }
        fn id() -> ::candid::types::TypeId {
            ::candid::types::TypeId::of::<Goods>()
        }
        fn idl_serialize<__S>(
            &self,
            __serializer: __S,
        ) -> ::std::result::Result<(), __S::Error>
        where
            __S: ::candid::types::Serializer,
        {
            let mut ser = __serializer.serialize_struct()?;
            ::candid::types::Compound::serialize_element(&mut ser, &self.name)?;
            Ok(())
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Goods {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field1_finish(
                f,
                "Goods",
                "name",
                &&self.name,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Goods {
        #[inline]
        fn clone(&self) -> Goods {
            Goods {
                name: ::core::clone::Clone::clone(&self.name),
            }
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for Goods {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "Goods",
                    false as usize + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "name",
                    &self.name,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for Goods {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "name" => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"name" => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<Goods>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = Goods;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct Goods",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct Goods with 1 element",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(Goods { name: __field0 })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("name"),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("name")?
                            }
                        };
                        _serde::__private::Ok(Goods { name: __field0 })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &["name"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "Goods",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<Goods>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    pub struct Experience {
        pub exp: u32,
    }
    impl ::candid::types::CandidType for Experience {
        fn _ty() -> ::candid::types::Type {
            ::candid::types::TypeInner::Record(
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named("exp".to_string()).into(),
                                ty: <u32 as ::candid::types::CandidType>::ty(),
                            },
                        ]),
                    ),
                )
                .into()
        }
        fn id() -> ::candid::types::TypeId {
            ::candid::types::TypeId::of::<Experience>()
        }
        fn idl_serialize<__S>(
            &self,
            __serializer: __S,
        ) -> ::std::result::Result<(), __S::Error>
        where
            __S: ::candid::types::Serializer,
        {
            let mut ser = __serializer.serialize_struct()?;
            ::candid::types::Compound::serialize_element(&mut ser, &self.exp)?;
            Ok(())
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Experience {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field1_finish(
                f,
                "Experience",
                "exp",
                &&self.exp,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Experience {
        #[inline]
        fn clone(&self) -> Experience {
            Experience {
                exp: ::core::clone::Clone::clone(&self.exp),
            }
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for Experience {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "Experience",
                    false as usize + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "exp",
                    &self.exp,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for Experience {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "exp" => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"exp" => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<Experience>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = Experience;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct Experience",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            u32,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct Experience with 1 element",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(Experience { exp: __field0 })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<u32> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("exp"),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<u32>(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("exp")?
                            }
                        };
                        _serde::__private::Ok(Experience { exp: __field0 })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &["exp"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "Experience",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<Experience>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    pub enum Voting {
        #[serde(rename = "accept")]
        Accept,
        #[serde(rename = "reject")]
        Reject,
        #[serde(rename = "abstain")]
        Abstain,
    }
    impl ::candid::types::CandidType for Voting {
        fn _ty() -> ::candid::types::Type {
            ::candid::types::TypeInner::Variant(
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named("reject".to_owned())
                                    .into(),
                                ty: ::candid::types::TypeInner::Null.into(),
                            },
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named("accept".to_owned())
                                    .into(),
                                ty: ::candid::types::TypeInner::Null.into(),
                            },
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named("abstain".to_owned())
                                    .into(),
                                ty: ::candid::types::TypeInner::Null.into(),
                            },
                        ]),
                    ),
                )
                .into()
        }
        fn id() -> ::candid::types::TypeId {
            ::candid::types::TypeId::of::<Voting>()
        }
        fn idl_serialize<__S>(
            &self,
            __serializer: __S,
        ) -> ::std::result::Result<(), __S::Error>
        where
            __S: ::candid::types::Serializer,
        {
            match *self {
                Voting::Reject => {
                    let mut ser = __serializer.serialize_variant(0u64)?;
                }
                Voting::Accept => {
                    let mut ser = __serializer.serialize_variant(1u64)?;
                }
                Voting::Abstain => {
                    let mut ser = __serializer.serialize_variant(2u64)?;
                }
            };
            Ok(())
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Voting {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(
                f,
                match self {
                    Voting::Accept => "Accept",
                    Voting::Reject => "Reject",
                    Voting::Abstain => "Abstain",
                },
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Voting {
        #[inline]
        fn clone(&self) -> Voting {
            match self {
                Voting::Accept => Voting::Accept,
                Voting::Reject => Voting::Reject,
                Voting::Abstain => Voting::Abstain,
            }
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for Voting {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    Voting::Accept => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "Voting",
                            0u32,
                            "accept",
                        )
                    }
                    Voting::Reject => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "Voting",
                            1u32,
                            "reject",
                        )
                    }
                    Voting::Abstain => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "Voting",
                            2u32,
                            "abstain",
                        )
                    }
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for Voting {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "variant identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::invalid_value(
                                        _serde::de::Unexpected::Unsigned(__value),
                                        &"variant index 0 <= i < 3",
                                    ),
                                )
                            }
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "accept" => _serde::__private::Ok(__Field::__field0),
                            "reject" => _serde::__private::Ok(__Field::__field1),
                            "abstain" => _serde::__private::Ok(__Field::__field2),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"accept" => _serde::__private::Ok(__Field::__field0),
                            b"reject" => _serde::__private::Ok(__Field::__field1),
                            b"abstain" => _serde::__private::Ok(__Field::__field2),
                            _ => {
                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<Voting>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = Voting;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "enum Voting",
                        )
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match _serde::de::EnumAccess::variant(__data)? {
                            (__Field::__field0, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(Voting::Accept)
                            }
                            (__Field::__field1, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(Voting::Reject)
                            }
                            (__Field::__field2, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(Voting::Abstain)
                            }
                        }
                    }
                }
                #[doc(hidden)]
                const VARIANTS: &'static [&'static str] = &[
                    "accept",
                    "reject",
                    "abstain",
                ];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "Voting",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<Voting>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Voting {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Voting {
        #[inline]
        fn eq(&self, other: &Voting) -> bool {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            let __arg1_discr = ::core::intrinsics::discriminant_value(other);
            __self_discr == __arg1_discr
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Eq for Voting {
        #[inline]
        #[doc(hidden)]
        #[coverage(off)]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    pub struct CommentData {
        pub id: u64,
        pub proposal_id: u64,
        pub parent_id: Option<u64>,
        pub commenter: Principal,
        pub nft_id: u64,
        pub created_at: u64,
        pub contents: String,
        pub total_likes: u64,
        pub total_replies: u64,
        pub user_liked: bool,
    }
    impl ::candid::types::CandidType for CommentData {
        fn _ty() -> ::candid::types::Type {
            ::candid::types::TypeInner::Record(
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named("id".to_string()).into(),
                                ty: <u64 as ::candid::types::CandidType>::ty(),
                            },
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named("total_likes".to_string())
                                    .into(),
                                ty: <u64 as ::candid::types::CandidType>::ty(),
                            },
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named("nft_id".to_string())
                                    .into(),
                                ty: <u64 as ::candid::types::CandidType>::ty(),
                            },
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named("commenter".to_string())
                                    .into(),
                                ty: <Principal as ::candid::types::CandidType>::ty(),
                            },
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named("user_liked".to_string())
                                    .into(),
                                ty: <bool as ::candid::types::CandidType>::ty(),
                            },
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named("contents".to_string())
                                    .into(),
                                ty: <String as ::candid::types::CandidType>::ty(),
                            },
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named(
                                        "total_replies".to_string(),
                                    )
                                    .into(),
                                ty: <u64 as ::candid::types::CandidType>::ty(),
                            },
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named("created_at".to_string())
                                    .into(),
                                ty: <u64 as ::candid::types::CandidType>::ty(),
                            },
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named("parent_id".to_string())
                                    .into(),
                                ty: <Option<u64> as ::candid::types::CandidType>::ty(),
                            },
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named("proposal_id".to_string())
                                    .into(),
                                ty: <u64 as ::candid::types::CandidType>::ty(),
                            },
                        ]),
                    ),
                )
                .into()
        }
        fn id() -> ::candid::types::TypeId {
            ::candid::types::TypeId::of::<CommentData>()
        }
        fn idl_serialize<__S>(
            &self,
            __serializer: __S,
        ) -> ::std::result::Result<(), __S::Error>
        where
            __S: ::candid::types::Serializer,
        {
            let mut ser = __serializer.serialize_struct()?;
            ::candid::types::Compound::serialize_element(&mut ser, &self.id)?;
            ::candid::types::Compound::serialize_element(&mut ser, &self.total_likes)?;
            ::candid::types::Compound::serialize_element(&mut ser, &self.nft_id)?;
            ::candid::types::Compound::serialize_element(&mut ser, &self.commenter)?;
            ::candid::types::Compound::serialize_element(&mut ser, &self.user_liked)?;
            ::candid::types::Compound::serialize_element(&mut ser, &self.contents)?;
            ::candid::types::Compound::serialize_element(&mut ser, &self.total_replies)?;
            ::candid::types::Compound::serialize_element(&mut ser, &self.created_at)?;
            ::candid::types::Compound::serialize_element(&mut ser, &self.parent_id)?;
            ::candid::types::Compound::serialize_element(&mut ser, &self.proposal_id)?;
            Ok(())
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for CommentData {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let names: &'static _ = &[
                "id",
                "proposal_id",
                "parent_id",
                "commenter",
                "nft_id",
                "created_at",
                "contents",
                "total_likes",
                "total_replies",
                "user_liked",
            ];
            let values: &[&dyn ::core::fmt::Debug] = &[
                &self.id,
                &self.proposal_id,
                &self.parent_id,
                &self.commenter,
                &self.nft_id,
                &self.created_at,
                &self.contents,
                &self.total_likes,
                &self.total_replies,
                &&self.user_liked,
            ];
            ::core::fmt::Formatter::debug_struct_fields_finish(
                f,
                "CommentData",
                names,
                values,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for CommentData {
        #[inline]
        fn clone(&self) -> CommentData {
            CommentData {
                id: ::core::clone::Clone::clone(&self.id),
                proposal_id: ::core::clone::Clone::clone(&self.proposal_id),
                parent_id: ::core::clone::Clone::clone(&self.parent_id),
                commenter: ::core::clone::Clone::clone(&self.commenter),
                nft_id: ::core::clone::Clone::clone(&self.nft_id),
                created_at: ::core::clone::Clone::clone(&self.created_at),
                contents: ::core::clone::Clone::clone(&self.contents),
                total_likes: ::core::clone::Clone::clone(&self.total_likes),
                total_replies: ::core::clone::Clone::clone(&self.total_replies),
                user_liked: ::core::clone::Clone::clone(&self.user_liked),
            }
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for CommentData {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "CommentData",
                    false as usize + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "id",
                    &self.id,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "proposal_id",
                    &self.proposal_id,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "parent_id",
                    &self.parent_id,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "commenter",
                    &self.commenter,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "nft_id",
                    &self.nft_id,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "created_at",
                    &self.created_at,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "contents",
                    &self.contents,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "total_likes",
                    &self.total_likes,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "total_replies",
                    &self.total_replies,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "user_liked",
                    &self.user_liked,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for CommentData {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __field4,
                    __field5,
                    __field6,
                    __field7,
                    __field8,
                    __field9,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            4u64 => _serde::__private::Ok(__Field::__field4),
                            5u64 => _serde::__private::Ok(__Field::__field5),
                            6u64 => _serde::__private::Ok(__Field::__field6),
                            7u64 => _serde::__private::Ok(__Field::__field7),
                            8u64 => _serde::__private::Ok(__Field::__field8),
                            9u64 => _serde::__private::Ok(__Field::__field9),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "id" => _serde::__private::Ok(__Field::__field0),
                            "proposal_id" => _serde::__private::Ok(__Field::__field1),
                            "parent_id" => _serde::__private::Ok(__Field::__field2),
                            "commenter" => _serde::__private::Ok(__Field::__field3),
                            "nft_id" => _serde::__private::Ok(__Field::__field4),
                            "created_at" => _serde::__private::Ok(__Field::__field5),
                            "contents" => _serde::__private::Ok(__Field::__field6),
                            "total_likes" => _serde::__private::Ok(__Field::__field7),
                            "total_replies" => _serde::__private::Ok(__Field::__field8),
                            "user_liked" => _serde::__private::Ok(__Field::__field9),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"id" => _serde::__private::Ok(__Field::__field0),
                            b"proposal_id" => _serde::__private::Ok(__Field::__field1),
                            b"parent_id" => _serde::__private::Ok(__Field::__field2),
                            b"commenter" => _serde::__private::Ok(__Field::__field3),
                            b"nft_id" => _serde::__private::Ok(__Field::__field4),
                            b"created_at" => _serde::__private::Ok(__Field::__field5),
                            b"contents" => _serde::__private::Ok(__Field::__field6),
                            b"total_likes" => _serde::__private::Ok(__Field::__field7),
                            b"total_replies" => _serde::__private::Ok(__Field::__field8),
                            b"user_liked" => _serde::__private::Ok(__Field::__field9),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<CommentData>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = CommentData;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct CommentData",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            u64,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct CommentData with 10 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            u64,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct CommentData with 10 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match _serde::de::SeqAccess::next_element::<
                            Option<u64>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct CommentData with 10 elements",
                                    ),
                                );
                            }
                        };
                        let __field3 = match _serde::de::SeqAccess::next_element::<
                            Principal,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        3usize,
                                        &"struct CommentData with 10 elements",
                                    ),
                                );
                            }
                        };
                        let __field4 = match _serde::de::SeqAccess::next_element::<
                            u64,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        4usize,
                                        &"struct CommentData with 10 elements",
                                    ),
                                );
                            }
                        };
                        let __field5 = match _serde::de::SeqAccess::next_element::<
                            u64,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        5usize,
                                        &"struct CommentData with 10 elements",
                                    ),
                                );
                            }
                        };
                        let __field6 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        6usize,
                                        &"struct CommentData with 10 elements",
                                    ),
                                );
                            }
                        };
                        let __field7 = match _serde::de::SeqAccess::next_element::<
                            u64,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        7usize,
                                        &"struct CommentData with 10 elements",
                                    ),
                                );
                            }
                        };
                        let __field8 = match _serde::de::SeqAccess::next_element::<
                            u64,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        8usize,
                                        &"struct CommentData with 10 elements",
                                    ),
                                );
                            }
                        };
                        let __field9 = match _serde::de::SeqAccess::next_element::<
                            bool,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        9usize,
                                        &"struct CommentData with 10 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(CommentData {
                            id: __field0,
                            proposal_id: __field1,
                            parent_id: __field2,
                            commenter: __field3,
                            nft_id: __field4,
                            created_at: __field5,
                            contents: __field6,
                            total_likes: __field7,
                            total_replies: __field8,
                            user_liked: __field9,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<u64> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<u64> = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<Option<u64>> = _serde::__private::None;
                        let mut __field3: _serde::__private::Option<Principal> = _serde::__private::None;
                        let mut __field4: _serde::__private::Option<u64> = _serde::__private::None;
                        let mut __field5: _serde::__private::Option<u64> = _serde::__private::None;
                        let mut __field6: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field7: _serde::__private::Option<u64> = _serde::__private::None;
                        let mut __field8: _serde::__private::Option<u64> = _serde::__private::None;
                        let mut __field9: _serde::__private::Option<bool> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("id"),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<u64>(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "proposal_id",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<u64>(&mut __map)?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "parent_id",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<u64>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field3 => {
                                    if _serde::__private::Option::is_some(&__field3) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "commenter",
                                            ),
                                        );
                                    }
                                    __field3 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<Principal>(&mut __map)?,
                                    );
                                }
                                __Field::__field4 => {
                                    if _serde::__private::Option::is_some(&__field4) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("nft_id"),
                                        );
                                    }
                                    __field4 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<u64>(&mut __map)?,
                                    );
                                }
                                __Field::__field5 => {
                                    if _serde::__private::Option::is_some(&__field5) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "created_at",
                                            ),
                                        );
                                    }
                                    __field5 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<u64>(&mut __map)?,
                                    );
                                }
                                __Field::__field6 => {
                                    if _serde::__private::Option::is_some(&__field6) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "contents",
                                            ),
                                        );
                                    }
                                    __field6 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field7 => {
                                    if _serde::__private::Option::is_some(&__field7) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "total_likes",
                                            ),
                                        );
                                    }
                                    __field7 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<u64>(&mut __map)?,
                                    );
                                }
                                __Field::__field8 => {
                                    if _serde::__private::Option::is_some(&__field8) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "total_replies",
                                            ),
                                        );
                                    }
                                    __field8 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<u64>(&mut __map)?,
                                    );
                                }
                                __Field::__field9 => {
                                    if _serde::__private::Option::is_some(&__field9) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "user_liked",
                                            ),
                                        );
                                    }
                                    __field9 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<bool>(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("id")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("proposal_id")?
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("parent_id")?
                            }
                        };
                        let __field3 = match __field3 {
                            _serde::__private::Some(__field3) => __field3,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("commenter")?
                            }
                        };
                        let __field4 = match __field4 {
                            _serde::__private::Some(__field4) => __field4,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("nft_id")?
                            }
                        };
                        let __field5 = match __field5 {
                            _serde::__private::Some(__field5) => __field5,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("created_at")?
                            }
                        };
                        let __field6 = match __field6 {
                            _serde::__private::Some(__field6) => __field6,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("contents")?
                            }
                        };
                        let __field7 = match __field7 {
                            _serde::__private::Some(__field7) => __field7,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("total_likes")?
                            }
                        };
                        let __field8 = match __field8 {
                            _serde::__private::Some(__field8) => __field8,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("total_replies")?
                            }
                        };
                        let __field9 = match __field9 {
                            _serde::__private::Some(__field9) => __field9,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("user_liked")?
                            }
                        };
                        _serde::__private::Ok(CommentData {
                            id: __field0,
                            proposal_id: __field1,
                            parent_id: __field2,
                            commenter: __field3,
                            nft_id: __field4,
                            created_at: __field5,
                            contents: __field6,
                            total_likes: __field7,
                            total_replies: __field8,
                            user_liked: __field9,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "id",
                    "proposal_id",
                    "parent_id",
                    "commenter",
                    "nft_id",
                    "created_at",
                    "contents",
                    "total_likes",
                    "total_replies",
                    "user_liked",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "CommentData",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<CommentData>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    pub struct LikeData {
        pub id: u64,
        pub comment_id: u64,
        pub user: Principal,
    }
    impl ::candid::types::CandidType for LikeData {
        fn _ty() -> ::candid::types::Type {
            ::candid::types::TypeInner::Record(
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named("id".to_string()).into(),
                                ty: <u64 as ::candid::types::CandidType>::ty(),
                            },
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named("user".to_string())
                                    .into(),
                                ty: <Principal as ::candid::types::CandidType>::ty(),
                            },
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named("comment_id".to_string())
                                    .into(),
                                ty: <u64 as ::candid::types::CandidType>::ty(),
                            },
                        ]),
                    ),
                )
                .into()
        }
        fn id() -> ::candid::types::TypeId {
            ::candid::types::TypeId::of::<LikeData>()
        }
        fn idl_serialize<__S>(
            &self,
            __serializer: __S,
        ) -> ::std::result::Result<(), __S::Error>
        where
            __S: ::candid::types::Serializer,
        {
            let mut ser = __serializer.serialize_struct()?;
            ::candid::types::Compound::serialize_element(&mut ser, &self.id)?;
            ::candid::types::Compound::serialize_element(&mut ser, &self.user)?;
            ::candid::types::Compound::serialize_element(&mut ser, &self.comment_id)?;
            Ok(())
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for LikeData {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "LikeData",
                "id",
                &self.id,
                "comment_id",
                &self.comment_id,
                "user",
                &&self.user,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for LikeData {
        #[inline]
        fn clone(&self) -> LikeData {
            LikeData {
                id: ::core::clone::Clone::clone(&self.id),
                comment_id: ::core::clone::Clone::clone(&self.comment_id),
                user: ::core::clone::Clone::clone(&self.user),
            }
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for LikeData {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "LikeData",
                    false as usize + 1 + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "id",
                    &self.id,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "comment_id",
                    &self.comment_id,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "user",
                    &self.user,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for LikeData {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "id" => _serde::__private::Ok(__Field::__field0),
                            "comment_id" => _serde::__private::Ok(__Field::__field1),
                            "user" => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"id" => _serde::__private::Ok(__Field::__field0),
                            b"comment_id" => _serde::__private::Ok(__Field::__field1),
                            b"user" => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<LikeData>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = LikeData;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct LikeData",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            u64,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct LikeData with 3 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            u64,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct LikeData with 3 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match _serde::de::SeqAccess::next_element::<
                            Principal,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct LikeData with 3 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(LikeData {
                            id: __field0,
                            comment_id: __field1,
                            user: __field2,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<u64> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<u64> = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<Principal> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("id"),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<u64>(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "comment_id",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<u64>(&mut __map)?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("user"),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<Principal>(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("id")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("comment_id")?
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("user")?
                            }
                        };
                        _serde::__private::Ok(LikeData {
                            id: __field0,
                            comment_id: __field1,
                            user: __field2,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &["id", "comment_id", "user"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "LikeData",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<LikeData>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
}
pub mod error {
    use dioxus_translate::Translate;
    use ethers::{
        abi::AbiError, contract::ContractError, providers::{Middleware, ProviderError},
        signers::WalletError, utils::ConversionError,
    };
    use validator::ValidationErrors;
    pub enum Error {
        #[translate(
            ko = "요청에 실패했습니다. 네트워크 상태를 점검해주세요.",
            en = "Request failed. Please check your network status."
        )]
        Reqwest(String),
        #[translate(
            ko = "Kaia 블록체인 네트워크 요청에 실패했습니다. 잠시후 다시 시도해주세요.",
            en = "Kaia blockchain network request failed. Please try again later."
        )]
        Klaytn(String),
        #[translate(
            ko = "ICP 주소가 올바르지 않습니다.",
            en = "ICP address is invalid."
        )]
        PrincipalError(String),
        #[translate(
            ko = "ICP 블록체인의 데이터를 읽을 수 없습니다. 커뮤니티에 보고해주세요.",
            en = "Failed to read data from ICP blockchain. Please report to the community."
        )]
        CandidError(String),
        #[translate(
            ko = "ICP 블록체인 요청에 실패했습니다. 잠시후 다시 시도해주세요.",
            en = "ICP blockchain request failed. Please try again later."
        )]
        AgentError(String),
        #[translate(
            ko = "파일 업로드에 실패했습니다. 다시 시도해주세요.",
            en = "Failed to upload file. Please try again."
        )]
        UploadMetadataError(String),
        #[translate(
            ko = "데이터베이스 오류가 발생했습니다. 관리자에게 문의해주세요.",
            en = "A database error has occurred. Please contact the administrator."
        )]
        DatabaseError(String),
        #[translate(
            ko = "업로드를 위한 URL을 얻을 수 없습니다. 다시 시도해주세요.",
            en = "Failed to get URL for upload. Please try again."
        )]
        AssetError(String),
        #[translate(
            ko = "입력데이터가 모두 정상인지 확인해주세요.",
            en = "Please check if all input data is correct."
        )]
        ValidationError(String),
        #[translate(
            ko = "알 수 없는 에러가 발생했습니다. 다시 시도해주세요.",
            en = "An unknown error has occurred. Please try again."
        )]
        Unknown(String),
        #[translate(
            ko = "데이터가 정상적으로 들어가지 않았을 수 있습니다. 새로고침 후 데이터가 정상주입되었는지 확인해주세요.",
            en = "The data may not have been entered correctly. Please check if the data has been injected correctly after refreshing."
        )]
        NoContentAfterInsert,
        #[translate(
            ko = "인증 토큰 생성에 실패하였습니다. 다시 시도해주세요.",
            en = "Failed to generate authentication token. Please try again."
        )]
        JwtGenerationFailed,
        #[translate(
            ko = "인가되지 않은 사용자 입니다. 로그인 상태를 확인해주세요.",
            en = "Unauthorized user. Please check your login status."
        )]
        Unauthorized,
        #[translate(
            ko = "이미 존재하는 데이터입니다. 다른 데이터를 입력해주세요.",
            en = "Data already exists. Please enter different data."
        )]
        InvalidType,
        #[translate(
            ko = "데이터가 존재하지 않습니다.",
            en = "Data does not exist."
        )]
        EmptyData,
        #[translate(
            ko = "컨텐츠가 존재하지 않습니다.",
            en = "Content does not exist."
        )]
        NotFoundContent,
        #[translate(
            ko = "Kaia 지갑이 없습니다. Chrome 웹 스토어에서 Kaia 지갑을 설치해주세요.",
            en = "No Kaia wallet. Please install Kaia wallet from Chrome Web Store."
        )]
        NoKaikasWallet,
        #[translate(
            ko = "서명에 실패했습니다. 다시 시도해주세요.",
            en = "Failed to sign. Please try again."
        )]
        SignError,
        #[translate(
            ko = "지갑이 초기화되지 않았습니다. 지갑을 초기화해주세요.",
            en = "The wallet has not been initialized. Please initialize the wallet."
        )]
        WalletNotInitialized,
        #[translate(
            ko = "시스템을 어뷰징 한 것으로 추측됩니다.",
            en = "It is suspected that the system is being abused."
        )]
        MisUsed(String),
        #[translate(
            ko = "카카오 메시지 전송에 실패했습니다.",
            en = "Failed to send Kakao message."
        )]
        KakaoSendMessageException,
        #[translate(
            ko = "데이터를 가져오는데 실패하였습니다. 관리자에게 문의해주세요.",
            en = "Failed to get data. Please contact the administrator."
        )]
        ParsingError,
        #[translate(
            ko = "잘못된 Seed 값을 입력했습니다.",
            en = "Invalid Seed value."
        )]
        InvalidSeed,
        #[translate(ko = "이미 발행된 NFT입니다.", en = "Already minted NFT.")]
        AlreadyMinted,
        #[translate(
            ko = "NFT 발행자는 민팅할 수 없습니다.",
            en = "NFT creators can not mint their own NFT"
        )]
        CannotMintedByCreator,
        #[translate(
            ko = "민팅된 NFT에 대한 사용권에 동의해야합니다.",
            en = "You must agree to the terms of use for the minted NFT."
        )]
        MustAgreeToTerms,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Error {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                Error::Reqwest(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Reqwest",
                        &__self_0,
                    )
                }
                Error::Klaytn(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Klaytn",
                        &__self_0,
                    )
                }
                Error::PrincipalError(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "PrincipalError",
                        &__self_0,
                    )
                }
                Error::CandidError(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "CandidError",
                        &__self_0,
                    )
                }
                Error::AgentError(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "AgentError",
                        &__self_0,
                    )
                }
                Error::UploadMetadataError(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "UploadMetadataError",
                        &__self_0,
                    )
                }
                Error::DatabaseError(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "DatabaseError",
                        &__self_0,
                    )
                }
                Error::AssetError(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "AssetError",
                        &__self_0,
                    )
                }
                Error::ValidationError(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "ValidationError",
                        &__self_0,
                    )
                }
                Error::Unknown(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Unknown",
                        &__self_0,
                    )
                }
                Error::NoContentAfterInsert => {
                    ::core::fmt::Formatter::write_str(f, "NoContentAfterInsert")
                }
                Error::JwtGenerationFailed => {
                    ::core::fmt::Formatter::write_str(f, "JwtGenerationFailed")
                }
                Error::Unauthorized => {
                    ::core::fmt::Formatter::write_str(f, "Unauthorized")
                }
                Error::InvalidType => ::core::fmt::Formatter::write_str(f, "InvalidType"),
                Error::EmptyData => ::core::fmt::Formatter::write_str(f, "EmptyData"),
                Error::NotFoundContent => {
                    ::core::fmt::Formatter::write_str(f, "NotFoundContent")
                }
                Error::NoKaikasWallet => {
                    ::core::fmt::Formatter::write_str(f, "NoKaikasWallet")
                }
                Error::SignError => ::core::fmt::Formatter::write_str(f, "SignError"),
                Error::WalletNotInitialized => {
                    ::core::fmt::Formatter::write_str(f, "WalletNotInitialized")
                }
                Error::MisUsed(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "MisUsed",
                        &__self_0,
                    )
                }
                Error::KakaoSendMessageException => {
                    ::core::fmt::Formatter::write_str(f, "KakaoSendMessageException")
                }
                Error::ParsingError => {
                    ::core::fmt::Formatter::write_str(f, "ParsingError")
                }
                Error::InvalidSeed => ::core::fmt::Formatter::write_str(f, "InvalidSeed"),
                Error::AlreadyMinted => {
                    ::core::fmt::Formatter::write_str(f, "AlreadyMinted")
                }
                Error::CannotMintedByCreator => {
                    ::core::fmt::Formatter::write_str(f, "CannotMintedByCreator")
                }
                Error::MustAgreeToTerms => {
                    ::core::fmt::Formatter::write_str(f, "MustAgreeToTerms")
                }
            }
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Error {
        #[inline]
        fn clone(&self) -> Error {
            match self {
                Error::Reqwest(__self_0) => {
                    Error::Reqwest(::core::clone::Clone::clone(__self_0))
                }
                Error::Klaytn(__self_0) => {
                    Error::Klaytn(::core::clone::Clone::clone(__self_0))
                }
                Error::PrincipalError(__self_0) => {
                    Error::PrincipalError(::core::clone::Clone::clone(__self_0))
                }
                Error::CandidError(__self_0) => {
                    Error::CandidError(::core::clone::Clone::clone(__self_0))
                }
                Error::AgentError(__self_0) => {
                    Error::AgentError(::core::clone::Clone::clone(__self_0))
                }
                Error::UploadMetadataError(__self_0) => {
                    Error::UploadMetadataError(::core::clone::Clone::clone(__self_0))
                }
                Error::DatabaseError(__self_0) => {
                    Error::DatabaseError(::core::clone::Clone::clone(__self_0))
                }
                Error::AssetError(__self_0) => {
                    Error::AssetError(::core::clone::Clone::clone(__self_0))
                }
                Error::ValidationError(__self_0) => {
                    Error::ValidationError(::core::clone::Clone::clone(__self_0))
                }
                Error::Unknown(__self_0) => {
                    Error::Unknown(::core::clone::Clone::clone(__self_0))
                }
                Error::NoContentAfterInsert => Error::NoContentAfterInsert,
                Error::JwtGenerationFailed => Error::JwtGenerationFailed,
                Error::Unauthorized => Error::Unauthorized,
                Error::InvalidType => Error::InvalidType,
                Error::EmptyData => Error::EmptyData,
                Error::NotFoundContent => Error::NotFoundContent,
                Error::NoKaikasWallet => Error::NoKaikasWallet,
                Error::SignError => Error::SignError,
                Error::WalletNotInitialized => Error::WalletNotInitialized,
                Error::MisUsed(__self_0) => {
                    Error::MisUsed(::core::clone::Clone::clone(__self_0))
                }
                Error::KakaoSendMessageException => Error::KakaoSendMessageException,
                Error::ParsingError => Error::ParsingError,
                Error::InvalidSeed => Error::InvalidSeed,
                Error::AlreadyMinted => Error::AlreadyMinted,
                Error::CannotMintedByCreator => Error::CannotMintedByCreator,
                Error::MustAgreeToTerms => Error::MustAgreeToTerms,
            }
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for Error {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    Error::Reqwest(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "Error",
                            0u32,
                            "Reqwest",
                            __field0,
                        )
                    }
                    Error::Klaytn(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "Error",
                            1u32,
                            "Klaytn",
                            __field0,
                        )
                    }
                    Error::PrincipalError(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "Error",
                            2u32,
                            "PrincipalError",
                            __field0,
                        )
                    }
                    Error::CandidError(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "Error",
                            3u32,
                            "CandidError",
                            __field0,
                        )
                    }
                    Error::AgentError(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "Error",
                            4u32,
                            "AgentError",
                            __field0,
                        )
                    }
                    Error::UploadMetadataError(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "Error",
                            5u32,
                            "UploadMetadataError",
                            __field0,
                        )
                    }
                    Error::DatabaseError(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "Error",
                            6u32,
                            "DatabaseError",
                            __field0,
                        )
                    }
                    Error::AssetError(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "Error",
                            7u32,
                            "AssetError",
                            __field0,
                        )
                    }
                    Error::ValidationError(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "Error",
                            8u32,
                            "ValidationError",
                            __field0,
                        )
                    }
                    Error::Unknown(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "Error",
                            9u32,
                            "Unknown",
                            __field0,
                        )
                    }
                    Error::NoContentAfterInsert => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "Error",
                            10u32,
                            "NoContentAfterInsert",
                        )
                    }
                    Error::JwtGenerationFailed => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "Error",
                            11u32,
                            "JwtGenerationFailed",
                        )
                    }
                    Error::Unauthorized => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "Error",
                            12u32,
                            "Unauthorized",
                        )
                    }
                    Error::InvalidType => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "Error",
                            13u32,
                            "InvalidType",
                        )
                    }
                    Error::EmptyData => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "Error",
                            14u32,
                            "EmptyData",
                        )
                    }
                    Error::NotFoundContent => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "Error",
                            15u32,
                            "NotFoundContent",
                        )
                    }
                    Error::NoKaikasWallet => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "Error",
                            16u32,
                            "NoKaikasWallet",
                        )
                    }
                    Error::SignError => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "Error",
                            17u32,
                            "SignError",
                        )
                    }
                    Error::WalletNotInitialized => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "Error",
                            18u32,
                            "WalletNotInitialized",
                        )
                    }
                    Error::MisUsed(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "Error",
                            19u32,
                            "MisUsed",
                            __field0,
                        )
                    }
                    Error::KakaoSendMessageException => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "Error",
                            20u32,
                            "KakaoSendMessageException",
                        )
                    }
                    Error::ParsingError => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "Error",
                            21u32,
                            "ParsingError",
                        )
                    }
                    Error::InvalidSeed => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "Error",
                            22u32,
                            "InvalidSeed",
                        )
                    }
                    Error::AlreadyMinted => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "Error",
                            23u32,
                            "AlreadyMinted",
                        )
                    }
                    Error::CannotMintedByCreator => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "Error",
                            24u32,
                            "CannotMintedByCreator",
                        )
                    }
                    Error::MustAgreeToTerms => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "Error",
                            25u32,
                            "MustAgreeToTerms",
                        )
                    }
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for Error {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __field4,
                    __field5,
                    __field6,
                    __field7,
                    __field8,
                    __field9,
                    __field10,
                    __field11,
                    __field12,
                    __field13,
                    __field14,
                    __field15,
                    __field16,
                    __field17,
                    __field18,
                    __field19,
                    __field20,
                    __field21,
                    __field22,
                    __field23,
                    __field24,
                    __field25,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "variant identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            4u64 => _serde::__private::Ok(__Field::__field4),
                            5u64 => _serde::__private::Ok(__Field::__field5),
                            6u64 => _serde::__private::Ok(__Field::__field6),
                            7u64 => _serde::__private::Ok(__Field::__field7),
                            8u64 => _serde::__private::Ok(__Field::__field8),
                            9u64 => _serde::__private::Ok(__Field::__field9),
                            10u64 => _serde::__private::Ok(__Field::__field10),
                            11u64 => _serde::__private::Ok(__Field::__field11),
                            12u64 => _serde::__private::Ok(__Field::__field12),
                            13u64 => _serde::__private::Ok(__Field::__field13),
                            14u64 => _serde::__private::Ok(__Field::__field14),
                            15u64 => _serde::__private::Ok(__Field::__field15),
                            16u64 => _serde::__private::Ok(__Field::__field16),
                            17u64 => _serde::__private::Ok(__Field::__field17),
                            18u64 => _serde::__private::Ok(__Field::__field18),
                            19u64 => _serde::__private::Ok(__Field::__field19),
                            20u64 => _serde::__private::Ok(__Field::__field20),
                            21u64 => _serde::__private::Ok(__Field::__field21),
                            22u64 => _serde::__private::Ok(__Field::__field22),
                            23u64 => _serde::__private::Ok(__Field::__field23),
                            24u64 => _serde::__private::Ok(__Field::__field24),
                            25u64 => _serde::__private::Ok(__Field::__field25),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::invalid_value(
                                        _serde::de::Unexpected::Unsigned(__value),
                                        &"variant index 0 <= i < 26",
                                    ),
                                )
                            }
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "Reqwest" => _serde::__private::Ok(__Field::__field0),
                            "Klaytn" => _serde::__private::Ok(__Field::__field1),
                            "PrincipalError" => _serde::__private::Ok(__Field::__field2),
                            "CandidError" => _serde::__private::Ok(__Field::__field3),
                            "AgentError" => _serde::__private::Ok(__Field::__field4),
                            "UploadMetadataError" => {
                                _serde::__private::Ok(__Field::__field5)
                            }
                            "DatabaseError" => _serde::__private::Ok(__Field::__field6),
                            "AssetError" => _serde::__private::Ok(__Field::__field7),
                            "ValidationError" => _serde::__private::Ok(__Field::__field8),
                            "Unknown" => _serde::__private::Ok(__Field::__field9),
                            "NoContentAfterInsert" => {
                                _serde::__private::Ok(__Field::__field10)
                            }
                            "JwtGenerationFailed" => {
                                _serde::__private::Ok(__Field::__field11)
                            }
                            "Unauthorized" => _serde::__private::Ok(__Field::__field12),
                            "InvalidType" => _serde::__private::Ok(__Field::__field13),
                            "EmptyData" => _serde::__private::Ok(__Field::__field14),
                            "NotFoundContent" => {
                                _serde::__private::Ok(__Field::__field15)
                            }
                            "NoKaikasWallet" => _serde::__private::Ok(__Field::__field16),
                            "SignError" => _serde::__private::Ok(__Field::__field17),
                            "WalletNotInitialized" => {
                                _serde::__private::Ok(__Field::__field18)
                            }
                            "MisUsed" => _serde::__private::Ok(__Field::__field19),
                            "KakaoSendMessageException" => {
                                _serde::__private::Ok(__Field::__field20)
                            }
                            "ParsingError" => _serde::__private::Ok(__Field::__field21),
                            "InvalidSeed" => _serde::__private::Ok(__Field::__field22),
                            "AlreadyMinted" => _serde::__private::Ok(__Field::__field23),
                            "CannotMintedByCreator" => {
                                _serde::__private::Ok(__Field::__field24)
                            }
                            "MustAgreeToTerms" => {
                                _serde::__private::Ok(__Field::__field25)
                            }
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"Reqwest" => _serde::__private::Ok(__Field::__field0),
                            b"Klaytn" => _serde::__private::Ok(__Field::__field1),
                            b"PrincipalError" => _serde::__private::Ok(__Field::__field2),
                            b"CandidError" => _serde::__private::Ok(__Field::__field3),
                            b"AgentError" => _serde::__private::Ok(__Field::__field4),
                            b"UploadMetadataError" => {
                                _serde::__private::Ok(__Field::__field5)
                            }
                            b"DatabaseError" => _serde::__private::Ok(__Field::__field6),
                            b"AssetError" => _serde::__private::Ok(__Field::__field7),
                            b"ValidationError" => {
                                _serde::__private::Ok(__Field::__field8)
                            }
                            b"Unknown" => _serde::__private::Ok(__Field::__field9),
                            b"NoContentAfterInsert" => {
                                _serde::__private::Ok(__Field::__field10)
                            }
                            b"JwtGenerationFailed" => {
                                _serde::__private::Ok(__Field::__field11)
                            }
                            b"Unauthorized" => _serde::__private::Ok(__Field::__field12),
                            b"InvalidType" => _serde::__private::Ok(__Field::__field13),
                            b"EmptyData" => _serde::__private::Ok(__Field::__field14),
                            b"NotFoundContent" => {
                                _serde::__private::Ok(__Field::__field15)
                            }
                            b"NoKaikasWallet" => {
                                _serde::__private::Ok(__Field::__field16)
                            }
                            b"SignError" => _serde::__private::Ok(__Field::__field17),
                            b"WalletNotInitialized" => {
                                _serde::__private::Ok(__Field::__field18)
                            }
                            b"MisUsed" => _serde::__private::Ok(__Field::__field19),
                            b"KakaoSendMessageException" => {
                                _serde::__private::Ok(__Field::__field20)
                            }
                            b"ParsingError" => _serde::__private::Ok(__Field::__field21),
                            b"InvalidSeed" => _serde::__private::Ok(__Field::__field22),
                            b"AlreadyMinted" => _serde::__private::Ok(__Field::__field23),
                            b"CannotMintedByCreator" => {
                                _serde::__private::Ok(__Field::__field24)
                            }
                            b"MustAgreeToTerms" => {
                                _serde::__private::Ok(__Field::__field25)
                            }
                            _ => {
                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<Error>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = Error;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "enum Error",
                        )
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match _serde::de::EnumAccess::variant(__data)? {
                            (__Field::__field0, __variant) => {
                                _serde::__private::Result::map(
                                    _serde::de::VariantAccess::newtype_variant::<
                                        String,
                                    >(__variant),
                                    Error::Reqwest,
                                )
                            }
                            (__Field::__field1, __variant) => {
                                _serde::__private::Result::map(
                                    _serde::de::VariantAccess::newtype_variant::<
                                        String,
                                    >(__variant),
                                    Error::Klaytn,
                                )
                            }
                            (__Field::__field2, __variant) => {
                                _serde::__private::Result::map(
                                    _serde::de::VariantAccess::newtype_variant::<
                                        String,
                                    >(__variant),
                                    Error::PrincipalError,
                                )
                            }
                            (__Field::__field3, __variant) => {
                                _serde::__private::Result::map(
                                    _serde::de::VariantAccess::newtype_variant::<
                                        String,
                                    >(__variant),
                                    Error::CandidError,
                                )
                            }
                            (__Field::__field4, __variant) => {
                                _serde::__private::Result::map(
                                    _serde::de::VariantAccess::newtype_variant::<
                                        String,
                                    >(__variant),
                                    Error::AgentError,
                                )
                            }
                            (__Field::__field5, __variant) => {
                                _serde::__private::Result::map(
                                    _serde::de::VariantAccess::newtype_variant::<
                                        String,
                                    >(__variant),
                                    Error::UploadMetadataError,
                                )
                            }
                            (__Field::__field6, __variant) => {
                                _serde::__private::Result::map(
                                    _serde::de::VariantAccess::newtype_variant::<
                                        String,
                                    >(__variant),
                                    Error::DatabaseError,
                                )
                            }
                            (__Field::__field7, __variant) => {
                                _serde::__private::Result::map(
                                    _serde::de::VariantAccess::newtype_variant::<
                                        String,
                                    >(__variant),
                                    Error::AssetError,
                                )
                            }
                            (__Field::__field8, __variant) => {
                                _serde::__private::Result::map(
                                    _serde::de::VariantAccess::newtype_variant::<
                                        String,
                                    >(__variant),
                                    Error::ValidationError,
                                )
                            }
                            (__Field::__field9, __variant) => {
                                _serde::__private::Result::map(
                                    _serde::de::VariantAccess::newtype_variant::<
                                        String,
                                    >(__variant),
                                    Error::Unknown,
                                )
                            }
                            (__Field::__field10, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(Error::NoContentAfterInsert)
                            }
                            (__Field::__field11, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(Error::JwtGenerationFailed)
                            }
                            (__Field::__field12, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(Error::Unauthorized)
                            }
                            (__Field::__field13, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(Error::InvalidType)
                            }
                            (__Field::__field14, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(Error::EmptyData)
                            }
                            (__Field::__field15, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(Error::NotFoundContent)
                            }
                            (__Field::__field16, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(Error::NoKaikasWallet)
                            }
                            (__Field::__field17, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(Error::SignError)
                            }
                            (__Field::__field18, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(Error::WalletNotInitialized)
                            }
                            (__Field::__field19, __variant) => {
                                _serde::__private::Result::map(
                                    _serde::de::VariantAccess::newtype_variant::<
                                        String,
                                    >(__variant),
                                    Error::MisUsed,
                                )
                            }
                            (__Field::__field20, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(Error::KakaoSendMessageException)
                            }
                            (__Field::__field21, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(Error::ParsingError)
                            }
                            (__Field::__field22, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(Error::InvalidSeed)
                            }
                            (__Field::__field23, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(Error::AlreadyMinted)
                            }
                            (__Field::__field24, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(Error::CannotMintedByCreator)
                            }
                            (__Field::__field25, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(Error::MustAgreeToTerms)
                            }
                        }
                    }
                }
                #[doc(hidden)]
                const VARIANTS: &'static [&'static str] = &[
                    "Reqwest",
                    "Klaytn",
                    "PrincipalError",
                    "CandidError",
                    "AgentError",
                    "UploadMetadataError",
                    "DatabaseError",
                    "AssetError",
                    "ValidationError",
                    "Unknown",
                    "NoContentAfterInsert",
                    "JwtGenerationFailed",
                    "Unauthorized",
                    "InvalidType",
                    "EmptyData",
                    "NotFoundContent",
                    "NoKaikasWallet",
                    "SignError",
                    "WalletNotInitialized",
                    "MisUsed",
                    "KakaoSendMessageException",
                    "ParsingError",
                    "InvalidSeed",
                    "AlreadyMinted",
                    "CannotMintedByCreator",
                    "MustAgreeToTerms",
                ];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "Error",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<Error>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    impl Error {
        pub fn translate(&self, lang: &dioxus_translate::Language) -> &'static str {
            match lang {
                dioxus_translate::Language::En => {
                    match self {
                        Error::Reqwest(..) => {
                            "Request failed. Please check your network status."
                        }
                        Error::Klaytn(..) => {
                            "Kaia blockchain network request failed. Please try again later."
                        }
                        Error::PrincipalError(..) => "ICP address is invalid.",
                        Error::CandidError(..) => {
                            "Failed to read data from ICP blockchain. Please report to the community."
                        }
                        Error::AgentError(..) => {
                            "ICP blockchain request failed. Please try again later."
                        }
                        Error::UploadMetadataError(..) => {
                            "Failed to upload file. Please try again."
                        }
                        Error::DatabaseError(..) => {
                            "A database error has occurred. Please contact the administrator."
                        }
                        Error::AssetError(..) => {
                            "Failed to get URL for upload. Please try again."
                        }
                        Error::ValidationError(..) => {
                            "Please check if all input data is correct."
                        }
                        Error::Unknown(..) => {
                            "An unknown error has occurred. Please try again."
                        }
                        Error::NoContentAfterInsert => {
                            "The data may not have been entered correctly. Please check if the data has been injected correctly after refreshing."
                        }
                        Error::JwtGenerationFailed => {
                            "Failed to generate authentication token. Please try again."
                        }
                        Error::Unauthorized => {
                            "Unauthorized user. Please check your login status."
                        }
                        Error::InvalidType => {
                            "Data already exists. Please enter different data."
                        }
                        Error::EmptyData => "Data does not exist.",
                        Error::NotFoundContent => "Content does not exist.",
                        Error::NoKaikasWallet => {
                            "No Kaia wallet. Please install Kaia wallet from Chrome Web Store."
                        }
                        Error::SignError => "Failed to sign. Please try again.",
                        Error::WalletNotInitialized => {
                            "The wallet has not been initialized. Please initialize the wallet."
                        }
                        Error::MisUsed(..) => {
                            "It is suspected that the system is being abused."
                        }
                        Error::KakaoSendMessageException => {
                            "Failed to send Kakao message."
                        }
                        Error::ParsingError => {
                            "Failed to get data. Please contact the administrator."
                        }
                        Error::InvalidSeed => "Invalid Seed value.",
                        Error::AlreadyMinted => "Already minted NFT.",
                        Error::CannotMintedByCreator => {
                            "NFT creators can not mint their own NFT"
                        }
                        Error::MustAgreeToTerms => {
                            "You must agree to the terms of use for the minted NFT."
                        }
                    }
                }
                dioxus_translate::Language::Ko => {
                    match self {
                        Error::Reqwest(..) => {
                            "요청에 실패했습니다. 네트워크 상태를 점검해주세요."
                        }
                        Error::Klaytn(..) => {
                            "Kaia 블록체인 네트워크 요청에 실패했습니다. 잠시후 다시 시도해주세요."
                        }
                        Error::PrincipalError(..) => {
                            "ICP 주소가 올바르지 않습니다."
                        }
                        Error::CandidError(..) => {
                            "ICP 블록체인의 데이터를 읽을 수 없습니다. 커뮤니티에 보고해주세요."
                        }
                        Error::AgentError(..) => {
                            "ICP 블록체인 요청에 실패했습니다. 잠시후 다시 시도해주세요."
                        }
                        Error::UploadMetadataError(..) => {
                            "파일 업로드에 실패했습니다. 다시 시도해주세요."
                        }
                        Error::DatabaseError(..) => {
                            "데이터베이스 오류가 발생했습니다. 관리자에게 문의해주세요."
                        }
                        Error::AssetError(..) => {
                            "업로드를 위한 URL을 얻을 수 없습니다. 다시 시도해주세요."
                        }
                        Error::ValidationError(..) => {
                            "입력데이터가 모두 정상인지 확인해주세요."
                        }
                        Error::Unknown(..) => {
                            "알 수 없는 에러가 발생했습니다. 다시 시도해주세요."
                        }
                        Error::NoContentAfterInsert => {
                            "데이터가 정상적으로 들어가지 않았을 수 있습니다. 새로고침 후 데이터가 정상주입되었는지 확인해주세요."
                        }
                        Error::JwtGenerationFailed => {
                            "인증 토큰 생성에 실패하였습니다. 다시 시도해주세요."
                        }
                        Error::Unauthorized => {
                            "인가되지 않은 사용자 입니다. 로그인 상태를 확인해주세요."
                        }
                        Error::InvalidType => {
                            "이미 존재하는 데이터입니다. 다른 데이터를 입력해주세요."
                        }
                        Error::EmptyData => "데이터가 존재하지 않습니다.",
                        Error::NotFoundContent => {
                            "컨텐츠가 존재하지 않습니다."
                        }
                        Error::NoKaikasWallet => {
                            "Kaia 지갑이 없습니다. Chrome 웹 스토어에서 Kaia 지갑을 설치해주세요."
                        }
                        Error::SignError => {
                            "서명에 실패했습니다. 다시 시도해주세요."
                        }
                        Error::WalletNotInitialized => {
                            "지갑이 초기화되지 않았습니다. 지갑을 초기화해주세요."
                        }
                        Error::MisUsed(..) => {
                            "시스템을 어뷰징 한 것으로 추측됩니다."
                        }
                        Error::KakaoSendMessageException => {
                            "카카오 메시지 전송에 실패했습니다."
                        }
                        Error::ParsingError => {
                            "데이터를 가져오는데 실패하였습니다. 관리자에게 문의해주세요."
                        }
                        Error::InvalidSeed => "잘못된 Seed 값을 입력했습니다.",
                        Error::AlreadyMinted => "이미 발행된 NFT입니다.",
                        Error::CannotMintedByCreator => {
                            "NFT 발행자는 민팅할 수 없습니다."
                        }
                        Error::MustAgreeToTerms => {
                            "민팅된 NFT에 대한 사용권에 동의해야합니다."
                        }
                    }
                }
            }
        }
        pub const VARIANTS: &'static [Self] = &[
            Error::NoContentAfterInsert,
            Error::JwtGenerationFailed,
            Error::Unauthorized,
            Error::InvalidType,
            Error::EmptyData,
            Error::NotFoundContent,
            Error::NoKaikasWallet,
            Error::SignError,
            Error::WalletNotInitialized,
            Error::KakaoSendMessageException,
            Error::ParsingError,
            Error::InvalidSeed,
            Error::AlreadyMinted,
            Error::CannotMintedByCreator,
            Error::MustAgreeToTerms,
        ];
        pub fn variants(lang: &dioxus_translate::Language) -> Vec<String> {
            Self::VARIANTS
                .iter()
                .map(|v| v.translate(&lang).to_string())
                .collect::<Vec<_>>()
        }
    }
    impl std::fmt::Display for Error {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match self {
                Error::Reqwest(..) => f.write_fmt(format_args!("reqwest")),
                Error::Klaytn(..) => f.write_fmt(format_args!("klaytn")),
                Error::PrincipalError(..) => f.write_fmt(format_args!("principalerror")),
                Error::CandidError(..) => f.write_fmt(format_args!("candiderror")),
                Error::AgentError(..) => f.write_fmt(format_args!("agenterror")),
                Error::UploadMetadataError(..) => {
                    f.write_fmt(format_args!("uploadmetadataerror"))
                }
                Error::DatabaseError(..) => f.write_fmt(format_args!("databaseerror")),
                Error::AssetError(..) => f.write_fmt(format_args!("asseterror")),
                Error::ValidationError(..) => {
                    f.write_fmt(format_args!("validationerror"))
                }
                Error::Unknown(..) => f.write_fmt(format_args!("unknown")),
                Error::NoContentAfterInsert => {
                    f.write_fmt(format_args!("nocontentafterinsert"))
                }
                Error::JwtGenerationFailed => {
                    f.write_fmt(format_args!("jwtgenerationfailed"))
                }
                Error::Unauthorized => f.write_fmt(format_args!("unauthorized")),
                Error::InvalidType => f.write_fmt(format_args!("invalidtype")),
                Error::EmptyData => f.write_fmt(format_args!("emptydata")),
                Error::NotFoundContent => f.write_fmt(format_args!("notfoundcontent")),
                Error::NoKaikasWallet => f.write_fmt(format_args!("nokaikaswallet")),
                Error::SignError => f.write_fmt(format_args!("signerror")),
                Error::WalletNotInitialized => {
                    f.write_fmt(format_args!("walletnotinitialized"))
                }
                Error::MisUsed(..) => f.write_fmt(format_args!("misused")),
                Error::KakaoSendMessageException => {
                    f.write_fmt(format_args!("kakaosendmessageexception"))
                }
                Error::ParsingError => f.write_fmt(format_args!("parsingerror")),
                Error::InvalidSeed => f.write_fmt(format_args!("invalidseed")),
                Error::AlreadyMinted => f.write_fmt(format_args!("alreadyminted")),
                Error::CannotMintedByCreator => {
                    f.write_fmt(format_args!("cannotmintedbycreator"))
                }
                Error::MustAgreeToTerms => f.write_fmt(format_args!("mustagreetoterms")),
            }
        }
    }
    impl std::str::FromStr for Error {
        type Err = String;
        fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
            match s {
                "Request failed. Please check your network status." | "reqwest" => {
                    Ok(Error::Reqwest(Default::default()))
                }
                "요청에 실패했습니다. 네트워크 상태를 점검해주세요." => {
                    Ok(Error::Reqwest(Default::default()))
                }
                "Kaia blockchain network request failed. Please try again later."
                | "klaytn" => Ok(Error::Klaytn(Default::default())),
                "Kaia 블록체인 네트워크 요청에 실패했습니다. 잠시후 다시 시도해주세요." => {
                    Ok(Error::Klaytn(Default::default()))
                }
                "ICP address is invalid." | "principalerror" => {
                    Ok(Error::PrincipalError(Default::default()))
                }
                "ICP 주소가 올바르지 않습니다." => {
                    Ok(Error::PrincipalError(Default::default()))
                }
                "Failed to read data from ICP blockchain. Please report to the community."
                | "candiderror" => Ok(Error::CandidError(Default::default())),
                "ICP 블록체인의 데이터를 읽을 수 없습니다. 커뮤니티에 보고해주세요." => {
                    Ok(Error::CandidError(Default::default()))
                }
                "ICP blockchain request failed. Please try again later."
                | "agenterror" => Ok(Error::AgentError(Default::default())),
                "ICP 블록체인 요청에 실패했습니다. 잠시후 다시 시도해주세요." => {
                    Ok(Error::AgentError(Default::default()))
                }
                "Failed to upload file. Please try again." | "uploadmetadataerror" => {
                    Ok(Error::UploadMetadataError(Default::default()))
                }
                "파일 업로드에 실패했습니다. 다시 시도해주세요." => {
                    Ok(Error::UploadMetadataError(Default::default()))
                }
                "A database error has occurred. Please contact the administrator."
                | "databaseerror" => Ok(Error::DatabaseError(Default::default())),
                "데이터베이스 오류가 발생했습니다. 관리자에게 문의해주세요." => {
                    Ok(Error::DatabaseError(Default::default()))
                }
                "Failed to get URL for upload. Please try again." | "asseterror" => {
                    Ok(Error::AssetError(Default::default()))
                }
                "업로드를 위한 URL을 얻을 수 없습니다. 다시 시도해주세요." => {
                    Ok(Error::AssetError(Default::default()))
                }
                "Please check if all input data is correct." | "validationerror" => {
                    Ok(Error::ValidationError(Default::default()))
                }
                "입력데이터가 모두 정상인지 확인해주세요." => {
                    Ok(Error::ValidationError(Default::default()))
                }
                "An unknown error has occurred. Please try again." | "unknown" => {
                    Ok(Error::Unknown(Default::default()))
                }
                "알 수 없는 에러가 발생했습니다. 다시 시도해주세요." => {
                    Ok(Error::Unknown(Default::default()))
                }
                "The data may not have been entered correctly. Please check if the data has been injected correctly after refreshing."
                | "nocontentafterinsert" => Ok(Error::NoContentAfterInsert),
                "데이터가 정상적으로 들어가지 않았을 수 있습니다. 새로고침 후 데이터가 정상주입되었는지 확인해주세요." => {
                    Ok(Error::NoContentAfterInsert)
                }
                "Failed to generate authentication token. Please try again."
                | "jwtgenerationfailed" => Ok(Error::JwtGenerationFailed),
                "인증 토큰 생성에 실패하였습니다. 다시 시도해주세요." => {
                    Ok(Error::JwtGenerationFailed)
                }
                "Unauthorized user. Please check your login status." | "unauthorized" => {
                    Ok(Error::Unauthorized)
                }
                "인가되지 않은 사용자 입니다. 로그인 상태를 확인해주세요." => {
                    Ok(Error::Unauthorized)
                }
                "Data already exists. Please enter different data." | "invalidtype" => {
                    Ok(Error::InvalidType)
                }
                "이미 존재하는 데이터입니다. 다른 데이터를 입력해주세요." => {
                    Ok(Error::InvalidType)
                }
                "Data does not exist." | "emptydata" => Ok(Error::EmptyData),
                "데이터가 존재하지 않습니다." => Ok(Error::EmptyData),
                "Content does not exist." | "notfoundcontent" => {
                    Ok(Error::NotFoundContent)
                }
                "컨텐츠가 존재하지 않습니다." => Ok(Error::NotFoundContent),
                "No Kaia wallet. Please install Kaia wallet from Chrome Web Store."
                | "nokaikaswallet" => Ok(Error::NoKaikasWallet),
                "Kaia 지갑이 없습니다. Chrome 웹 스토어에서 Kaia 지갑을 설치해주세요." => {
                    Ok(Error::NoKaikasWallet)
                }
                "Failed to sign. Please try again." | "signerror" => Ok(Error::SignError),
                "서명에 실패했습니다. 다시 시도해주세요." => {
                    Ok(Error::SignError)
                }
                "The wallet has not been initialized. Please initialize the wallet."
                | "walletnotinitialized" => Ok(Error::WalletNotInitialized),
                "지갑이 초기화되지 않았습니다. 지갑을 초기화해주세요." => {
                    Ok(Error::WalletNotInitialized)
                }
                "It is suspected that the system is being abused." | "misused" => {
                    Ok(Error::MisUsed(Default::default()))
                }
                "시스템을 어뷰징 한 것으로 추측됩니다." => {
                    Ok(Error::MisUsed(Default::default()))
                }
                "Failed to send Kakao message." | "kakaosendmessageexception" => {
                    Ok(Error::KakaoSendMessageException)
                }
                "카카오 메시지 전송에 실패했습니다." => {
                    Ok(Error::KakaoSendMessageException)
                }
                "Failed to get data. Please contact the administrator."
                | "parsingerror" => Ok(Error::ParsingError),
                "데이터를 가져오는데 실패하였습니다. 관리자에게 문의해주세요." => {
                    Ok(Error::ParsingError)
                }
                "Invalid Seed value." | "invalidseed" => Ok(Error::InvalidSeed),
                "잘못된 Seed 값을 입력했습니다." => Ok(Error::InvalidSeed),
                "Already minted NFT." | "alreadyminted" => Ok(Error::AlreadyMinted),
                "이미 발행된 NFT입니다." => Ok(Error::AlreadyMinted),
                "NFT creators can not mint their own NFT" | "cannotmintedbycreator" => {
                    Ok(Error::CannotMintedByCreator)
                }
                "NFT 발행자는 민팅할 수 없습니다." => {
                    Ok(Error::CannotMintedByCreator)
                }
                "You must agree to the terms of use for the minted NFT."
                | "mustagreetoterms" => Ok(Error::MustAgreeToTerms),
                "민팅된 NFT에 대한 사용권에 동의해야합니다." => {
                    Ok(Error::MustAgreeToTerms)
                }
                _ => {
                    Err(
                        ::alloc::__export::must_use({
                            let res = ::alloc::fmt::format(
                                format_args!("invalid field"),
                            );
                            res
                        }),
                    )
                }
            }
        }
    }
    impl std::error::Error for Error {}
    impl From<reqwest::Error> for Error {
        fn from(e: reqwest::Error) -> Self {
            Self::Reqwest(e.to_string())
        }
    }
    impl From<String> for Error {
        fn from(e: String) -> Self {
            Self::PrincipalError(e)
        }
    }
    impl From<ValidationErrors> for Error {
        fn from(e: ValidationErrors) -> Self {
            Self::ValidationError(e.to_string())
        }
    }
    impl<M: Middleware> From<ContractError<M>> for Error {
        fn from(e: ContractError<M>) -> Self {
            Self::Klaytn(e.to_string())
        }
    }
    impl From<AbiError> for Error {
        fn from(e: AbiError) -> Self {
            Self::Klaytn(e.to_string())
        }
    }
    impl From<ProviderError> for Error {
        fn from(e: ProviderError) -> Self {
            Self::Klaytn(e.to_string())
        }
    }
    impl From<ConversionError> for Error {
        fn from(e: ConversionError) -> Self {
            Self::Klaytn(e.to_string())
        }
    }
    impl From<WalletError> for Error {
        fn from(e: WalletError) -> Self {
            Self::Klaytn(e.to_string())
        }
    }
}
pub mod events {
    #![allow(unused)]
    use by_macros::api_model;
    /// Event is a generated struct that represents the model
    ///
    /// For making API calls related to this model, use `Event::get_client(endpoint: &str)`.
    /// It will returns EventClient struct that implements the API calls.
    ///
    /// In server side, you can use `Event::get_repository()` to interact with the database.
    /// Recommend to use `EventRepository` to insert or update the model.
    /// To query the model, use `Event::query_builder()`.
    /// For more detail, refer to the documentation of the query builder.
    pub struct Event {
        pub id: i64,
        pub created_at: i64,
        pub from_address: String,
        pub to_address: String,
        pub tx_hash: String,
        pub sort_key: i64,
        pub timestamp: i64,
        pub tx_index: i64,
        pub log_index: i64,
        pub block_number: i64,
        pub operator: String,
        pub token_id: i64,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Event {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let names: &'static _ = &[
                "id",
                "created_at",
                "from_address",
                "to_address",
                "tx_hash",
                "sort_key",
                "timestamp",
                "tx_index",
                "log_index",
                "block_number",
                "operator",
                "token_id",
            ];
            let values: &[&dyn ::core::fmt::Debug] = &[
                &self.id,
                &self.created_at,
                &self.from_address,
                &self.to_address,
                &self.tx_hash,
                &self.sort_key,
                &self.timestamp,
                &self.tx_index,
                &self.log_index,
                &self.block_number,
                &self.operator,
                &&self.token_id,
            ];
            ::core::fmt::Formatter::debug_struct_fields_finish(f, "Event", names, values)
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Event {
        #[inline]
        fn clone(&self) -> Event {
            Event {
                id: ::core::clone::Clone::clone(&self.id),
                created_at: ::core::clone::Clone::clone(&self.created_at),
                from_address: ::core::clone::Clone::clone(&self.from_address),
                to_address: ::core::clone::Clone::clone(&self.to_address),
                tx_hash: ::core::clone::Clone::clone(&self.tx_hash),
                sort_key: ::core::clone::Clone::clone(&self.sort_key),
                timestamp: ::core::clone::Clone::clone(&self.timestamp),
                tx_index: ::core::clone::Clone::clone(&self.tx_index),
                log_index: ::core::clone::Clone::clone(&self.log_index),
                block_number: ::core::clone::Clone::clone(&self.block_number),
                operator: ::core::clone::Clone::clone(&self.operator),
                token_id: ::core::clone::Clone::clone(&self.token_id),
            }
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for Event {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __field4,
                    __field5,
                    __field6,
                    __field7,
                    __field8,
                    __field9,
                    __field10,
                    __field11,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            4u64 => _serde::__private::Ok(__Field::__field4),
                            5u64 => _serde::__private::Ok(__Field::__field5),
                            6u64 => _serde::__private::Ok(__Field::__field6),
                            7u64 => _serde::__private::Ok(__Field::__field7),
                            8u64 => _serde::__private::Ok(__Field::__field8),
                            9u64 => _serde::__private::Ok(__Field::__field9),
                            10u64 => _serde::__private::Ok(__Field::__field10),
                            11u64 => _serde::__private::Ok(__Field::__field11),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "id" => _serde::__private::Ok(__Field::__field0),
                            "created_at" => _serde::__private::Ok(__Field::__field1),
                            "from_address" => _serde::__private::Ok(__Field::__field2),
                            "to_address" => _serde::__private::Ok(__Field::__field3),
                            "tx_hash" => _serde::__private::Ok(__Field::__field4),
                            "sort_key" => _serde::__private::Ok(__Field::__field5),
                            "timestamp" => _serde::__private::Ok(__Field::__field6),
                            "tx_index" => _serde::__private::Ok(__Field::__field7),
                            "log_index" => _serde::__private::Ok(__Field::__field8),
                            "block_number" => _serde::__private::Ok(__Field::__field9),
                            "operator" => _serde::__private::Ok(__Field::__field10),
                            "token_id" => _serde::__private::Ok(__Field::__field11),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"id" => _serde::__private::Ok(__Field::__field0),
                            b"created_at" => _serde::__private::Ok(__Field::__field1),
                            b"from_address" => _serde::__private::Ok(__Field::__field2),
                            b"to_address" => _serde::__private::Ok(__Field::__field3),
                            b"tx_hash" => _serde::__private::Ok(__Field::__field4),
                            b"sort_key" => _serde::__private::Ok(__Field::__field5),
                            b"timestamp" => _serde::__private::Ok(__Field::__field6),
                            b"tx_index" => _serde::__private::Ok(__Field::__field7),
                            b"log_index" => _serde::__private::Ok(__Field::__field8),
                            b"block_number" => _serde::__private::Ok(__Field::__field9),
                            b"operator" => _serde::__private::Ok(__Field::__field10),
                            b"token_id" => _serde::__private::Ok(__Field::__field11),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<Event>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = Event;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct Event",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            i64,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct Event with 12 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            i64,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct Event with 12 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct Event with 12 elements",
                                    ),
                                );
                            }
                        };
                        let __field3 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        3usize,
                                        &"struct Event with 12 elements",
                                    ),
                                );
                            }
                        };
                        let __field4 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        4usize,
                                        &"struct Event with 12 elements",
                                    ),
                                );
                            }
                        };
                        let __field5 = match _serde::de::SeqAccess::next_element::<
                            i64,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        5usize,
                                        &"struct Event with 12 elements",
                                    ),
                                );
                            }
                        };
                        let __field6 = match _serde::de::SeqAccess::next_element::<
                            i64,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        6usize,
                                        &"struct Event with 12 elements",
                                    ),
                                );
                            }
                        };
                        let __field7 = match _serde::de::SeqAccess::next_element::<
                            i64,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        7usize,
                                        &"struct Event with 12 elements",
                                    ),
                                );
                            }
                        };
                        let __field8 = match _serde::de::SeqAccess::next_element::<
                            i64,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        8usize,
                                        &"struct Event with 12 elements",
                                    ),
                                );
                            }
                        };
                        let __field9 = match _serde::de::SeqAccess::next_element::<
                            i64,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        9usize,
                                        &"struct Event with 12 elements",
                                    ),
                                );
                            }
                        };
                        let __field10 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        10usize,
                                        &"struct Event with 12 elements",
                                    ),
                                );
                            }
                        };
                        let __field11 = match _serde::de::SeqAccess::next_element::<
                            i64,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        11usize,
                                        &"struct Event with 12 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(Event {
                            id: __field0,
                            created_at: __field1,
                            from_address: __field2,
                            to_address: __field3,
                            tx_hash: __field4,
                            sort_key: __field5,
                            timestamp: __field6,
                            tx_index: __field7,
                            log_index: __field8,
                            block_number: __field9,
                            operator: __field10,
                            token_id: __field11,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<i64> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<i64> = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field3: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field4: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field5: _serde::__private::Option<i64> = _serde::__private::None;
                        let mut __field6: _serde::__private::Option<i64> = _serde::__private::None;
                        let mut __field7: _serde::__private::Option<i64> = _serde::__private::None;
                        let mut __field8: _serde::__private::Option<i64> = _serde::__private::None;
                        let mut __field9: _serde::__private::Option<i64> = _serde::__private::None;
                        let mut __field10: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field11: _serde::__private::Option<i64> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("id"),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<i64>(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "created_at",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<i64>(&mut __map)?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "from_address",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field3 => {
                                    if _serde::__private::Option::is_some(&__field3) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "to_address",
                                            ),
                                        );
                                    }
                                    __field3 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field4 => {
                                    if _serde::__private::Option::is_some(&__field4) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "tx_hash",
                                            ),
                                        );
                                    }
                                    __field4 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field5 => {
                                    if _serde::__private::Option::is_some(&__field5) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "sort_key",
                                            ),
                                        );
                                    }
                                    __field5 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<i64>(&mut __map)?,
                                    );
                                }
                                __Field::__field6 => {
                                    if _serde::__private::Option::is_some(&__field6) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "timestamp",
                                            ),
                                        );
                                    }
                                    __field6 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<i64>(&mut __map)?,
                                    );
                                }
                                __Field::__field7 => {
                                    if _serde::__private::Option::is_some(&__field7) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "tx_index",
                                            ),
                                        );
                                    }
                                    __field7 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<i64>(&mut __map)?,
                                    );
                                }
                                __Field::__field8 => {
                                    if _serde::__private::Option::is_some(&__field8) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "log_index",
                                            ),
                                        );
                                    }
                                    __field8 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<i64>(&mut __map)?,
                                    );
                                }
                                __Field::__field9 => {
                                    if _serde::__private::Option::is_some(&__field9) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "block_number",
                                            ),
                                        );
                                    }
                                    __field9 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<i64>(&mut __map)?,
                                    );
                                }
                                __Field::__field10 => {
                                    if _serde::__private::Option::is_some(&__field10) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "operator",
                                            ),
                                        );
                                    }
                                    __field10 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field11 => {
                                    if _serde::__private::Option::is_some(&__field11) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "token_id",
                                            ),
                                        );
                                    }
                                    __field11 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<i64>(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("id")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("created_at")?
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("from_address")?
                            }
                        };
                        let __field3 = match __field3 {
                            _serde::__private::Some(__field3) => __field3,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("to_address")?
                            }
                        };
                        let __field4 = match __field4 {
                            _serde::__private::Some(__field4) => __field4,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("tx_hash")?
                            }
                        };
                        let __field5 = match __field5 {
                            _serde::__private::Some(__field5) => __field5,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("sort_key")?
                            }
                        };
                        let __field6 = match __field6 {
                            _serde::__private::Some(__field6) => __field6,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("timestamp")?
                            }
                        };
                        let __field7 = match __field7 {
                            _serde::__private::Some(__field7) => __field7,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("tx_index")?
                            }
                        };
                        let __field8 = match __field8 {
                            _serde::__private::Some(__field8) => __field8,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("log_index")?
                            }
                        };
                        let __field9 = match __field9 {
                            _serde::__private::Some(__field9) => __field9,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("block_number")?
                            }
                        };
                        let __field10 = match __field10 {
                            _serde::__private::Some(__field10) => __field10,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("operator")?
                            }
                        };
                        let __field11 = match __field11 {
                            _serde::__private::Some(__field11) => __field11,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("token_id")?
                            }
                        };
                        _serde::__private::Ok(Event {
                            id: __field0,
                            created_at: __field1,
                            from_address: __field2,
                            to_address: __field3,
                            tx_hash: __field4,
                            sort_key: __field5,
                            timestamp: __field6,
                            tx_index: __field7,
                            log_index: __field8,
                            block_number: __field9,
                            operator: __field10,
                            token_id: __field11,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "id",
                    "created_at",
                    "from_address",
                    "to_address",
                    "tx_hash",
                    "sort_key",
                    "timestamp",
                    "tx_index",
                    "log_index",
                    "block_number",
                    "operator",
                    "token_id",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "Event",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<Event>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for Event {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "Event",
                    false as usize + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "id",
                    &self.id,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "created_at",
                    &self.created_at,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "from_address",
                    &self.from_address,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "to_address",
                    &self.to_address,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "tx_hash",
                    &self.tx_hash,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "sort_key",
                    &self.sort_key,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "timestamp",
                    &self.timestamp,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "tx_index",
                    &self.tx_index,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "log_index",
                    &self.log_index,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "block_number",
                    &self.block_number,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "operator",
                    &self.operator,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "token_id",
                    &self.token_id,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[automatically_derived]
    impl ::core::default::Default for Event {
        #[inline]
        fn default() -> Event {
            Event {
                id: ::core::default::Default::default(),
                created_at: ::core::default::Default::default(),
                from_address: ::core::default::Default::default(),
                to_address: ::core::default::Default::default(),
                tx_hash: ::core::default::Default::default(),
                sort_key: ::core::default::Default::default(),
                timestamp: ::core::default::Default::default(),
                tx_index: ::core::default::Default::default(),
                log_index: ::core::default::Default::default(),
                block_number: ::core::default::Default::default(),
                operator: ::core::default::Default::default(),
                token_id: ::core::default::Default::default(),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Event {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Event {
        #[inline]
        fn eq(&self, other: &Event) -> bool {
            self.id == other.id && self.created_at == other.created_at
                && self.from_address == other.from_address
                && self.to_address == other.to_address && self.tx_hash == other.tx_hash
                && self.sort_key == other.sort_key && self.timestamp == other.timestamp
                && self.tx_index == other.tx_index && self.log_index == other.log_index
                && self.block_number == other.block_number
                && self.operator == other.operator && self.token_id == other.token_id
        }
    }
    #[serde(rename_all = "snake_case")]
    pub enum EventAction {
        Create(EventCreateRequest),
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for EventAction {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                EventAction::Create(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Create",
                        &__self_0,
                    )
                }
            }
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for EventAction {
        #[inline]
        fn clone(&self) -> EventAction {
            match self {
                EventAction::Create(__self_0) => {
                    EventAction::Create(::core::clone::Clone::clone(__self_0))
                }
            }
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for EventAction {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    EventAction::Create(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "EventAction",
                            0u32,
                            "create",
                            __field0,
                        )
                    }
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for EventAction {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "variant identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::invalid_value(
                                        _serde::de::Unexpected::Unsigned(__value),
                                        &"variant index 0 <= i < 1",
                                    ),
                                )
                            }
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "create" => _serde::__private::Ok(__Field::__field0),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"create" => _serde::__private::Ok(__Field::__field0),
                            _ => {
                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<EventAction>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = EventAction;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "enum EventAction",
                        )
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match _serde::de::EnumAccess::variant(__data)? {
                            (__Field::__field0, __variant) => {
                                _serde::__private::Result::map(
                                    _serde::de::VariantAccess::newtype_variant::<
                                        EventCreateRequest,
                                    >(__variant),
                                    EventAction::Create,
                                )
                            }
                        }
                    }
                }
                #[doc(hidden)]
                const VARIANTS: &'static [&'static str] = &["create"];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "EventAction",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<EventAction>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for EventAction {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for EventAction {
        #[inline]
        fn eq(&self, other: &EventAction) -> bool {
            match (self, other) {
                (EventAction::Create(__self_0), EventAction::Create(__arg1_0)) => {
                    __self_0 == __arg1_0
                }
            }
        }
    }
    pub struct EventCreateRequest {
        pub from_address: String,
        pub to_address: String,
        pub tx_hash: String,
        pub sort_key: i64,
        pub timestamp: i64,
        pub tx_index: i64,
        pub log_index: i64,
        pub block_number: i64,
        pub operator: String,
        pub token_id: i64,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for EventCreateRequest {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let names: &'static _ = &[
                "from_address",
                "to_address",
                "tx_hash",
                "sort_key",
                "timestamp",
                "tx_index",
                "log_index",
                "block_number",
                "operator",
                "token_id",
            ];
            let values: &[&dyn ::core::fmt::Debug] = &[
                &self.from_address,
                &self.to_address,
                &self.tx_hash,
                &self.sort_key,
                &self.timestamp,
                &self.tx_index,
                &self.log_index,
                &self.block_number,
                &self.operator,
                &&self.token_id,
            ];
            ::core::fmt::Formatter::debug_struct_fields_finish(
                f,
                "EventCreateRequest",
                names,
                values,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for EventCreateRequest {
        #[inline]
        fn clone(&self) -> EventCreateRequest {
            EventCreateRequest {
                from_address: ::core::clone::Clone::clone(&self.from_address),
                to_address: ::core::clone::Clone::clone(&self.to_address),
                tx_hash: ::core::clone::Clone::clone(&self.tx_hash),
                sort_key: ::core::clone::Clone::clone(&self.sort_key),
                timestamp: ::core::clone::Clone::clone(&self.timestamp),
                tx_index: ::core::clone::Clone::clone(&self.tx_index),
                log_index: ::core::clone::Clone::clone(&self.log_index),
                block_number: ::core::clone::Clone::clone(&self.block_number),
                operator: ::core::clone::Clone::clone(&self.operator),
                token_id: ::core::clone::Clone::clone(&self.token_id),
            }
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for EventCreateRequest {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "EventCreateRequest",
                    false as usize + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "from_address",
                    &self.from_address,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "to_address",
                    &self.to_address,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "tx_hash",
                    &self.tx_hash,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "sort_key",
                    &self.sort_key,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "timestamp",
                    &self.timestamp,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "tx_index",
                    &self.tx_index,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "log_index",
                    &self.log_index,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "block_number",
                    &self.block_number,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "operator",
                    &self.operator,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "token_id",
                    &self.token_id,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for EventCreateRequest {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __field4,
                    __field5,
                    __field6,
                    __field7,
                    __field8,
                    __field9,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            4u64 => _serde::__private::Ok(__Field::__field4),
                            5u64 => _serde::__private::Ok(__Field::__field5),
                            6u64 => _serde::__private::Ok(__Field::__field6),
                            7u64 => _serde::__private::Ok(__Field::__field7),
                            8u64 => _serde::__private::Ok(__Field::__field8),
                            9u64 => _serde::__private::Ok(__Field::__field9),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "from_address" => _serde::__private::Ok(__Field::__field0),
                            "to_address" => _serde::__private::Ok(__Field::__field1),
                            "tx_hash" => _serde::__private::Ok(__Field::__field2),
                            "sort_key" => _serde::__private::Ok(__Field::__field3),
                            "timestamp" => _serde::__private::Ok(__Field::__field4),
                            "tx_index" => _serde::__private::Ok(__Field::__field5),
                            "log_index" => _serde::__private::Ok(__Field::__field6),
                            "block_number" => _serde::__private::Ok(__Field::__field7),
                            "operator" => _serde::__private::Ok(__Field::__field8),
                            "token_id" => _serde::__private::Ok(__Field::__field9),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"from_address" => _serde::__private::Ok(__Field::__field0),
                            b"to_address" => _serde::__private::Ok(__Field::__field1),
                            b"tx_hash" => _serde::__private::Ok(__Field::__field2),
                            b"sort_key" => _serde::__private::Ok(__Field::__field3),
                            b"timestamp" => _serde::__private::Ok(__Field::__field4),
                            b"tx_index" => _serde::__private::Ok(__Field::__field5),
                            b"log_index" => _serde::__private::Ok(__Field::__field6),
                            b"block_number" => _serde::__private::Ok(__Field::__field7),
                            b"operator" => _serde::__private::Ok(__Field::__field8),
                            b"token_id" => _serde::__private::Ok(__Field::__field9),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<EventCreateRequest>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = EventCreateRequest;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct EventCreateRequest",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct EventCreateRequest with 10 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct EventCreateRequest with 10 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct EventCreateRequest with 10 elements",
                                    ),
                                );
                            }
                        };
                        let __field3 = match _serde::de::SeqAccess::next_element::<
                            i64,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        3usize,
                                        &"struct EventCreateRequest with 10 elements",
                                    ),
                                );
                            }
                        };
                        let __field4 = match _serde::de::SeqAccess::next_element::<
                            i64,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        4usize,
                                        &"struct EventCreateRequest with 10 elements",
                                    ),
                                );
                            }
                        };
                        let __field5 = match _serde::de::SeqAccess::next_element::<
                            i64,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        5usize,
                                        &"struct EventCreateRequest with 10 elements",
                                    ),
                                );
                            }
                        };
                        let __field6 = match _serde::de::SeqAccess::next_element::<
                            i64,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        6usize,
                                        &"struct EventCreateRequest with 10 elements",
                                    ),
                                );
                            }
                        };
                        let __field7 = match _serde::de::SeqAccess::next_element::<
                            i64,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        7usize,
                                        &"struct EventCreateRequest with 10 elements",
                                    ),
                                );
                            }
                        };
                        let __field8 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        8usize,
                                        &"struct EventCreateRequest with 10 elements",
                                    ),
                                );
                            }
                        };
                        let __field9 = match _serde::de::SeqAccess::next_element::<
                            i64,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        9usize,
                                        &"struct EventCreateRequest with 10 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(EventCreateRequest {
                            from_address: __field0,
                            to_address: __field1,
                            tx_hash: __field2,
                            sort_key: __field3,
                            timestamp: __field4,
                            tx_index: __field5,
                            log_index: __field6,
                            block_number: __field7,
                            operator: __field8,
                            token_id: __field9,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field3: _serde::__private::Option<i64> = _serde::__private::None;
                        let mut __field4: _serde::__private::Option<i64> = _serde::__private::None;
                        let mut __field5: _serde::__private::Option<i64> = _serde::__private::None;
                        let mut __field6: _serde::__private::Option<i64> = _serde::__private::None;
                        let mut __field7: _serde::__private::Option<i64> = _serde::__private::None;
                        let mut __field8: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field9: _serde::__private::Option<i64> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "from_address",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "to_address",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "tx_hash",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field3 => {
                                    if _serde::__private::Option::is_some(&__field3) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "sort_key",
                                            ),
                                        );
                                    }
                                    __field3 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<i64>(&mut __map)?,
                                    );
                                }
                                __Field::__field4 => {
                                    if _serde::__private::Option::is_some(&__field4) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "timestamp",
                                            ),
                                        );
                                    }
                                    __field4 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<i64>(&mut __map)?,
                                    );
                                }
                                __Field::__field5 => {
                                    if _serde::__private::Option::is_some(&__field5) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "tx_index",
                                            ),
                                        );
                                    }
                                    __field5 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<i64>(&mut __map)?,
                                    );
                                }
                                __Field::__field6 => {
                                    if _serde::__private::Option::is_some(&__field6) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "log_index",
                                            ),
                                        );
                                    }
                                    __field6 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<i64>(&mut __map)?,
                                    );
                                }
                                __Field::__field7 => {
                                    if _serde::__private::Option::is_some(&__field7) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "block_number",
                                            ),
                                        );
                                    }
                                    __field7 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<i64>(&mut __map)?,
                                    );
                                }
                                __Field::__field8 => {
                                    if _serde::__private::Option::is_some(&__field8) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "operator",
                                            ),
                                        );
                                    }
                                    __field8 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field9 => {
                                    if _serde::__private::Option::is_some(&__field9) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "token_id",
                                            ),
                                        );
                                    }
                                    __field9 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<i64>(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("from_address")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("to_address")?
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("tx_hash")?
                            }
                        };
                        let __field3 = match __field3 {
                            _serde::__private::Some(__field3) => __field3,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("sort_key")?
                            }
                        };
                        let __field4 = match __field4 {
                            _serde::__private::Some(__field4) => __field4,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("timestamp")?
                            }
                        };
                        let __field5 = match __field5 {
                            _serde::__private::Some(__field5) => __field5,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("tx_index")?
                            }
                        };
                        let __field6 = match __field6 {
                            _serde::__private::Some(__field6) => __field6,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("log_index")?
                            }
                        };
                        let __field7 = match __field7 {
                            _serde::__private::Some(__field7) => __field7,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("block_number")?
                            }
                        };
                        let __field8 = match __field8 {
                            _serde::__private::Some(__field8) => __field8,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("operator")?
                            }
                        };
                        let __field9 = match __field9 {
                            _serde::__private::Some(__field9) => __field9,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("token_id")?
                            }
                        };
                        _serde::__private::Ok(EventCreateRequest {
                            from_address: __field0,
                            to_address: __field1,
                            tx_hash: __field2,
                            sort_key: __field3,
                            timestamp: __field4,
                            tx_index: __field5,
                            log_index: __field6,
                            block_number: __field7,
                            operator: __field8,
                            token_id: __field9,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "from_address",
                    "to_address",
                    "tx_hash",
                    "sort_key",
                    "timestamp",
                    "tx_index",
                    "log_index",
                    "block_number",
                    "operator",
                    "token_id",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "EventCreateRequest",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<EventCreateRequest>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::default::Default for EventCreateRequest {
        #[inline]
        fn default() -> EventCreateRequest {
            EventCreateRequest {
                from_address: ::core::default::Default::default(),
                to_address: ::core::default::Default::default(),
                tx_hash: ::core::default::Default::default(),
                sort_key: ::core::default::Default::default(),
                timestamp: ::core::default::Default::default(),
                tx_index: ::core::default::Default::default(),
                log_index: ::core::default::Default::default(),
                block_number: ::core::default::Default::default(),
                operator: ::core::default::Default::default(),
                token_id: ::core::default::Default::default(),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for EventCreateRequest {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for EventCreateRequest {
        #[inline]
        fn eq(&self, other: &EventCreateRequest) -> bool {
            self.from_address == other.from_address
                && self.to_address == other.to_address && self.tx_hash == other.tx_hash
                && self.sort_key == other.sort_key && self.timestamp == other.timestamp
                && self.tx_index == other.tx_index && self.log_index == other.log_index
                && self.block_number == other.block_number
                && self.operator == other.operator && self.token_id == other.token_id
        }
    }
    impl EventClient {
        pub async fn act(&self, params: EventAction) -> crate::Result<Event> {
            let path = ::alloc::__export::must_use({
                let res = ::alloc::fmt::format(format_args!("/events"));
                res
            });
            let endpoint = ::alloc::__export::must_use({
                let res = ::alloc::fmt::format(
                    format_args!("{0}{1}", self.endpoint, path),
                );
                res
            });
            rest_api::post(&endpoint, params).await
        }
        pub async fn create(
            &self,
            from_address: String,
            to_address: String,
            tx_hash: String,
            sort_key: i64,
            timestamp: i64,
            tx_index: i64,
            log_index: i64,
            block_number: i64,
            operator: String,
            token_id: i64,
        ) -> crate::Result<Event> {
            let path = ::alloc::__export::must_use({
                let res = ::alloc::fmt::format(format_args!("/events"));
                res
            });
            let endpoint = ::alloc::__export::must_use({
                let res = ::alloc::fmt::format(
                    format_args!("{0}{1}", self.endpoint, path),
                );
                res
            });
            let req = EventAction::Create(EventCreateRequest {
                from_address,
                to_address,
                tx_hash,
                sort_key,
                timestamp,
                tx_index,
                log_index,
                block_number,
                operator,
                token_id,
            });
            rest_api::post(&endpoint, req).await
        }
    }
    pub struct EventSummary {
        pub id: i64,
        pub created_at: i64,
        pub from_address: String,
        pub to_address: String,
        pub tx_hash: String,
        pub sort_key: i64,
        pub timestamp: i64,
        pub tx_index: i64,
        pub log_index: i64,
        pub block_number: i64,
        pub operator: String,
        pub token_id: i64,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for EventSummary {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let names: &'static _ = &[
                "id",
                "created_at",
                "from_address",
                "to_address",
                "tx_hash",
                "sort_key",
                "timestamp",
                "tx_index",
                "log_index",
                "block_number",
                "operator",
                "token_id",
            ];
            let values: &[&dyn ::core::fmt::Debug] = &[
                &self.id,
                &self.created_at,
                &self.from_address,
                &self.to_address,
                &self.tx_hash,
                &self.sort_key,
                &self.timestamp,
                &self.tx_index,
                &self.log_index,
                &self.block_number,
                &self.operator,
                &&self.token_id,
            ];
            ::core::fmt::Formatter::debug_struct_fields_finish(
                f,
                "EventSummary",
                names,
                values,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for EventSummary {
        #[inline]
        fn clone(&self) -> EventSummary {
            EventSummary {
                id: ::core::clone::Clone::clone(&self.id),
                created_at: ::core::clone::Clone::clone(&self.created_at),
                from_address: ::core::clone::Clone::clone(&self.from_address),
                to_address: ::core::clone::Clone::clone(&self.to_address),
                tx_hash: ::core::clone::Clone::clone(&self.tx_hash),
                sort_key: ::core::clone::Clone::clone(&self.sort_key),
                timestamp: ::core::clone::Clone::clone(&self.timestamp),
                tx_index: ::core::clone::Clone::clone(&self.tx_index),
                log_index: ::core::clone::Clone::clone(&self.log_index),
                block_number: ::core::clone::Clone::clone(&self.block_number),
                operator: ::core::clone::Clone::clone(&self.operator),
                token_id: ::core::clone::Clone::clone(&self.token_id),
            }
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for EventSummary {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "EventSummary",
                    false as usize + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "id",
                    &self.id,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "created_at",
                    &self.created_at,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "from_address",
                    &self.from_address,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "to_address",
                    &self.to_address,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "tx_hash",
                    &self.tx_hash,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "sort_key",
                    &self.sort_key,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "timestamp",
                    &self.timestamp,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "tx_index",
                    &self.tx_index,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "log_index",
                    &self.log_index,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "block_number",
                    &self.block_number,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "operator",
                    &self.operator,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "token_id",
                    &self.token_id,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for EventSummary {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __field4,
                    __field5,
                    __field6,
                    __field7,
                    __field8,
                    __field9,
                    __field10,
                    __field11,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            4u64 => _serde::__private::Ok(__Field::__field4),
                            5u64 => _serde::__private::Ok(__Field::__field5),
                            6u64 => _serde::__private::Ok(__Field::__field6),
                            7u64 => _serde::__private::Ok(__Field::__field7),
                            8u64 => _serde::__private::Ok(__Field::__field8),
                            9u64 => _serde::__private::Ok(__Field::__field9),
                            10u64 => _serde::__private::Ok(__Field::__field10),
                            11u64 => _serde::__private::Ok(__Field::__field11),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "id" => _serde::__private::Ok(__Field::__field0),
                            "created_at" => _serde::__private::Ok(__Field::__field1),
                            "from_address" => _serde::__private::Ok(__Field::__field2),
                            "to_address" => _serde::__private::Ok(__Field::__field3),
                            "tx_hash" => _serde::__private::Ok(__Field::__field4),
                            "sort_key" => _serde::__private::Ok(__Field::__field5),
                            "timestamp" => _serde::__private::Ok(__Field::__field6),
                            "tx_index" => _serde::__private::Ok(__Field::__field7),
                            "log_index" => _serde::__private::Ok(__Field::__field8),
                            "block_number" => _serde::__private::Ok(__Field::__field9),
                            "operator" => _serde::__private::Ok(__Field::__field10),
                            "token_id" => _serde::__private::Ok(__Field::__field11),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"id" => _serde::__private::Ok(__Field::__field0),
                            b"created_at" => _serde::__private::Ok(__Field::__field1),
                            b"from_address" => _serde::__private::Ok(__Field::__field2),
                            b"to_address" => _serde::__private::Ok(__Field::__field3),
                            b"tx_hash" => _serde::__private::Ok(__Field::__field4),
                            b"sort_key" => _serde::__private::Ok(__Field::__field5),
                            b"timestamp" => _serde::__private::Ok(__Field::__field6),
                            b"tx_index" => _serde::__private::Ok(__Field::__field7),
                            b"log_index" => _serde::__private::Ok(__Field::__field8),
                            b"block_number" => _serde::__private::Ok(__Field::__field9),
                            b"operator" => _serde::__private::Ok(__Field::__field10),
                            b"token_id" => _serde::__private::Ok(__Field::__field11),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<EventSummary>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = EventSummary;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct EventSummary",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            i64,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct EventSummary with 12 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            i64,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct EventSummary with 12 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct EventSummary with 12 elements",
                                    ),
                                );
                            }
                        };
                        let __field3 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        3usize,
                                        &"struct EventSummary with 12 elements",
                                    ),
                                );
                            }
                        };
                        let __field4 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        4usize,
                                        &"struct EventSummary with 12 elements",
                                    ),
                                );
                            }
                        };
                        let __field5 = match _serde::de::SeqAccess::next_element::<
                            i64,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        5usize,
                                        &"struct EventSummary with 12 elements",
                                    ),
                                );
                            }
                        };
                        let __field6 = match _serde::de::SeqAccess::next_element::<
                            i64,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        6usize,
                                        &"struct EventSummary with 12 elements",
                                    ),
                                );
                            }
                        };
                        let __field7 = match _serde::de::SeqAccess::next_element::<
                            i64,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        7usize,
                                        &"struct EventSummary with 12 elements",
                                    ),
                                );
                            }
                        };
                        let __field8 = match _serde::de::SeqAccess::next_element::<
                            i64,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        8usize,
                                        &"struct EventSummary with 12 elements",
                                    ),
                                );
                            }
                        };
                        let __field9 = match _serde::de::SeqAccess::next_element::<
                            i64,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        9usize,
                                        &"struct EventSummary with 12 elements",
                                    ),
                                );
                            }
                        };
                        let __field10 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        10usize,
                                        &"struct EventSummary with 12 elements",
                                    ),
                                );
                            }
                        };
                        let __field11 = match _serde::de::SeqAccess::next_element::<
                            i64,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        11usize,
                                        &"struct EventSummary with 12 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(EventSummary {
                            id: __field0,
                            created_at: __field1,
                            from_address: __field2,
                            to_address: __field3,
                            tx_hash: __field4,
                            sort_key: __field5,
                            timestamp: __field6,
                            tx_index: __field7,
                            log_index: __field8,
                            block_number: __field9,
                            operator: __field10,
                            token_id: __field11,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<i64> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<i64> = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field3: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field4: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field5: _serde::__private::Option<i64> = _serde::__private::None;
                        let mut __field6: _serde::__private::Option<i64> = _serde::__private::None;
                        let mut __field7: _serde::__private::Option<i64> = _serde::__private::None;
                        let mut __field8: _serde::__private::Option<i64> = _serde::__private::None;
                        let mut __field9: _serde::__private::Option<i64> = _serde::__private::None;
                        let mut __field10: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field11: _serde::__private::Option<i64> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("id"),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<i64>(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "created_at",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<i64>(&mut __map)?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "from_address",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field3 => {
                                    if _serde::__private::Option::is_some(&__field3) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "to_address",
                                            ),
                                        );
                                    }
                                    __field3 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field4 => {
                                    if _serde::__private::Option::is_some(&__field4) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "tx_hash",
                                            ),
                                        );
                                    }
                                    __field4 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field5 => {
                                    if _serde::__private::Option::is_some(&__field5) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "sort_key",
                                            ),
                                        );
                                    }
                                    __field5 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<i64>(&mut __map)?,
                                    );
                                }
                                __Field::__field6 => {
                                    if _serde::__private::Option::is_some(&__field6) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "timestamp",
                                            ),
                                        );
                                    }
                                    __field6 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<i64>(&mut __map)?,
                                    );
                                }
                                __Field::__field7 => {
                                    if _serde::__private::Option::is_some(&__field7) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "tx_index",
                                            ),
                                        );
                                    }
                                    __field7 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<i64>(&mut __map)?,
                                    );
                                }
                                __Field::__field8 => {
                                    if _serde::__private::Option::is_some(&__field8) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "log_index",
                                            ),
                                        );
                                    }
                                    __field8 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<i64>(&mut __map)?,
                                    );
                                }
                                __Field::__field9 => {
                                    if _serde::__private::Option::is_some(&__field9) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "block_number",
                                            ),
                                        );
                                    }
                                    __field9 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<i64>(&mut __map)?,
                                    );
                                }
                                __Field::__field10 => {
                                    if _serde::__private::Option::is_some(&__field10) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "operator",
                                            ),
                                        );
                                    }
                                    __field10 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field11 => {
                                    if _serde::__private::Option::is_some(&__field11) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "token_id",
                                            ),
                                        );
                                    }
                                    __field11 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<i64>(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("id")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("created_at")?
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("from_address")?
                            }
                        };
                        let __field3 = match __field3 {
                            _serde::__private::Some(__field3) => __field3,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("to_address")?
                            }
                        };
                        let __field4 = match __field4 {
                            _serde::__private::Some(__field4) => __field4,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("tx_hash")?
                            }
                        };
                        let __field5 = match __field5 {
                            _serde::__private::Some(__field5) => __field5,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("sort_key")?
                            }
                        };
                        let __field6 = match __field6 {
                            _serde::__private::Some(__field6) => __field6,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("timestamp")?
                            }
                        };
                        let __field7 = match __field7 {
                            _serde::__private::Some(__field7) => __field7,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("tx_index")?
                            }
                        };
                        let __field8 = match __field8 {
                            _serde::__private::Some(__field8) => __field8,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("log_index")?
                            }
                        };
                        let __field9 = match __field9 {
                            _serde::__private::Some(__field9) => __field9,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("block_number")?
                            }
                        };
                        let __field10 = match __field10 {
                            _serde::__private::Some(__field10) => __field10,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("operator")?
                            }
                        };
                        let __field11 = match __field11 {
                            _serde::__private::Some(__field11) => __field11,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("token_id")?
                            }
                        };
                        _serde::__private::Ok(EventSummary {
                            id: __field0,
                            created_at: __field1,
                            from_address: __field2,
                            to_address: __field3,
                            tx_hash: __field4,
                            sort_key: __field5,
                            timestamp: __field6,
                            tx_index: __field7,
                            log_index: __field8,
                            block_number: __field9,
                            operator: __field10,
                            token_id: __field11,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "id",
                    "created_at",
                    "from_address",
                    "to_address",
                    "tx_hash",
                    "sort_key",
                    "timestamp",
                    "tx_index",
                    "log_index",
                    "block_number",
                    "operator",
                    "token_id",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "EventSummary",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<EventSummary>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::default::Default for EventSummary {
        #[inline]
        fn default() -> EventSummary {
            EventSummary {
                id: ::core::default::Default::default(),
                created_at: ::core::default::Default::default(),
                from_address: ::core::default::Default::default(),
                to_address: ::core::default::Default::default(),
                tx_hash: ::core::default::Default::default(),
                sort_key: ::core::default::Default::default(),
                timestamp: ::core::default::Default::default(),
                tx_index: ::core::default::Default::default(),
                log_index: ::core::default::Default::default(),
                block_number: ::core::default::Default::default(),
                operator: ::core::default::Default::default(),
                token_id: ::core::default::Default::default(),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for EventSummary {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for EventSummary {
        #[inline]
        fn eq(&self, other: &EventSummary) -> bool {
            self.id == other.id && self.created_at == other.created_at
                && self.from_address == other.from_address
                && self.to_address == other.to_address && self.tx_hash == other.tx_hash
                && self.sort_key == other.sort_key && self.timestamp == other.timestamp
                && self.tx_index == other.tx_index && self.log_index == other.log_index
                && self.block_number == other.block_number
                && self.operator == other.operator && self.token_id == other.token_id
        }
    }
    impl From<Event> for EventSummary {
        fn from(item: Event) -> Self {
            Self {
                id: item.id,
                created_at: item.created_at,
                from_address: item.from_address,
                to_address: item.to_address,
                tx_hash: item.tx_hash,
                sort_key: item.sort_key,
                timestamp: item.timestamp,
                tx_index: item.tx_index,
                log_index: item.log_index,
                block_number: item.block_number,
                operator: item.operator,
                token_id: item.token_id,
            }
        }
    }
    impl Into<Event> for EventSummary {
        fn into(self) -> Event {
            Event {
                id: self.id,
                created_at: self.created_at,
                from_address: self.from_address,
                to_address: self.to_address,
                tx_hash: self.tx_hash,
                sort_key: self.sort_key,
                timestamp: self.timestamp,
                tx_index: self.tx_index,
                log_index: self.log_index,
                block_number: self.block_number,
                operator: self.operator,
                token_id: self.token_id,
                ..Default::default()
            }
        }
    }
    #[serde(rename_all = "kebab-case")]
    pub struct EventQuery {
        #[serde(deserialize_with = "parse_size_of_event_query", default)]
        pub size: usize,
        pub bookmark: Option<String>,
        pub action: Option<EventQueryActionType>,
        pub tx_hash: Option<String>,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for EventQuery {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field4_finish(
                f,
                "EventQuery",
                "size",
                &self.size,
                "bookmark",
                &self.bookmark,
                "action",
                &self.action,
                "tx_hash",
                &&self.tx_hash,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for EventQuery {
        #[inline]
        fn clone(&self) -> EventQuery {
            EventQuery {
                size: ::core::clone::Clone::clone(&self.size),
                bookmark: ::core::clone::Clone::clone(&self.bookmark),
                action: ::core::clone::Clone::clone(&self.action),
                tx_hash: ::core::clone::Clone::clone(&self.tx_hash),
            }
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for EventQuery {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "EventQuery",
                    false as usize + 1 + 1 + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "size",
                    &self.size,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "bookmark",
                    &self.bookmark,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "action",
                    &self.action,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "tx-hash",
                    &self.tx_hash,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for EventQuery {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "size" => _serde::__private::Ok(__Field::__field0),
                            "bookmark" => _serde::__private::Ok(__Field::__field1),
                            "action" => _serde::__private::Ok(__Field::__field2),
                            "tx-hash" => _serde::__private::Ok(__Field::__field3),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"size" => _serde::__private::Ok(__Field::__field0),
                            b"bookmark" => _serde::__private::Ok(__Field::__field1),
                            b"action" => _serde::__private::Ok(__Field::__field2),
                            b"tx-hash" => _serde::__private::Ok(__Field::__field3),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<EventQuery>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = EventQuery;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct EventQuery",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match {
                            #[doc(hidden)]
                            struct __DeserializeWith<'de> {
                                value: usize,
                                phantom: _serde::__private::PhantomData<EventQuery>,
                                lifetime: _serde::__private::PhantomData<&'de ()>,
                            }
                            #[automatically_derived]
                            impl<'de> _serde::Deserialize<'de>
                            for __DeserializeWith<'de> {
                                fn deserialize<__D>(
                                    __deserializer: __D,
                                ) -> _serde::__private::Result<Self, __D::Error>
                                where
                                    __D: _serde::Deserializer<'de>,
                                {
                                    _serde::__private::Ok(__DeserializeWith {
                                        value: parse_size_of_event_query(__deserializer)?,
                                        phantom: _serde::__private::PhantomData,
                                        lifetime: _serde::__private::PhantomData,
                                    })
                                }
                            }
                            _serde::__private::Option::map(
                                _serde::de::SeqAccess::next_element::<
                                    __DeserializeWith<'de>,
                                >(&mut __seq)?,
                                |__wrap| __wrap.value,
                            )
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                _serde::__private::Default::default()
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            Option<String>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct EventQuery with 4 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match _serde::de::SeqAccess::next_element::<
                            Option<EventQueryActionType>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct EventQuery with 4 elements",
                                    ),
                                );
                            }
                        };
                        let __field3 = match _serde::de::SeqAccess::next_element::<
                            Option<String>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        3usize,
                                        &"struct EventQuery with 4 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(EventQuery {
                            size: __field0,
                            bookmark: __field1,
                            action: __field2,
                            tx_hash: __field3,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<usize> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<Option<String>> = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<
                            Option<EventQueryActionType>,
                        > = _serde::__private::None;
                        let mut __field3: _serde::__private::Option<Option<String>> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("size"),
                                        );
                                    }
                                    __field0 = _serde::__private::Some({
                                        #[doc(hidden)]
                                        struct __DeserializeWith<'de> {
                                            value: usize,
                                            phantom: _serde::__private::PhantomData<EventQuery>,
                                            lifetime: _serde::__private::PhantomData<&'de ()>,
                                        }
                                        #[automatically_derived]
                                        impl<'de> _serde::Deserialize<'de>
                                        for __DeserializeWith<'de> {
                                            fn deserialize<__D>(
                                                __deserializer: __D,
                                            ) -> _serde::__private::Result<Self, __D::Error>
                                            where
                                                __D: _serde::Deserializer<'de>,
                                            {
                                                _serde::__private::Ok(__DeserializeWith {
                                                    value: parse_size_of_event_query(__deserializer)?,
                                                    phantom: _serde::__private::PhantomData,
                                                    lifetime: _serde::__private::PhantomData,
                                                })
                                            }
                                        }
                                        match _serde::de::MapAccess::next_value::<
                                            __DeserializeWith<'de>,
                                        >(&mut __map) {
                                            _serde::__private::Ok(__wrapper) => __wrapper.value,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        }
                                    });
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "bookmark",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<String>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("action"),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<EventQueryActionType>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field3 => {
                                    if _serde::__private::Option::is_some(&__field3) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "tx-hash",
                                            ),
                                        );
                                    }
                                    __field3 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<String>,
                                        >(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::Default::default()
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("bookmark")?
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("action")?
                            }
                        };
                        let __field3 = match __field3 {
                            _serde::__private::Some(__field3) => __field3,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("tx-hash")?
                            }
                        };
                        _serde::__private::Ok(EventQuery {
                            size: __field0,
                            bookmark: __field1,
                            action: __field2,
                            tx_hash: __field3,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "size",
                    "bookmark",
                    "action",
                    "tx-hash",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "EventQuery",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<EventQuery>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::default::Default for EventQuery {
        #[inline]
        fn default() -> EventQuery {
            EventQuery {
                size: ::core::default::Default::default(),
                bookmark: ::core::default::Default::default(),
                action: ::core::default::Default::default(),
                tx_hash: ::core::default::Default::default(),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for EventQuery {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for EventQuery {
        #[inline]
        fn eq(&self, other: &EventQuery) -> bool {
            self.size == other.size && self.bookmark == other.bookmark
                && self.action == other.action && self.tx_hash == other.tx_hash
        }
    }
    impl std::fmt::Display for EventQuery {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let query = serde_urlencoded::to_string(&self).map_err(|_| std::fmt::Error)?;
            f.write_fmt(format_args!("{0}", query))
        }
    }
    pub fn parse_size_of_event_query<'de, D>(
        deserializer: D,
    ) -> std::result::Result<usize, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::Deserialize;
        let s: Option<String> = Option::deserialize(deserializer)?;
        s.unwrap_or_else(|| Default::default())
            .parse::<usize>()
            .map_err(serde::de::Error::custom)
    }
    impl EventQuery {
        pub fn new(size: usize) -> Self {
            Self { size, ..Self::default() }
        }
        pub fn with_bookmark(mut self, bookmark: String) -> Self {
            self.bookmark = Some(bookmark);
            self
        }
        pub fn with_page(mut self, page: usize) -> Self {
            self.bookmark = Some(page.to_string());
            self
        }
        /// Returns the size(i32) of the query
        pub fn size(&self) -> i32 {
            self.size as i32
        }
        pub fn page(&self) -> i32 {
            self.bookmark.as_ref().unwrap_or(&"1".to_string()).parse().unwrap_or(1)
        }
        pub fn find_by_hash(mut self, tx_hash: String) -> Self {
            self.tx_hash = Some(tx_hash);
            self.action = Some(EventQueryActionType::FindByHash);
            self
        }
    }
    #[serde(rename_all = "kebab-case")]
    pub enum EventQueryActionType {
        FindByHash,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for EventQueryActionType {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "FindByHash")
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for EventQueryActionType {
        #[inline]
        fn clone(&self) -> EventQueryActionType {
            EventQueryActionType::FindByHash
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for EventQueryActionType {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for EventQueryActionType {
        #[inline]
        fn eq(&self, other: &EventQueryActionType) -> bool {
            true
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for EventQueryActionType {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    EventQueryActionType::FindByHash => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "EventQueryActionType",
                            0u32,
                            "find-by-hash",
                        )
                    }
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for EventQueryActionType {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "variant identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::invalid_value(
                                        _serde::de::Unexpected::Unsigned(__value),
                                        &"variant index 0 <= i < 1",
                                    ),
                                )
                            }
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "find-by-hash" => _serde::__private::Ok(__Field::__field0),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"find-by-hash" => _serde::__private::Ok(__Field::__field0),
                            _ => {
                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<EventQueryActionType>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = EventQueryActionType;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "enum EventQueryActionType",
                        )
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match _serde::de::EnumAccess::variant(__data)? {
                            (__Field::__field0, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(EventQueryActionType::FindByHash)
                            }
                        }
                    }
                }
                #[doc(hidden)]
                const VARIANTS: &'static [&'static str] = &["find-by-hash"];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "EventQueryActionType",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<EventQueryActionType>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    impl EventClient {
        pub async fn find_by_hash(
            &self,
            size: usize,
            bookmark: Option<String>,
            tx_hash: String,
        ) -> crate::Result<by_types::QueryResponse<EventSummary>> {
            let path = ::alloc::__export::must_use({
                let res = ::alloc::fmt::format(format_args!("/events"));
                res
            });
            let endpoint = ::alloc::__export::must_use({
                let res = ::alloc::fmt::format(
                    format_args!("{0}{1}", self.endpoint, path),
                );
                res
            });
            let params = EventParam::Query(EventQuery {
                size,
                bookmark,
                action: Some(EventQueryActionType::FindByHash),
                tx_hash: Some(tx_hash),
                ..EventQuery::default()
            });
            let query = ::alloc::__export::must_use({
                let res = ::alloc::fmt::format(
                    format_args!("{0}?{1}", endpoint, params),
                );
                res
            });
            rest_api::get(&query).await
        }
    }
    impl Event {
        pub fn get_client(endpoint: &str) -> EventClient {
            EventClient {
                endpoint: endpoint.to_string(),
            }
        }
    }
    pub struct EventClient {
        pub endpoint: String,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for EventClient {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field1_finish(
                f,
                "EventClient",
                "endpoint",
                &&self.endpoint,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for EventClient {
        #[inline]
        fn clone(&self) -> EventClient {
            EventClient {
                endpoint: ::core::clone::Clone::clone(&self.endpoint),
            }
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for EventClient {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "EventClient",
                    false as usize + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "endpoint",
                    &self.endpoint,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for EventClient {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "endpoint" => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"endpoint" => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<EventClient>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = EventClient;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct EventClient",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct EventClient with 1 element",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(EventClient { endpoint: __field0 })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "endpoint",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("endpoint")?
                            }
                        };
                        _serde::__private::Ok(EventClient { endpoint: __field0 })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &["endpoint"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "EventClient",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<EventClient>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::default::Default for EventClient {
        #[inline]
        fn default() -> EventClient {
            EventClient {
                endpoint: ::core::default::Default::default(),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for EventClient {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for EventClient {
        #[inline]
        fn eq(&self, other: &EventClient) -> bool {
            self.endpoint == other.endpoint
        }
    }
    impl EventClient {
        pub async fn query(
            &self,
            params: EventQuery,
        ) -> crate::Result<by_types::QueryResponse<EventSummary>> {
            let path = ::alloc::__export::must_use({
                let res = ::alloc::fmt::format(format_args!("/events"));
                res
            });
            let endpoint = ::alloc::__export::must_use({
                let res = ::alloc::fmt::format(
                    format_args!("{0}{1}", self.endpoint, path),
                );
                res
            });
            let query = ::alloc::__export::must_use({
                let res = ::alloc::fmt::format(
                    format_args!("{0}?{1}", endpoint, EventParam::Query(params)),
                );
                res
            });
            rest_api::get(&query).await
        }
        pub async fn get(&self, id: i64) -> crate::Result<Event> {
            let path = ::alloc::__export::must_use({
                let res = ::alloc::fmt::format(format_args!("/events"));
                res
            });
            let endpoint = ::alloc::__export::must_use({
                let res = ::alloc::fmt::format(
                    format_args!("{0}{1}/{2}", self.endpoint, path, id),
                );
                res
            });
            rest_api::get(&endpoint).await
        }
    }
    impl Event {
        pub fn url() -> String {
            "/events".to_string()
        }
    }
    pub struct EventReadAction {}
    #[automatically_derived]
    impl ::core::fmt::Debug for EventReadAction {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "EventReadAction")
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for EventReadAction {
        #[inline]
        fn clone(&self) -> EventReadAction {
            EventReadAction {}
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for EventReadAction {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "EventReadAction",
                    false as usize,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for EventReadAction {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<EventReadAction>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = EventReadAction;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct EventReadAction",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        _: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        _serde::__private::Ok(EventReadAction {})
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        _serde::__private::Ok(EventReadAction {})
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "EventReadAction",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<EventReadAction>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::default::Default for EventReadAction {
        #[inline]
        fn default() -> EventReadAction {
            EventReadAction {}
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for EventReadAction {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for EventReadAction {
        #[inline]
        fn eq(&self, other: &EventReadAction) -> bool {
            true
        }
    }
    impl std::fmt::Display for EventReadAction {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let query = serde_urlencoded::to_string(&self).map_err(|_| std::fmt::Error)?;
            f.write_fmt(format_args!("{0}", query))
        }
    }
    impl EventReadAction {
        pub fn new() -> Self {
            Self::default()
        }
    }
    impl EventClient {}
    #[serde(tag = "param-type", rename_all = "kebab-case")]
    pub enum EventParam {
        Query(EventQuery),
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for EventParam {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                EventParam::Query(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Query",
                        &__self_0,
                    )
                }
            }
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for EventParam {
        #[inline]
        fn clone(&self) -> EventParam {
            match self {
                EventParam::Query(__self_0) => {
                    EventParam::Query(::core::clone::Clone::clone(__self_0))
                }
            }
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for EventParam {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    EventParam::Query(ref __field0) => {
                        _serde::__private::ser::serialize_tagged_newtype(
                            __serializer,
                            "EventParam",
                            "Query",
                            "param-type",
                            "query",
                            __field0,
                        )
                    }
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for EventParam {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "variant identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::invalid_value(
                                        _serde::de::Unexpected::Unsigned(__value),
                                        &"variant index 0 <= i < 1",
                                    ),
                                )
                            }
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "query" => _serde::__private::Ok(__Field::__field0),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"query" => _serde::__private::Ok(__Field::__field0),
                            _ => {
                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                const VARIANTS: &'static [&'static str] = &["query"];
                let (__tag, __content) = _serde::Deserializer::deserialize_any(
                    __deserializer,
                    _serde::__private::de::TaggedContentVisitor::<
                        __Field,
                    >::new("param-type", "internally tagged enum EventParam"),
                )?;
                let __deserializer = _serde::__private::de::ContentDeserializer::<
                    __D::Error,
                >::new(__content);
                match __tag {
                    __Field::__field0 => {
                        _serde::__private::Result::map(
                            <EventQuery as _serde::Deserialize>::deserialize(
                                __deserializer,
                            ),
                            EventParam::Query,
                        )
                    }
                }
            }
        }
    };
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for EventParam {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for EventParam {
        #[inline]
        fn eq(&self, other: &EventParam) -> bool {
            match (self, other) {
                (EventParam::Query(__self_0), EventParam::Query(__arg1_0)) => {
                    __self_0 == __arg1_0
                }
            }
        }
    }
    impl std::fmt::Display for EventParam {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let query = serde_urlencoded::to_string(&self).map_err(|_| std::fmt::Error)?;
            f.write_fmt(format_args!("{0}", query))
        }
    }
    #[serde(tag = "param_type")]
    #[serde(rename_all = "snake_case")]
    pub enum EventGetResponse {
        Query(by_types::QueryResponse<EventSummary>),
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for EventGetResponse {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                EventGetResponse::Query(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Query",
                        &__self_0,
                    )
                }
            }
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for EventGetResponse {
        #[inline]
        fn clone(&self) -> EventGetResponse {
            match self {
                EventGetResponse::Query(__self_0) => {
                    EventGetResponse::Query(::core::clone::Clone::clone(__self_0))
                }
            }
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for EventGetResponse {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    EventGetResponse::Query(ref __field0) => {
                        _serde::__private::ser::serialize_tagged_newtype(
                            __serializer,
                            "EventGetResponse",
                            "Query",
                            "param_type",
                            "query",
                            __field0,
                        )
                    }
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for EventGetResponse {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "variant identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::invalid_value(
                                        _serde::de::Unexpected::Unsigned(__value),
                                        &"variant index 0 <= i < 1",
                                    ),
                                )
                            }
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "query" => _serde::__private::Ok(__Field::__field0),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"query" => _serde::__private::Ok(__Field::__field0),
                            _ => {
                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                const VARIANTS: &'static [&'static str] = &["query"];
                let (__tag, __content) = _serde::Deserializer::deserialize_any(
                    __deserializer,
                    _serde::__private::de::TaggedContentVisitor::<
                        __Field,
                    >::new("param_type", "internally tagged enum EventGetResponse"),
                )?;
                let __deserializer = _serde::__private::de::ContentDeserializer::<
                    __D::Error,
                >::new(__content);
                match __tag {
                    __Field::__field0 => {
                        _serde::__private::Result::map(
                            <by_types::QueryResponse<
                                EventSummary,
                            > as _serde::Deserialize>::deserialize(__deserializer),
                            EventGetResponse::Query,
                        )
                    }
                }
            }
        }
    };
    /// UserNftTransfer is a generated struct that represents the model
    ///
    /// For making API calls related to this model, use `UserNftTransfer::get_client(endpoint: &str)`.
    /// It will returns UserNftTransferClient struct that implements the API calls.
    ///
    /// In server side, you can use `UserNftTransfer::get_repository()` to interact with the database.
    /// Recommend to use `UserNftTransferRepository` to insert or update the model.
    /// To query the model, use `UserNftTransfer::query_builder()`.
    /// For more detail, refer to the documentation of the query builder.
    pub struct UserNftTransfer {
        pub id: i64,
        pub created_at: i64,
        pub user_id: i64,
        pub event_id: i64,
        pub amount: i64,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for UserNftTransfer {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field5_finish(
                f,
                "UserNftTransfer",
                "id",
                &self.id,
                "created_at",
                &self.created_at,
                "user_id",
                &self.user_id,
                "event_id",
                &self.event_id,
                "amount",
                &&self.amount,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for UserNftTransfer {
        #[inline]
        fn clone(&self) -> UserNftTransfer {
            UserNftTransfer {
                id: ::core::clone::Clone::clone(&self.id),
                created_at: ::core::clone::Clone::clone(&self.created_at),
                user_id: ::core::clone::Clone::clone(&self.user_id),
                event_id: ::core::clone::Clone::clone(&self.event_id),
                amount: ::core::clone::Clone::clone(&self.amount),
            }
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for UserNftTransfer {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __field4,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            4u64 => _serde::__private::Ok(__Field::__field4),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "id" => _serde::__private::Ok(__Field::__field0),
                            "created_at" => _serde::__private::Ok(__Field::__field1),
                            "user_id" => _serde::__private::Ok(__Field::__field2),
                            "event_id" => _serde::__private::Ok(__Field::__field3),
                            "amount" => _serde::__private::Ok(__Field::__field4),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"id" => _serde::__private::Ok(__Field::__field0),
                            b"created_at" => _serde::__private::Ok(__Field::__field1),
                            b"user_id" => _serde::__private::Ok(__Field::__field2),
                            b"event_id" => _serde::__private::Ok(__Field::__field3),
                            b"amount" => _serde::__private::Ok(__Field::__field4),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<UserNftTransfer>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = UserNftTransfer;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct UserNftTransfer",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            i64,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct UserNftTransfer with 5 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            i64,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct UserNftTransfer with 5 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match _serde::de::SeqAccess::next_element::<
                            i64,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct UserNftTransfer with 5 elements",
                                    ),
                                );
                            }
                        };
                        let __field3 = match _serde::de::SeqAccess::next_element::<
                            i64,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        3usize,
                                        &"struct UserNftTransfer with 5 elements",
                                    ),
                                );
                            }
                        };
                        let __field4 = match _serde::de::SeqAccess::next_element::<
                            i64,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        4usize,
                                        &"struct UserNftTransfer with 5 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(UserNftTransfer {
                            id: __field0,
                            created_at: __field1,
                            user_id: __field2,
                            event_id: __field3,
                            amount: __field4,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<i64> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<i64> = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<i64> = _serde::__private::None;
                        let mut __field3: _serde::__private::Option<i64> = _serde::__private::None;
                        let mut __field4: _serde::__private::Option<i64> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("id"),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<i64>(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "created_at",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<i64>(&mut __map)?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "user_id",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<i64>(&mut __map)?,
                                    );
                                }
                                __Field::__field3 => {
                                    if _serde::__private::Option::is_some(&__field3) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "event_id",
                                            ),
                                        );
                                    }
                                    __field3 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<i64>(&mut __map)?,
                                    );
                                }
                                __Field::__field4 => {
                                    if _serde::__private::Option::is_some(&__field4) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("amount"),
                                        );
                                    }
                                    __field4 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<i64>(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("id")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("created_at")?
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("user_id")?
                            }
                        };
                        let __field3 = match __field3 {
                            _serde::__private::Some(__field3) => __field3,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("event_id")?
                            }
                        };
                        let __field4 = match __field4 {
                            _serde::__private::Some(__field4) => __field4,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("amount")?
                            }
                        };
                        _serde::__private::Ok(UserNftTransfer {
                            id: __field0,
                            created_at: __field1,
                            user_id: __field2,
                            event_id: __field3,
                            amount: __field4,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "id",
                    "created_at",
                    "user_id",
                    "event_id",
                    "amount",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "UserNftTransfer",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<UserNftTransfer>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for UserNftTransfer {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "UserNftTransfer",
                    false as usize + 1 + 1 + 1 + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "id",
                    &self.id,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "created_at",
                    &self.created_at,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "user_id",
                    &self.user_id,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "event_id",
                    &self.event_id,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "amount",
                    &self.amount,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[automatically_derived]
    impl ::core::default::Default for UserNftTransfer {
        #[inline]
        fn default() -> UserNftTransfer {
            UserNftTransfer {
                id: ::core::default::Default::default(),
                created_at: ::core::default::Default::default(),
                user_id: ::core::default::Default::default(),
                event_id: ::core::default::Default::default(),
                amount: ::core::default::Default::default(),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for UserNftTransfer {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for UserNftTransfer {
        #[inline]
        fn eq(&self, other: &UserNftTransfer) -> bool {
            self.id == other.id && self.created_at == other.created_at
                && self.user_id == other.user_id && self.event_id == other.event_id
                && self.amount == other.amount
        }
    }
    #[serde(rename_all = "snake_case")]
    pub enum UserNftTransferAction {
        Create(UserNftTransferCreateRequest),
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for UserNftTransferAction {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                UserNftTransferAction::Create(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Create",
                        &__self_0,
                    )
                }
            }
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for UserNftTransferAction {
        #[inline]
        fn clone(&self) -> UserNftTransferAction {
            match self {
                UserNftTransferAction::Create(__self_0) => {
                    UserNftTransferAction::Create(::core::clone::Clone::clone(__self_0))
                }
            }
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for UserNftTransferAction {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    UserNftTransferAction::Create(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "UserNftTransferAction",
                            0u32,
                            "create",
                            __field0,
                        )
                    }
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for UserNftTransferAction {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "variant identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::invalid_value(
                                        _serde::de::Unexpected::Unsigned(__value),
                                        &"variant index 0 <= i < 1",
                                    ),
                                )
                            }
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "create" => _serde::__private::Ok(__Field::__field0),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"create" => _serde::__private::Ok(__Field::__field0),
                            _ => {
                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<UserNftTransferAction>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = UserNftTransferAction;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "enum UserNftTransferAction",
                        )
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match _serde::de::EnumAccess::variant(__data)? {
                            (__Field::__field0, __variant) => {
                                _serde::__private::Result::map(
                                    _serde::de::VariantAccess::newtype_variant::<
                                        UserNftTransferCreateRequest,
                                    >(__variant),
                                    UserNftTransferAction::Create,
                                )
                            }
                        }
                    }
                }
                #[doc(hidden)]
                const VARIANTS: &'static [&'static str] = &["create"];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "UserNftTransferAction",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<UserNftTransferAction>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for UserNftTransferAction {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for UserNftTransferAction {
        #[inline]
        fn eq(&self, other: &UserNftTransferAction) -> bool {
            match (self, other) {
                (
                    UserNftTransferAction::Create(__self_0),
                    UserNftTransferAction::Create(__arg1_0),
                ) => __self_0 == __arg1_0,
            }
        }
    }
    pub struct UserNftTransferCreateRequest {
        pub amount: i64,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for UserNftTransferCreateRequest {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field1_finish(
                f,
                "UserNftTransferCreateRequest",
                "amount",
                &&self.amount,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for UserNftTransferCreateRequest {
        #[inline]
        fn clone(&self) -> UserNftTransferCreateRequest {
            UserNftTransferCreateRequest {
                amount: ::core::clone::Clone::clone(&self.amount),
            }
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for UserNftTransferCreateRequest {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "UserNftTransferCreateRequest",
                    false as usize + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "amount",
                    &self.amount,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for UserNftTransferCreateRequest {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "amount" => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"amount" => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<UserNftTransferCreateRequest>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = UserNftTransferCreateRequest;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct UserNftTransferCreateRequest",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            i64,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct UserNftTransferCreateRequest with 1 element",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(UserNftTransferCreateRequest {
                            amount: __field0,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<i64> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("amount"),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<i64>(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("amount")?
                            }
                        };
                        _serde::__private::Ok(UserNftTransferCreateRequest {
                            amount: __field0,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &["amount"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "UserNftTransferCreateRequest",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<
                            UserNftTransferCreateRequest,
                        >,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::default::Default for UserNftTransferCreateRequest {
        #[inline]
        fn default() -> UserNftTransferCreateRequest {
            UserNftTransferCreateRequest {
                amount: ::core::default::Default::default(),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for UserNftTransferCreateRequest {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for UserNftTransferCreateRequest {
        #[inline]
        fn eq(&self, other: &UserNftTransferCreateRequest) -> bool {
            self.amount == other.amount
        }
    }
    impl UserNftTransferClient {
        pub async fn act(
            &self,
            params: UserNftTransferAction,
        ) -> crate::Result<UserNftTransfer> {
            let path = ::alloc::__export::must_use({
                let res = ::alloc::fmt::format(format_args!("/"));
                res
            });
            let endpoint = ::alloc::__export::must_use({
                let res = ::alloc::fmt::format(
                    format_args!("{0}{1}", self.endpoint, path),
                );
                res
            });
            rest_api::post(&endpoint, params).await
        }
        pub async fn create(&self, amount: i64) -> crate::Result<UserNftTransfer> {
            let path = ::alloc::__export::must_use({
                let res = ::alloc::fmt::format(format_args!("/"));
                res
            });
            let endpoint = ::alloc::__export::must_use({
                let res = ::alloc::fmt::format(
                    format_args!("{0}{1}", self.endpoint, path),
                );
                res
            });
            let req = UserNftTransferAction::Create(UserNftTransferCreateRequest {
                amount,
            });
            rest_api::post(&endpoint, req).await
        }
    }
    pub struct UserNftTransferSummary {
        pub id: i64,
        pub created_at: i64,
        pub amount: i64,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for UserNftTransferSummary {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "UserNftTransferSummary",
                "id",
                &self.id,
                "created_at",
                &self.created_at,
                "amount",
                &&self.amount,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for UserNftTransferSummary {
        #[inline]
        fn clone(&self) -> UserNftTransferSummary {
            UserNftTransferSummary {
                id: ::core::clone::Clone::clone(&self.id),
                created_at: ::core::clone::Clone::clone(&self.created_at),
                amount: ::core::clone::Clone::clone(&self.amount),
            }
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for UserNftTransferSummary {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "UserNftTransferSummary",
                    false as usize + 1 + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "id",
                    &self.id,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "created_at",
                    &self.created_at,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "amount",
                    &self.amount,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for UserNftTransferSummary {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "id" => _serde::__private::Ok(__Field::__field0),
                            "created_at" => _serde::__private::Ok(__Field::__field1),
                            "amount" => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"id" => _serde::__private::Ok(__Field::__field0),
                            b"created_at" => _serde::__private::Ok(__Field::__field1),
                            b"amount" => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<UserNftTransferSummary>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = UserNftTransferSummary;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct UserNftTransferSummary",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            i64,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct UserNftTransferSummary with 3 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            i64,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct UserNftTransferSummary with 3 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match _serde::de::SeqAccess::next_element::<
                            i64,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct UserNftTransferSummary with 3 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(UserNftTransferSummary {
                            id: __field0,
                            created_at: __field1,
                            amount: __field2,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<i64> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<i64> = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<i64> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("id"),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<i64>(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "created_at",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<i64>(&mut __map)?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("amount"),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<i64>(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("id")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("created_at")?
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("amount")?
                            }
                        };
                        _serde::__private::Ok(UserNftTransferSummary {
                            id: __field0,
                            created_at: __field1,
                            amount: __field2,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &["id", "created_at", "amount"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "UserNftTransferSummary",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<UserNftTransferSummary>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::default::Default for UserNftTransferSummary {
        #[inline]
        fn default() -> UserNftTransferSummary {
            UserNftTransferSummary {
                id: ::core::default::Default::default(),
                created_at: ::core::default::Default::default(),
                amount: ::core::default::Default::default(),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for UserNftTransferSummary {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for UserNftTransferSummary {
        #[inline]
        fn eq(&self, other: &UserNftTransferSummary) -> bool {
            self.id == other.id && self.created_at == other.created_at
                && self.amount == other.amount
        }
    }
    impl From<UserNftTransfer> for UserNftTransferSummary {
        fn from(item: UserNftTransfer) -> Self {
            Self {
                id: item.id,
                created_at: item.created_at,
                amount: item.amount,
            }
        }
    }
    impl Into<UserNftTransfer> for UserNftTransferSummary {
        fn into(self) -> UserNftTransfer {
            UserNftTransfer {
                id: self.id,
                created_at: self.created_at,
                amount: self.amount,
                ..Default::default()
            }
        }
    }
    #[serde(rename_all = "kebab-case")]
    pub struct UserNftTransferQuery {
        #[serde(deserialize_with = "parse_size_of_user_nft_transfer_query", default)]
        pub size: usize,
        pub bookmark: Option<String>,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for UserNftTransferQuery {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(
                f,
                "UserNftTransferQuery",
                "size",
                &self.size,
                "bookmark",
                &&self.bookmark,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for UserNftTransferQuery {
        #[inline]
        fn clone(&self) -> UserNftTransferQuery {
            UserNftTransferQuery {
                size: ::core::clone::Clone::clone(&self.size),
                bookmark: ::core::clone::Clone::clone(&self.bookmark),
            }
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for UserNftTransferQuery {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "UserNftTransferQuery",
                    false as usize + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "size",
                    &self.size,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "bookmark",
                    &self.bookmark,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for UserNftTransferQuery {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "size" => _serde::__private::Ok(__Field::__field0),
                            "bookmark" => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"size" => _serde::__private::Ok(__Field::__field0),
                            b"bookmark" => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<UserNftTransferQuery>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = UserNftTransferQuery;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct UserNftTransferQuery",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match {
                            #[doc(hidden)]
                            struct __DeserializeWith<'de> {
                                value: usize,
                                phantom: _serde::__private::PhantomData<
                                    UserNftTransferQuery,
                                >,
                                lifetime: _serde::__private::PhantomData<&'de ()>,
                            }
                            #[automatically_derived]
                            impl<'de> _serde::Deserialize<'de>
                            for __DeserializeWith<'de> {
                                fn deserialize<__D>(
                                    __deserializer: __D,
                                ) -> _serde::__private::Result<Self, __D::Error>
                                where
                                    __D: _serde::Deserializer<'de>,
                                {
                                    _serde::__private::Ok(__DeserializeWith {
                                        value: parse_size_of_user_nft_transfer_query(
                                            __deserializer,
                                        )?,
                                        phantom: _serde::__private::PhantomData,
                                        lifetime: _serde::__private::PhantomData,
                                    })
                                }
                            }
                            _serde::__private::Option::map(
                                _serde::de::SeqAccess::next_element::<
                                    __DeserializeWith<'de>,
                                >(&mut __seq)?,
                                |__wrap| __wrap.value,
                            )
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                _serde::__private::Default::default()
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            Option<String>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct UserNftTransferQuery with 2 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(UserNftTransferQuery {
                            size: __field0,
                            bookmark: __field1,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<usize> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<Option<String>> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("size"),
                                        );
                                    }
                                    __field0 = _serde::__private::Some({
                                        #[doc(hidden)]
                                        struct __DeserializeWith<'de> {
                                            value: usize,
                                            phantom: _serde::__private::PhantomData<
                                                UserNftTransferQuery,
                                            >,
                                            lifetime: _serde::__private::PhantomData<&'de ()>,
                                        }
                                        #[automatically_derived]
                                        impl<'de> _serde::Deserialize<'de>
                                        for __DeserializeWith<'de> {
                                            fn deserialize<__D>(
                                                __deserializer: __D,
                                            ) -> _serde::__private::Result<Self, __D::Error>
                                            where
                                                __D: _serde::Deserializer<'de>,
                                            {
                                                _serde::__private::Ok(__DeserializeWith {
                                                    value: parse_size_of_user_nft_transfer_query(
                                                        __deserializer,
                                                    )?,
                                                    phantom: _serde::__private::PhantomData,
                                                    lifetime: _serde::__private::PhantomData,
                                                })
                                            }
                                        }
                                        match _serde::de::MapAccess::next_value::<
                                            __DeserializeWith<'de>,
                                        >(&mut __map) {
                                            _serde::__private::Ok(__wrapper) => __wrapper.value,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        }
                                    });
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "bookmark",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<String>,
                                        >(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::Default::default()
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("bookmark")?
                            }
                        };
                        _serde::__private::Ok(UserNftTransferQuery {
                            size: __field0,
                            bookmark: __field1,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &["size", "bookmark"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "UserNftTransferQuery",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<UserNftTransferQuery>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::default::Default for UserNftTransferQuery {
        #[inline]
        fn default() -> UserNftTransferQuery {
            UserNftTransferQuery {
                size: ::core::default::Default::default(),
                bookmark: ::core::default::Default::default(),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for UserNftTransferQuery {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for UserNftTransferQuery {
        #[inline]
        fn eq(&self, other: &UserNftTransferQuery) -> bool {
            self.size == other.size && self.bookmark == other.bookmark
        }
    }
    impl std::fmt::Display for UserNftTransferQuery {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let query = serde_urlencoded::to_string(&self).map_err(|_| std::fmt::Error)?;
            f.write_fmt(format_args!("{0}", query))
        }
    }
    pub fn parse_size_of_user_nft_transfer_query<'de, D>(
        deserializer: D,
    ) -> std::result::Result<usize, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::Deserialize;
        let s: Option<String> = Option::deserialize(deserializer)?;
        s.unwrap_or_else(|| Default::default())
            .parse::<usize>()
            .map_err(serde::de::Error::custom)
    }
    impl UserNftTransferQuery {
        pub fn new(size: usize) -> Self {
            Self { size, ..Self::default() }
        }
        pub fn with_bookmark(mut self, bookmark: String) -> Self {
            self.bookmark = Some(bookmark);
            self
        }
        pub fn with_page(mut self, page: usize) -> Self {
            self.bookmark = Some(page.to_string());
            self
        }
        /// Returns the size(i32) of the query
        pub fn size(&self) -> i32 {
            self.size as i32
        }
        pub fn page(&self) -> i32 {
            self.bookmark.as_ref().unwrap_or(&"1".to_string()).parse().unwrap_or(1)
        }
    }
    impl UserNftTransferClient {}
    impl UserNftTransfer {
        pub fn get_client(endpoint: &str) -> UserNftTransferClient {
            UserNftTransferClient {
                endpoint: endpoint.to_string(),
            }
        }
    }
    pub struct UserNftTransferClient {
        pub endpoint: String,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for UserNftTransferClient {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field1_finish(
                f,
                "UserNftTransferClient",
                "endpoint",
                &&self.endpoint,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for UserNftTransferClient {
        #[inline]
        fn clone(&self) -> UserNftTransferClient {
            UserNftTransferClient {
                endpoint: ::core::clone::Clone::clone(&self.endpoint),
            }
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for UserNftTransferClient {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "UserNftTransferClient",
                    false as usize + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "endpoint",
                    &self.endpoint,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for UserNftTransferClient {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "endpoint" => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"endpoint" => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<UserNftTransferClient>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = UserNftTransferClient;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct UserNftTransferClient",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct UserNftTransferClient with 1 element",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(UserNftTransferClient {
                            endpoint: __field0,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "endpoint",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("endpoint")?
                            }
                        };
                        _serde::__private::Ok(UserNftTransferClient {
                            endpoint: __field0,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &["endpoint"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "UserNftTransferClient",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<UserNftTransferClient>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::default::Default for UserNftTransferClient {
        #[inline]
        fn default() -> UserNftTransferClient {
            UserNftTransferClient {
                endpoint: ::core::default::Default::default(),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for UserNftTransferClient {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for UserNftTransferClient {
        #[inline]
        fn eq(&self, other: &UserNftTransferClient) -> bool {
            self.endpoint == other.endpoint
        }
    }
    impl UserNftTransferClient {
        pub async fn query(
            &self,
            params: UserNftTransferQuery,
        ) -> crate::Result<by_types::QueryResponse<UserNftTransferSummary>> {
            let path = ::alloc::__export::must_use({
                let res = ::alloc::fmt::format(format_args!("/"));
                res
            });
            let endpoint = ::alloc::__export::must_use({
                let res = ::alloc::fmt::format(
                    format_args!("{0}{1}", self.endpoint, path),
                );
                res
            });
            let query = ::alloc::__export::must_use({
                let res = ::alloc::fmt::format(
                    format_args!(
                        "{0}?{1}",
                        endpoint,
                        UserNftTransferParam::Query(params),
                    ),
                );
                res
            });
            rest_api::get(&query).await
        }
        pub async fn get(&self, id: i64) -> crate::Result<UserNftTransfer> {
            let path = ::alloc::__export::must_use({
                let res = ::alloc::fmt::format(format_args!("/"));
                res
            });
            let endpoint = ::alloc::__export::must_use({
                let res = ::alloc::fmt::format(
                    format_args!("{0}{1}/{2}", self.endpoint, path, id),
                );
                res
            });
            rest_api::get(&endpoint).await
        }
    }
    impl UserNftTransfer {
        pub fn url() -> String {
            "/".to_string()
        }
    }
    pub struct UserNftTransferReadAction {}
    #[automatically_derived]
    impl ::core::fmt::Debug for UserNftTransferReadAction {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "UserNftTransferReadAction")
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for UserNftTransferReadAction {
        #[inline]
        fn clone(&self) -> UserNftTransferReadAction {
            UserNftTransferReadAction {}
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for UserNftTransferReadAction {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "UserNftTransferReadAction",
                    false as usize,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for UserNftTransferReadAction {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<UserNftTransferReadAction>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = UserNftTransferReadAction;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct UserNftTransferReadAction",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        _: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        _serde::__private::Ok(UserNftTransferReadAction {})
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        _serde::__private::Ok(UserNftTransferReadAction {})
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "UserNftTransferReadAction",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<
                            UserNftTransferReadAction,
                        >,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::default::Default for UserNftTransferReadAction {
        #[inline]
        fn default() -> UserNftTransferReadAction {
            UserNftTransferReadAction {}
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for UserNftTransferReadAction {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for UserNftTransferReadAction {
        #[inline]
        fn eq(&self, other: &UserNftTransferReadAction) -> bool {
            true
        }
    }
    impl std::fmt::Display for UserNftTransferReadAction {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let query = serde_urlencoded::to_string(&self).map_err(|_| std::fmt::Error)?;
            f.write_fmt(format_args!("{0}", query))
        }
    }
    impl UserNftTransferReadAction {
        pub fn new() -> Self {
            Self::default()
        }
    }
    impl UserNftTransferClient {}
    #[serde(tag = "param-type", rename_all = "kebab-case")]
    pub enum UserNftTransferParam {
        Query(UserNftTransferQuery),
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for UserNftTransferParam {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                UserNftTransferParam::Query(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Query",
                        &__self_0,
                    )
                }
            }
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for UserNftTransferParam {
        #[inline]
        fn clone(&self) -> UserNftTransferParam {
            match self {
                UserNftTransferParam::Query(__self_0) => {
                    UserNftTransferParam::Query(::core::clone::Clone::clone(__self_0))
                }
            }
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for UserNftTransferParam {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    UserNftTransferParam::Query(ref __field0) => {
                        _serde::__private::ser::serialize_tagged_newtype(
                            __serializer,
                            "UserNftTransferParam",
                            "Query",
                            "param-type",
                            "query",
                            __field0,
                        )
                    }
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for UserNftTransferParam {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "variant identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::invalid_value(
                                        _serde::de::Unexpected::Unsigned(__value),
                                        &"variant index 0 <= i < 1",
                                    ),
                                )
                            }
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "query" => _serde::__private::Ok(__Field::__field0),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"query" => _serde::__private::Ok(__Field::__field0),
                            _ => {
                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                const VARIANTS: &'static [&'static str] = &["query"];
                let (__tag, __content) = _serde::Deserializer::deserialize_any(
                    __deserializer,
                    _serde::__private::de::TaggedContentVisitor::<
                        __Field,
                    >::new("param-type", "internally tagged enum UserNftTransferParam"),
                )?;
                let __deserializer = _serde::__private::de::ContentDeserializer::<
                    __D::Error,
                >::new(__content);
                match __tag {
                    __Field::__field0 => {
                        _serde::__private::Result::map(
                            <UserNftTransferQuery as _serde::Deserialize>::deserialize(
                                __deserializer,
                            ),
                            UserNftTransferParam::Query,
                        )
                    }
                }
            }
        }
    };
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for UserNftTransferParam {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for UserNftTransferParam {
        #[inline]
        fn eq(&self, other: &UserNftTransferParam) -> bool {
            match (self, other) {
                (
                    UserNftTransferParam::Query(__self_0),
                    UserNftTransferParam::Query(__arg1_0),
                ) => __self_0 == __arg1_0,
            }
        }
    }
    impl std::fmt::Display for UserNftTransferParam {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let query = serde_urlencoded::to_string(&self).map_err(|_| std::fmt::Error)?;
            f.write_fmt(format_args!("{0}", query))
        }
    }
    #[serde(tag = "param_type")]
    #[serde(rename_all = "snake_case")]
    pub enum UserNftTransferGetResponse {
        Query(by_types::QueryResponse<UserNftTransferSummary>),
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for UserNftTransferGetResponse {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                UserNftTransferGetResponse::Query(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Query",
                        &__self_0,
                    )
                }
            }
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for UserNftTransferGetResponse {
        #[inline]
        fn clone(&self) -> UserNftTransferGetResponse {
            match self {
                UserNftTransferGetResponse::Query(__self_0) => {
                    UserNftTransferGetResponse::Query(
                        ::core::clone::Clone::clone(__self_0),
                    )
                }
            }
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for UserNftTransferGetResponse {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    UserNftTransferGetResponse::Query(ref __field0) => {
                        _serde::__private::ser::serialize_tagged_newtype(
                            __serializer,
                            "UserNftTransferGetResponse",
                            "Query",
                            "param_type",
                            "query",
                            __field0,
                        )
                    }
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for UserNftTransferGetResponse {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "variant identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::invalid_value(
                                        _serde::de::Unexpected::Unsigned(__value),
                                        &"variant index 0 <= i < 1",
                                    ),
                                )
                            }
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "query" => _serde::__private::Ok(__Field::__field0),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"query" => _serde::__private::Ok(__Field::__field0),
                            _ => {
                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                const VARIANTS: &'static [&'static str] = &["query"];
                let (__tag, __content) = _serde::Deserializer::deserialize_any(
                    __deserializer,
                    _serde::__private::de::TaggedContentVisitor::<
                        __Field,
                    >::new(
                        "param_type",
                        "internally tagged enum UserNftTransferGetResponse",
                    ),
                )?;
                let __deserializer = _serde::__private::de::ContentDeserializer::<
                    __D::Error,
                >::new(__content);
                match __tag {
                    __Field::__field0 => {
                        _serde::__private::Result::map(
                            <by_types::QueryResponse<
                                UserNftTransferSummary,
                            > as _serde::Deserialize>::deserialize(__deserializer),
                            UserNftTransferGetResponse::Query,
                        )
                    }
                }
            }
        }
    };
    impl Event {
        pub fn generate_sort_key(
            timestamp_diff: u64,
            tx_index: u64,
            log_index: u64,
        ) -> u64 {
            let mut sort_key = 0u64;
            sort_key |= timestamp_diff << 16;
            sort_key |= tx_index << 8;
            sort_key |= log_index;
            sort_key
        }
    }
}
pub mod feepayer {
    use by_macros::api_model;
    use ethers::types::{Signature, U256};
    use crate::contracts::klaytn_transaction::KlaytnTransaction;
    /// FeePayerAddress is a generated struct that represents the model
    ///
    /// For making API calls related to this model, use `FeePayerAddress::get_client(endpoint: &str)`.
    /// It will returns FeePayerAddressClient struct that implements the API calls.
    ///
    /// In server side, you can use `FeePayerAddress::get_repository()` to interact with the database.
    /// Recommend to use `FeePayerAddressRepository` to insert or update the model.
    /// To query the model, use `FeePayerAddress::query_builder()`.
    /// For more detail, refer to the documentation of the query builder.
    pub struct FeePayerAddress {
        pub address: String,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for FeePayerAddress {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field1_finish(
                f,
                "FeePayerAddress",
                "address",
                &&self.address,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for FeePayerAddress {
        #[inline]
        fn clone(&self) -> FeePayerAddress {
            FeePayerAddress {
                address: ::core::clone::Clone::clone(&self.address),
            }
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for FeePayerAddress {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "address" => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"address" => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<FeePayerAddress>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = FeePayerAddress;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct FeePayerAddress",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct FeePayerAddress with 1 element",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(FeePayerAddress {
                            address: __field0,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "address",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("address")?
                            }
                        };
                        _serde::__private::Ok(FeePayerAddress {
                            address: __field0,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &["address"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "FeePayerAddress",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<FeePayerAddress>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for FeePayerAddress {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "FeePayerAddress",
                    false as usize + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "address",
                    &self.address,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[automatically_derived]
    impl ::core::default::Default for FeePayerAddress {
        #[inline]
        fn default() -> FeePayerAddress {
            FeePayerAddress {
                address: ::core::default::Default::default(),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for FeePayerAddress {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for FeePayerAddress {
        #[inline]
        fn eq(&self, other: &FeePayerAddress) -> bool {
            self.address == other.address
        }
    }
    pub struct FeePayerAddressSummary {}
    #[automatically_derived]
    impl ::core::fmt::Debug for FeePayerAddressSummary {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "FeePayerAddressSummary")
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for FeePayerAddressSummary {
        #[inline]
        fn clone(&self) -> FeePayerAddressSummary {
            FeePayerAddressSummary {}
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for FeePayerAddressSummary {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "FeePayerAddressSummary",
                    false as usize,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for FeePayerAddressSummary {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<FeePayerAddressSummary>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = FeePayerAddressSummary;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct FeePayerAddressSummary",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        _: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        _serde::__private::Ok(FeePayerAddressSummary {})
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        _serde::__private::Ok(FeePayerAddressSummary {})
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "FeePayerAddressSummary",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<FeePayerAddressSummary>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::default::Default for FeePayerAddressSummary {
        #[inline]
        fn default() -> FeePayerAddressSummary {
            FeePayerAddressSummary {}
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for FeePayerAddressSummary {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for FeePayerAddressSummary {
        #[inline]
        fn eq(&self, other: &FeePayerAddressSummary) -> bool {
            true
        }
    }
    impl From<FeePayerAddress> for FeePayerAddressSummary {
        fn from(item: FeePayerAddress) -> Self {
            Self {}
        }
    }
    impl Into<FeePayerAddress> for FeePayerAddressSummary {
        fn into(self) -> FeePayerAddress {
            FeePayerAddress {
                ..Default::default()
            }
        }
    }
    #[serde(rename_all = "kebab-case")]
    pub struct FeePayerAddressQuery {
        #[serde(deserialize_with = "parse_size_of_fee_payer_address_query", default)]
        pub size: usize,
        pub bookmark: Option<String>,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for FeePayerAddressQuery {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(
                f,
                "FeePayerAddressQuery",
                "size",
                &self.size,
                "bookmark",
                &&self.bookmark,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for FeePayerAddressQuery {
        #[inline]
        fn clone(&self) -> FeePayerAddressQuery {
            FeePayerAddressQuery {
                size: ::core::clone::Clone::clone(&self.size),
                bookmark: ::core::clone::Clone::clone(&self.bookmark),
            }
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for FeePayerAddressQuery {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "FeePayerAddressQuery",
                    false as usize + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "size",
                    &self.size,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "bookmark",
                    &self.bookmark,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for FeePayerAddressQuery {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "size" => _serde::__private::Ok(__Field::__field0),
                            "bookmark" => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"size" => _serde::__private::Ok(__Field::__field0),
                            b"bookmark" => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<FeePayerAddressQuery>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = FeePayerAddressQuery;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct FeePayerAddressQuery",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match {
                            #[doc(hidden)]
                            struct __DeserializeWith<'de> {
                                value: usize,
                                phantom: _serde::__private::PhantomData<
                                    FeePayerAddressQuery,
                                >,
                                lifetime: _serde::__private::PhantomData<&'de ()>,
                            }
                            #[automatically_derived]
                            impl<'de> _serde::Deserialize<'de>
                            for __DeserializeWith<'de> {
                                fn deserialize<__D>(
                                    __deserializer: __D,
                                ) -> _serde::__private::Result<Self, __D::Error>
                                where
                                    __D: _serde::Deserializer<'de>,
                                {
                                    _serde::__private::Ok(__DeserializeWith {
                                        value: parse_size_of_fee_payer_address_query(
                                            __deserializer,
                                        )?,
                                        phantom: _serde::__private::PhantomData,
                                        lifetime: _serde::__private::PhantomData,
                                    })
                                }
                            }
                            _serde::__private::Option::map(
                                _serde::de::SeqAccess::next_element::<
                                    __DeserializeWith<'de>,
                                >(&mut __seq)?,
                                |__wrap| __wrap.value,
                            )
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                _serde::__private::Default::default()
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            Option<String>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct FeePayerAddressQuery with 2 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(FeePayerAddressQuery {
                            size: __field0,
                            bookmark: __field1,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<usize> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<Option<String>> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("size"),
                                        );
                                    }
                                    __field0 = _serde::__private::Some({
                                        #[doc(hidden)]
                                        struct __DeserializeWith<'de> {
                                            value: usize,
                                            phantom: _serde::__private::PhantomData<
                                                FeePayerAddressQuery,
                                            >,
                                            lifetime: _serde::__private::PhantomData<&'de ()>,
                                        }
                                        #[automatically_derived]
                                        impl<'de> _serde::Deserialize<'de>
                                        for __DeserializeWith<'de> {
                                            fn deserialize<__D>(
                                                __deserializer: __D,
                                            ) -> _serde::__private::Result<Self, __D::Error>
                                            where
                                                __D: _serde::Deserializer<'de>,
                                            {
                                                _serde::__private::Ok(__DeserializeWith {
                                                    value: parse_size_of_fee_payer_address_query(
                                                        __deserializer,
                                                    )?,
                                                    phantom: _serde::__private::PhantomData,
                                                    lifetime: _serde::__private::PhantomData,
                                                })
                                            }
                                        }
                                        match _serde::de::MapAccess::next_value::<
                                            __DeserializeWith<'de>,
                                        >(&mut __map) {
                                            _serde::__private::Ok(__wrapper) => __wrapper.value,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        }
                                    });
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "bookmark",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<String>,
                                        >(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::Default::default()
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("bookmark")?
                            }
                        };
                        _serde::__private::Ok(FeePayerAddressQuery {
                            size: __field0,
                            bookmark: __field1,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &["size", "bookmark"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "FeePayerAddressQuery",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<FeePayerAddressQuery>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::default::Default for FeePayerAddressQuery {
        #[inline]
        fn default() -> FeePayerAddressQuery {
            FeePayerAddressQuery {
                size: ::core::default::Default::default(),
                bookmark: ::core::default::Default::default(),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for FeePayerAddressQuery {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for FeePayerAddressQuery {
        #[inline]
        fn eq(&self, other: &FeePayerAddressQuery) -> bool {
            self.size == other.size && self.bookmark == other.bookmark
        }
    }
    impl std::fmt::Display for FeePayerAddressQuery {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let query = serde_urlencoded::to_string(&self).map_err(|_| std::fmt::Error)?;
            f.write_fmt(format_args!("{0}", query))
        }
    }
    pub fn parse_size_of_fee_payer_address_query<'de, D>(
        deserializer: D,
    ) -> std::result::Result<usize, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::Deserialize;
        let s: Option<String> = Option::deserialize(deserializer)?;
        s.unwrap_or_else(|| Default::default())
            .parse::<usize>()
            .map_err(serde::de::Error::custom)
    }
    impl FeePayerAddressQuery {
        pub fn new(size: usize) -> Self {
            Self { size, ..Self::default() }
        }
        pub fn with_bookmark(mut self, bookmark: String) -> Self {
            self.bookmark = Some(bookmark);
            self
        }
        pub fn with_page(mut self, page: usize) -> Self {
            self.bookmark = Some(page.to_string());
            self
        }
        /// Returns the size(i32) of the query
        pub fn size(&self) -> i32 {
            self.size as i32
        }
        pub fn page(&self) -> i32 {
            self.bookmark.as_ref().unwrap_or(&"1".to_string()).parse().unwrap_or(1)
        }
    }
    impl FeePayerAddressClient {}
    impl FeePayerAddress {
        pub fn get_client(endpoint: &str) -> FeePayerAddressClient {
            FeePayerAddressClient {
                endpoint: endpoint.to_string(),
            }
        }
    }
    pub struct FeePayerAddressClient {
        pub endpoint: String,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for FeePayerAddressClient {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field1_finish(
                f,
                "FeePayerAddressClient",
                "endpoint",
                &&self.endpoint,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for FeePayerAddressClient {
        #[inline]
        fn clone(&self) -> FeePayerAddressClient {
            FeePayerAddressClient {
                endpoint: ::core::clone::Clone::clone(&self.endpoint),
            }
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for FeePayerAddressClient {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "FeePayerAddressClient",
                    false as usize + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "endpoint",
                    &self.endpoint,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for FeePayerAddressClient {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "endpoint" => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"endpoint" => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<FeePayerAddressClient>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = FeePayerAddressClient;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct FeePayerAddressClient",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct FeePayerAddressClient with 1 element",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(FeePayerAddressClient {
                            endpoint: __field0,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "endpoint",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("endpoint")?
                            }
                        };
                        _serde::__private::Ok(FeePayerAddressClient {
                            endpoint: __field0,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &["endpoint"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "FeePayerAddressClient",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<FeePayerAddressClient>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::default::Default for FeePayerAddressClient {
        #[inline]
        fn default() -> FeePayerAddressClient {
            FeePayerAddressClient {
                endpoint: ::core::default::Default::default(),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for FeePayerAddressClient {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for FeePayerAddressClient {
        #[inline]
        fn eq(&self, other: &FeePayerAddressClient) -> bool {
            self.endpoint == other.endpoint
        }
    }
    impl FeePayerAddressClient {
        pub async fn query(
            &self,
            params: FeePayerAddressQuery,
        ) -> crate::Result<by_types::QueryResponse<FeePayerAddressSummary>> {
            let path = ::alloc::__export::must_use({
                let res = ::alloc::fmt::format(format_args!("/v1/fee-payer"));
                res
            });
            let endpoint = ::alloc::__export::must_use({
                let res = ::alloc::fmt::format(
                    format_args!("{0}{1}", self.endpoint, path),
                );
                res
            });
            let query = ::alloc::__export::must_use({
                let res = ::alloc::fmt::format(
                    format_args!(
                        "{0}?{1}",
                        endpoint,
                        FeePayerAddressParam::Query(params),
                    ),
                );
                res
            });
            rest_api::get(&query).await
        }
        pub async fn get(&self, id: i64) -> crate::Result<FeePayerAddress> {
            let path = ::alloc::__export::must_use({
                let res = ::alloc::fmt::format(format_args!("/v1/fee-payer"));
                res
            });
            let endpoint = ::alloc::__export::must_use({
                let res = ::alloc::fmt::format(
                    format_args!("{0}{1}/{2}", self.endpoint, path, id),
                );
                res
            });
            rest_api::get(&endpoint).await
        }
    }
    impl FeePayerAddress {
        pub fn url() -> String {
            "/v1/fee-payer".to_string()
        }
    }
    pub struct FeePayerAddressReadAction {
        pub action: Option<FeePayerAddressReadActionType>,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for FeePayerAddressReadAction {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field1_finish(
                f,
                "FeePayerAddressReadAction",
                "action",
                &&self.action,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for FeePayerAddressReadAction {
        #[inline]
        fn clone(&self) -> FeePayerAddressReadAction {
            FeePayerAddressReadAction {
                action: ::core::clone::Clone::clone(&self.action),
            }
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for FeePayerAddressReadAction {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "FeePayerAddressReadAction",
                    false as usize + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "action",
                    &self.action,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for FeePayerAddressReadAction {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "action" => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"action" => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<FeePayerAddressReadAction>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = FeePayerAddressReadAction;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct FeePayerAddressReadAction",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            Option<FeePayerAddressReadActionType>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct FeePayerAddressReadAction with 1 element",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(FeePayerAddressReadAction {
                            action: __field0,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<
                            Option<FeePayerAddressReadActionType>,
                        > = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("action"),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<FeePayerAddressReadActionType>,
                                        >(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("action")?
                            }
                        };
                        _serde::__private::Ok(FeePayerAddressReadAction {
                            action: __field0,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &["action"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "FeePayerAddressReadAction",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<
                            FeePayerAddressReadAction,
                        >,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::default::Default for FeePayerAddressReadAction {
        #[inline]
        fn default() -> FeePayerAddressReadAction {
            FeePayerAddressReadAction {
                action: ::core::default::Default::default(),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for FeePayerAddressReadAction {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for FeePayerAddressReadAction {
        #[inline]
        fn eq(&self, other: &FeePayerAddressReadAction) -> bool {
            self.action == other.action
        }
    }
    impl std::fmt::Display for FeePayerAddressReadAction {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let query = serde_urlencoded::to_string(&self).map_err(|_| std::fmt::Error)?;
            f.write_fmt(format_args!("{0}", query))
        }
    }
    impl FeePayerAddressReadAction {
        pub fn new() -> Self {
            Self::default()
        }
        pub fn get_fee_payer(mut self) -> Self {
            self.action = Some(FeePayerAddressReadActionType::GetFeePayer);
            self
        }
    }
    #[serde(rename_all = "kebab-case")]
    pub enum FeePayerAddressReadActionType {
        GetFeePayer,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for FeePayerAddressReadActionType {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "GetFeePayer")
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for FeePayerAddressReadActionType {
        #[inline]
        fn clone(&self) -> FeePayerAddressReadActionType {
            FeePayerAddressReadActionType::GetFeePayer
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for FeePayerAddressReadActionType {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for FeePayerAddressReadActionType {
        #[inline]
        fn eq(&self, other: &FeePayerAddressReadActionType) -> bool {
            true
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for FeePayerAddressReadActionType {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    FeePayerAddressReadActionType::GetFeePayer => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "FeePayerAddressReadActionType",
                            0u32,
                            "get-fee-payer",
                        )
                    }
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for FeePayerAddressReadActionType {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "variant identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::invalid_value(
                                        _serde::de::Unexpected::Unsigned(__value),
                                        &"variant index 0 <= i < 1",
                                    ),
                                )
                            }
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "get-fee-payer" => _serde::__private::Ok(__Field::__field0),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"get-fee-payer" => _serde::__private::Ok(__Field::__field0),
                            _ => {
                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<
                        FeePayerAddressReadActionType,
                    >,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = FeePayerAddressReadActionType;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "enum FeePayerAddressReadActionType",
                        )
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match _serde::de::EnumAccess::variant(__data)? {
                            (__Field::__field0, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(
                                    FeePayerAddressReadActionType::GetFeePayer,
                                )
                            }
                        }
                    }
                }
                #[doc(hidden)]
                const VARIANTS: &'static [&'static str] = &["get-fee-payer"];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "FeePayerAddressReadActionType",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<
                            FeePayerAddressReadActionType,
                        >,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    impl FeePayerAddressClient {
        pub async fn get_fee_payer(&self) -> crate::Result<FeePayerAddress> {
            let path = ::alloc::__export::must_use({
                let res = ::alloc::fmt::format(format_args!("/v1/fee-payer"));
                res
            });
            let endpoint = ::alloc::__export::must_use({
                let res = ::alloc::fmt::format(
                    format_args!("{0}{1}", self.endpoint, path),
                );
                res
            });
            let params = FeePayerAddressReadAction::new().get_fee_payer();
            let query = ::alloc::__export::must_use({
                let res = ::alloc::fmt::format(
                    format_args!("{0}?{1}", endpoint, FeePayerAddressParam::Read(params)),
                );
                res
            });
            rest_api::get(&query).await
        }
    }
    #[serde(tag = "param-type", rename_all = "kebab-case")]
    pub enum FeePayerAddressParam {
        Query(FeePayerAddressQuery),
        Read(FeePayerAddressReadAction),
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for FeePayerAddressParam {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                FeePayerAddressParam::Query(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Query",
                        &__self_0,
                    )
                }
                FeePayerAddressParam::Read(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Read",
                        &__self_0,
                    )
                }
            }
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for FeePayerAddressParam {
        #[inline]
        fn clone(&self) -> FeePayerAddressParam {
            match self {
                FeePayerAddressParam::Query(__self_0) => {
                    FeePayerAddressParam::Query(::core::clone::Clone::clone(__self_0))
                }
                FeePayerAddressParam::Read(__self_0) => {
                    FeePayerAddressParam::Read(::core::clone::Clone::clone(__self_0))
                }
            }
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for FeePayerAddressParam {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    FeePayerAddressParam::Query(ref __field0) => {
                        _serde::__private::ser::serialize_tagged_newtype(
                            __serializer,
                            "FeePayerAddressParam",
                            "Query",
                            "param-type",
                            "query",
                            __field0,
                        )
                    }
                    FeePayerAddressParam::Read(ref __field0) => {
                        _serde::__private::ser::serialize_tagged_newtype(
                            __serializer,
                            "FeePayerAddressParam",
                            "Read",
                            "param-type",
                            "read",
                            __field0,
                        )
                    }
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for FeePayerAddressParam {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "variant identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::invalid_value(
                                        _serde::de::Unexpected::Unsigned(__value),
                                        &"variant index 0 <= i < 2",
                                    ),
                                )
                            }
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "query" => _serde::__private::Ok(__Field::__field0),
                            "read" => _serde::__private::Ok(__Field::__field1),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"query" => _serde::__private::Ok(__Field::__field0),
                            b"read" => _serde::__private::Ok(__Field::__field1),
                            _ => {
                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                const VARIANTS: &'static [&'static str] = &["query", "read"];
                let (__tag, __content) = _serde::Deserializer::deserialize_any(
                    __deserializer,
                    _serde::__private::de::TaggedContentVisitor::<
                        __Field,
                    >::new("param-type", "internally tagged enum FeePayerAddressParam"),
                )?;
                let __deserializer = _serde::__private::de::ContentDeserializer::<
                    __D::Error,
                >::new(__content);
                match __tag {
                    __Field::__field0 => {
                        _serde::__private::Result::map(
                            <FeePayerAddressQuery as _serde::Deserialize>::deserialize(
                                __deserializer,
                            ),
                            FeePayerAddressParam::Query,
                        )
                    }
                    __Field::__field1 => {
                        _serde::__private::Result::map(
                            <FeePayerAddressReadAction as _serde::Deserialize>::deserialize(
                                __deserializer,
                            ),
                            FeePayerAddressParam::Read,
                        )
                    }
                }
            }
        }
    };
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for FeePayerAddressParam {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for FeePayerAddressParam {
        #[inline]
        fn eq(&self, other: &FeePayerAddressParam) -> bool {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            let __arg1_discr = ::core::intrinsics::discriminant_value(other);
            __self_discr == __arg1_discr
                && match (self, other) {
                    (
                        FeePayerAddressParam::Query(__self_0),
                        FeePayerAddressParam::Query(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (
                        FeePayerAddressParam::Read(__self_0),
                        FeePayerAddressParam::Read(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    _ => unsafe { ::core::intrinsics::unreachable() }
                }
        }
    }
    impl std::fmt::Display for FeePayerAddressParam {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let query = serde_urlencoded::to_string(&self).map_err(|_| std::fmt::Error)?;
            f.write_fmt(format_args!("{0}", query))
        }
    }
    #[serde(tag = "param_type")]
    #[serde(rename_all = "snake_case")]
    pub enum FeePayerAddressGetResponse {
        Query(by_types::QueryResponse<FeePayerAddress>),
        Read(FeePayerAddress),
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for FeePayerAddressGetResponse {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                FeePayerAddressGetResponse::Query(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Query",
                        &__self_0,
                    )
                }
                FeePayerAddressGetResponse::Read(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Read",
                        &__self_0,
                    )
                }
            }
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for FeePayerAddressGetResponse {
        #[inline]
        fn clone(&self) -> FeePayerAddressGetResponse {
            match self {
                FeePayerAddressGetResponse::Query(__self_0) => {
                    FeePayerAddressGetResponse::Query(
                        ::core::clone::Clone::clone(__self_0),
                    )
                }
                FeePayerAddressGetResponse::Read(__self_0) => {
                    FeePayerAddressGetResponse::Read(
                        ::core::clone::Clone::clone(__self_0),
                    )
                }
            }
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for FeePayerAddressGetResponse {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    FeePayerAddressGetResponse::Query(ref __field0) => {
                        _serde::__private::ser::serialize_tagged_newtype(
                            __serializer,
                            "FeePayerAddressGetResponse",
                            "Query",
                            "param_type",
                            "query",
                            __field0,
                        )
                    }
                    FeePayerAddressGetResponse::Read(ref __field0) => {
                        _serde::__private::ser::serialize_tagged_newtype(
                            __serializer,
                            "FeePayerAddressGetResponse",
                            "Read",
                            "param_type",
                            "read",
                            __field0,
                        )
                    }
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for FeePayerAddressGetResponse {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "variant identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::invalid_value(
                                        _serde::de::Unexpected::Unsigned(__value),
                                        &"variant index 0 <= i < 2",
                                    ),
                                )
                            }
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "query" => _serde::__private::Ok(__Field::__field0),
                            "read" => _serde::__private::Ok(__Field::__field1),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"query" => _serde::__private::Ok(__Field::__field0),
                            b"read" => _serde::__private::Ok(__Field::__field1),
                            _ => {
                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                const VARIANTS: &'static [&'static str] = &["query", "read"];
                let (__tag, __content) = _serde::Deserializer::deserialize_any(
                    __deserializer,
                    _serde::__private::de::TaggedContentVisitor::<
                        __Field,
                    >::new(
                        "param_type",
                        "internally tagged enum FeePayerAddressGetResponse",
                    ),
                )?;
                let __deserializer = _serde::__private::de::ContentDeserializer::<
                    __D::Error,
                >::new(__content);
                match __tag {
                    __Field::__field0 => {
                        _serde::__private::Result::map(
                            <by_types::QueryResponse<
                                FeePayerAddress,
                            > as _serde::Deserialize>::deserialize(__deserializer),
                            FeePayerAddressGetResponse::Query,
                        )
                    }
                    __Field::__field1 => {
                        _serde::__private::Result::map(
                            <FeePayerAddress as _serde::Deserialize>::deserialize(
                                __deserializer,
                            ),
                            FeePayerAddressGetResponse::Read,
                        )
                    }
                }
            }
        }
    };
    /// FeePayerSignature is a generated struct that represents the model
    ///
    /// For making API calls related to this model, use `FeePayerSignature::get_client(endpoint: &str)`.
    /// It will returns FeePayerSignatureClient struct that implements the API calls.
    ///
    /// In server side, you can use `FeePayerSignature::get_repository()` to interact with the database.
    /// Recommend to use `FeePayerSignatureRepository` to insert or update the model.
    /// To query the model, use `FeePayerSignature::query_builder()`.
    /// For more detail, refer to the documentation of the query builder.
    pub struct FeePayerSignature {
        pub r: Vec<u64>,
        pub s: Vec<u64>,
        pub v: u64,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for FeePayerSignature {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "FeePayerSignature",
                "r",
                &self.r,
                "s",
                &self.s,
                "v",
                &&self.v,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for FeePayerSignature {
        #[inline]
        fn clone(&self) -> FeePayerSignature {
            FeePayerSignature {
                r: ::core::clone::Clone::clone(&self.r),
                s: ::core::clone::Clone::clone(&self.s),
                v: ::core::clone::Clone::clone(&self.v),
            }
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for FeePayerSignature {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "r" => _serde::__private::Ok(__Field::__field0),
                            "s" => _serde::__private::Ok(__Field::__field1),
                            "v" => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"r" => _serde::__private::Ok(__Field::__field0),
                            b"s" => _serde::__private::Ok(__Field::__field1),
                            b"v" => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<FeePayerSignature>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = FeePayerSignature;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct FeePayerSignature",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            Vec<u64>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct FeePayerSignature with 3 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            Vec<u64>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct FeePayerSignature with 3 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match _serde::de::SeqAccess::next_element::<
                            u64,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct FeePayerSignature with 3 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(FeePayerSignature {
                            r: __field0,
                            s: __field1,
                            v: __field2,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<Vec<u64>> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<Vec<u64>> = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<u64> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("r"),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<Vec<u64>>(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("s"),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<Vec<u64>>(&mut __map)?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("v"),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<u64>(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("r")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("s")?
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("v")?
                            }
                        };
                        _serde::__private::Ok(FeePayerSignature {
                            r: __field0,
                            s: __field1,
                            v: __field2,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &["r", "s", "v"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "FeePayerSignature",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<FeePayerSignature>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for FeePayerSignature {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "FeePayerSignature",
                    false as usize + 1 + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "r",
                    &self.r,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "s",
                    &self.s,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "v",
                    &self.v,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[automatically_derived]
    impl ::core::default::Default for FeePayerSignature {
        #[inline]
        fn default() -> FeePayerSignature {
            FeePayerSignature {
                r: ::core::default::Default::default(),
                s: ::core::default::Default::default(),
                v: ::core::default::Default::default(),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for FeePayerSignature {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for FeePayerSignature {
        #[inline]
        fn eq(&self, other: &FeePayerSignature) -> bool {
            self.r == other.r && self.s == other.s && self.v == other.v
        }
    }
    #[serde(rename_all = "snake_case")]
    pub enum FeePayerSignatureAction {
        SignTransaction(FeePayerSignatureSignTransactionRequest),
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for FeePayerSignatureAction {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                FeePayerSignatureAction::SignTransaction(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "SignTransaction",
                        &__self_0,
                    )
                }
            }
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for FeePayerSignatureAction {
        #[inline]
        fn clone(&self) -> FeePayerSignatureAction {
            match self {
                FeePayerSignatureAction::SignTransaction(__self_0) => {
                    FeePayerSignatureAction::SignTransaction(
                        ::core::clone::Clone::clone(__self_0),
                    )
                }
            }
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for FeePayerSignatureAction {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    FeePayerSignatureAction::SignTransaction(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "FeePayerSignatureAction",
                            0u32,
                            "sign_transaction",
                            __field0,
                        )
                    }
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for FeePayerSignatureAction {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "variant identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::invalid_value(
                                        _serde::de::Unexpected::Unsigned(__value),
                                        &"variant index 0 <= i < 1",
                                    ),
                                )
                            }
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "sign_transaction" => {
                                _serde::__private::Ok(__Field::__field0)
                            }
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"sign_transaction" => {
                                _serde::__private::Ok(__Field::__field0)
                            }
                            _ => {
                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<FeePayerSignatureAction>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = FeePayerSignatureAction;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "enum FeePayerSignatureAction",
                        )
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match _serde::de::EnumAccess::variant(__data)? {
                            (__Field::__field0, __variant) => {
                                _serde::__private::Result::map(
                                    _serde::de::VariantAccess::newtype_variant::<
                                        FeePayerSignatureSignTransactionRequest,
                                    >(__variant),
                                    FeePayerSignatureAction::SignTransaction,
                                )
                            }
                        }
                    }
                }
                #[doc(hidden)]
                const VARIANTS: &'static [&'static str] = &["sign_transaction"];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "FeePayerSignatureAction",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<
                            FeePayerSignatureAction,
                        >,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for FeePayerSignatureAction {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for FeePayerSignatureAction {
        #[inline]
        fn eq(&self, other: &FeePayerSignatureAction) -> bool {
            match (self, other) {
                (
                    FeePayerSignatureAction::SignTransaction(__self_0),
                    FeePayerSignatureAction::SignTransaction(__arg1_0),
                ) => __self_0 == __arg1_0,
            }
        }
    }
    pub struct FeePayerSignatureSignTransactionRequest {
        pub tx: KlaytnTransaction,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for FeePayerSignatureSignTransactionRequest {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field1_finish(
                f,
                "FeePayerSignatureSignTransactionRequest",
                "tx",
                &&self.tx,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for FeePayerSignatureSignTransactionRequest {
        #[inline]
        fn clone(&self) -> FeePayerSignatureSignTransactionRequest {
            FeePayerSignatureSignTransactionRequest {
                tx: ::core::clone::Clone::clone(&self.tx),
            }
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for FeePayerSignatureSignTransactionRequest {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "FeePayerSignatureSignTransactionRequest",
                    false as usize + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "tx",
                    &self.tx,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for FeePayerSignatureSignTransactionRequest {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "tx" => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"tx" => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<
                        FeePayerSignatureSignTransactionRequest,
                    >,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = FeePayerSignatureSignTransactionRequest;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct FeePayerSignatureSignTransactionRequest",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            KlaytnTransaction,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct FeePayerSignatureSignTransactionRequest with 1 element",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(FeePayerSignatureSignTransactionRequest {
                            tx: __field0,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<KlaytnTransaction> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("tx"),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            KlaytnTransaction,
                                        >(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("tx")?
                            }
                        };
                        _serde::__private::Ok(FeePayerSignatureSignTransactionRequest {
                            tx: __field0,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &["tx"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "FeePayerSignatureSignTransactionRequest",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<
                            FeePayerSignatureSignTransactionRequest,
                        >,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::default::Default for FeePayerSignatureSignTransactionRequest {
        #[inline]
        fn default() -> FeePayerSignatureSignTransactionRequest {
            FeePayerSignatureSignTransactionRequest {
                tx: ::core::default::Default::default(),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq
    for FeePayerSignatureSignTransactionRequest {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for FeePayerSignatureSignTransactionRequest {
        #[inline]
        fn eq(&self, other: &FeePayerSignatureSignTransactionRequest) -> bool {
            self.tx == other.tx
        }
    }
    impl FeePayerSignatureClient {
        pub async fn act(
            &self,
            params: FeePayerSignatureAction,
        ) -> crate::Result<FeePayerSignature> {
            let path = ::alloc::__export::must_use({
                let res = ::alloc::fmt::format(format_args!("/v1/fee-payer"));
                res
            });
            let endpoint = ::alloc::__export::must_use({
                let res = ::alloc::fmt::format(
                    format_args!("{0}{1}", self.endpoint, path),
                );
                res
            });
            rest_api::post(&endpoint, params).await
        }
        pub async fn sign_transaction(
            &self,
            tx: KlaytnTransaction,
        ) -> crate::Result<FeePayerSignature> {
            let path = ::alloc::__export::must_use({
                let res = ::alloc::fmt::format(format_args!("/v1/fee-payer"));
                res
            });
            let endpoint = ::alloc::__export::must_use({
                let res = ::alloc::fmt::format(
                    format_args!("{0}{1}", self.endpoint, path),
                );
                res
            });
            let req = FeePayerSignatureAction::SignTransaction(FeePayerSignatureSignTransactionRequest {
                tx,
            });
            rest_api::post(&endpoint, req).await
        }
    }
    pub struct FeePayerSignatureSummary {}
    #[automatically_derived]
    impl ::core::fmt::Debug for FeePayerSignatureSummary {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "FeePayerSignatureSummary")
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for FeePayerSignatureSummary {
        #[inline]
        fn clone(&self) -> FeePayerSignatureSummary {
            FeePayerSignatureSummary {}
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for FeePayerSignatureSummary {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "FeePayerSignatureSummary",
                    false as usize,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for FeePayerSignatureSummary {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<FeePayerSignatureSummary>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = FeePayerSignatureSummary;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct FeePayerSignatureSummary",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        _: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        _serde::__private::Ok(FeePayerSignatureSummary {})
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        _serde::__private::Ok(FeePayerSignatureSummary {})
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "FeePayerSignatureSummary",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<
                            FeePayerSignatureSummary,
                        >,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::default::Default for FeePayerSignatureSummary {
        #[inline]
        fn default() -> FeePayerSignatureSummary {
            FeePayerSignatureSummary {}
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for FeePayerSignatureSummary {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for FeePayerSignatureSummary {
        #[inline]
        fn eq(&self, other: &FeePayerSignatureSummary) -> bool {
            true
        }
    }
    impl From<FeePayerSignature> for FeePayerSignatureSummary {
        fn from(item: FeePayerSignature) -> Self {
            Self {}
        }
    }
    impl Into<FeePayerSignature> for FeePayerSignatureSummary {
        fn into(self) -> FeePayerSignature {
            FeePayerSignature {
                ..Default::default()
            }
        }
    }
    #[serde(rename_all = "kebab-case")]
    pub struct FeePayerSignatureQuery {
        #[serde(deserialize_with = "parse_size_of_fee_payer_signature_query", default)]
        pub size: usize,
        pub bookmark: Option<String>,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for FeePayerSignatureQuery {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(
                f,
                "FeePayerSignatureQuery",
                "size",
                &self.size,
                "bookmark",
                &&self.bookmark,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for FeePayerSignatureQuery {
        #[inline]
        fn clone(&self) -> FeePayerSignatureQuery {
            FeePayerSignatureQuery {
                size: ::core::clone::Clone::clone(&self.size),
                bookmark: ::core::clone::Clone::clone(&self.bookmark),
            }
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for FeePayerSignatureQuery {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "FeePayerSignatureQuery",
                    false as usize + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "size",
                    &self.size,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "bookmark",
                    &self.bookmark,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for FeePayerSignatureQuery {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "size" => _serde::__private::Ok(__Field::__field0),
                            "bookmark" => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"size" => _serde::__private::Ok(__Field::__field0),
                            b"bookmark" => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<FeePayerSignatureQuery>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = FeePayerSignatureQuery;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct FeePayerSignatureQuery",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match {
                            #[doc(hidden)]
                            struct __DeserializeWith<'de> {
                                value: usize,
                                phantom: _serde::__private::PhantomData<
                                    FeePayerSignatureQuery,
                                >,
                                lifetime: _serde::__private::PhantomData<&'de ()>,
                            }
                            #[automatically_derived]
                            impl<'de> _serde::Deserialize<'de>
                            for __DeserializeWith<'de> {
                                fn deserialize<__D>(
                                    __deserializer: __D,
                                ) -> _serde::__private::Result<Self, __D::Error>
                                where
                                    __D: _serde::Deserializer<'de>,
                                {
                                    _serde::__private::Ok(__DeserializeWith {
                                        value: parse_size_of_fee_payer_signature_query(
                                            __deserializer,
                                        )?,
                                        phantom: _serde::__private::PhantomData,
                                        lifetime: _serde::__private::PhantomData,
                                    })
                                }
                            }
                            _serde::__private::Option::map(
                                _serde::de::SeqAccess::next_element::<
                                    __DeserializeWith<'de>,
                                >(&mut __seq)?,
                                |__wrap| __wrap.value,
                            )
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                _serde::__private::Default::default()
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            Option<String>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct FeePayerSignatureQuery with 2 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(FeePayerSignatureQuery {
                            size: __field0,
                            bookmark: __field1,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<usize> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<Option<String>> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("size"),
                                        );
                                    }
                                    __field0 = _serde::__private::Some({
                                        #[doc(hidden)]
                                        struct __DeserializeWith<'de> {
                                            value: usize,
                                            phantom: _serde::__private::PhantomData<
                                                FeePayerSignatureQuery,
                                            >,
                                            lifetime: _serde::__private::PhantomData<&'de ()>,
                                        }
                                        #[automatically_derived]
                                        impl<'de> _serde::Deserialize<'de>
                                        for __DeserializeWith<'de> {
                                            fn deserialize<__D>(
                                                __deserializer: __D,
                                            ) -> _serde::__private::Result<Self, __D::Error>
                                            where
                                                __D: _serde::Deserializer<'de>,
                                            {
                                                _serde::__private::Ok(__DeserializeWith {
                                                    value: parse_size_of_fee_payer_signature_query(
                                                        __deserializer,
                                                    )?,
                                                    phantom: _serde::__private::PhantomData,
                                                    lifetime: _serde::__private::PhantomData,
                                                })
                                            }
                                        }
                                        match _serde::de::MapAccess::next_value::<
                                            __DeserializeWith<'de>,
                                        >(&mut __map) {
                                            _serde::__private::Ok(__wrapper) => __wrapper.value,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        }
                                    });
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "bookmark",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<String>,
                                        >(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::Default::default()
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("bookmark")?
                            }
                        };
                        _serde::__private::Ok(FeePayerSignatureQuery {
                            size: __field0,
                            bookmark: __field1,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &["size", "bookmark"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "FeePayerSignatureQuery",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<FeePayerSignatureQuery>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::default::Default for FeePayerSignatureQuery {
        #[inline]
        fn default() -> FeePayerSignatureQuery {
            FeePayerSignatureQuery {
                size: ::core::default::Default::default(),
                bookmark: ::core::default::Default::default(),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for FeePayerSignatureQuery {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for FeePayerSignatureQuery {
        #[inline]
        fn eq(&self, other: &FeePayerSignatureQuery) -> bool {
            self.size == other.size && self.bookmark == other.bookmark
        }
    }
    impl std::fmt::Display for FeePayerSignatureQuery {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let query = serde_urlencoded::to_string(&self).map_err(|_| std::fmt::Error)?;
            f.write_fmt(format_args!("{0}", query))
        }
    }
    pub fn parse_size_of_fee_payer_signature_query<'de, D>(
        deserializer: D,
    ) -> std::result::Result<usize, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::Deserialize;
        let s: Option<String> = Option::deserialize(deserializer)?;
        s.unwrap_or_else(|| Default::default())
            .parse::<usize>()
            .map_err(serde::de::Error::custom)
    }
    impl FeePayerSignatureQuery {
        pub fn new(size: usize) -> Self {
            Self { size, ..Self::default() }
        }
        pub fn with_bookmark(mut self, bookmark: String) -> Self {
            self.bookmark = Some(bookmark);
            self
        }
        pub fn with_page(mut self, page: usize) -> Self {
            self.bookmark = Some(page.to_string());
            self
        }
        /// Returns the size(i32) of the query
        pub fn size(&self) -> i32 {
            self.size as i32
        }
        pub fn page(&self) -> i32 {
            self.bookmark.as_ref().unwrap_or(&"1".to_string()).parse().unwrap_or(1)
        }
    }
    impl FeePayerSignatureClient {}
    impl FeePayerSignature {
        pub fn get_client(endpoint: &str) -> FeePayerSignatureClient {
            FeePayerSignatureClient {
                endpoint: endpoint.to_string(),
            }
        }
    }
    pub struct FeePayerSignatureClient {
        pub endpoint: String,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for FeePayerSignatureClient {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field1_finish(
                f,
                "FeePayerSignatureClient",
                "endpoint",
                &&self.endpoint,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for FeePayerSignatureClient {
        #[inline]
        fn clone(&self) -> FeePayerSignatureClient {
            FeePayerSignatureClient {
                endpoint: ::core::clone::Clone::clone(&self.endpoint),
            }
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for FeePayerSignatureClient {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "FeePayerSignatureClient",
                    false as usize + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "endpoint",
                    &self.endpoint,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for FeePayerSignatureClient {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "endpoint" => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"endpoint" => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<FeePayerSignatureClient>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = FeePayerSignatureClient;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct FeePayerSignatureClient",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct FeePayerSignatureClient with 1 element",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(FeePayerSignatureClient {
                            endpoint: __field0,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "endpoint",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("endpoint")?
                            }
                        };
                        _serde::__private::Ok(FeePayerSignatureClient {
                            endpoint: __field0,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &["endpoint"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "FeePayerSignatureClient",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<
                            FeePayerSignatureClient,
                        >,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::default::Default for FeePayerSignatureClient {
        #[inline]
        fn default() -> FeePayerSignatureClient {
            FeePayerSignatureClient {
                endpoint: ::core::default::Default::default(),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for FeePayerSignatureClient {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for FeePayerSignatureClient {
        #[inline]
        fn eq(&self, other: &FeePayerSignatureClient) -> bool {
            self.endpoint == other.endpoint
        }
    }
    impl FeePayerSignatureClient {
        pub async fn query(
            &self,
            params: FeePayerSignatureQuery,
        ) -> crate::Result<by_types::QueryResponse<FeePayerSignatureSummary>> {
            let path = ::alloc::__export::must_use({
                let res = ::alloc::fmt::format(format_args!("/v1/fee-payer"));
                res
            });
            let endpoint = ::alloc::__export::must_use({
                let res = ::alloc::fmt::format(
                    format_args!("{0}{1}", self.endpoint, path),
                );
                res
            });
            let query = ::alloc::__export::must_use({
                let res = ::alloc::fmt::format(
                    format_args!(
                        "{0}?{1}",
                        endpoint,
                        FeePayerSignatureParam::Query(params),
                    ),
                );
                res
            });
            rest_api::get(&query).await
        }
        pub async fn get(&self, id: i64) -> crate::Result<FeePayerSignature> {
            let path = ::alloc::__export::must_use({
                let res = ::alloc::fmt::format(format_args!("/v1/fee-payer"));
                res
            });
            let endpoint = ::alloc::__export::must_use({
                let res = ::alloc::fmt::format(
                    format_args!("{0}{1}/{2}", self.endpoint, path, id),
                );
                res
            });
            rest_api::get(&endpoint).await
        }
    }
    impl FeePayerSignature {
        pub fn url() -> String {
            "/v1/fee-payer".to_string()
        }
    }
    pub struct FeePayerSignatureReadAction {}
    #[automatically_derived]
    impl ::core::fmt::Debug for FeePayerSignatureReadAction {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "FeePayerSignatureReadAction")
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for FeePayerSignatureReadAction {
        #[inline]
        fn clone(&self) -> FeePayerSignatureReadAction {
            FeePayerSignatureReadAction {}
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for FeePayerSignatureReadAction {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "FeePayerSignatureReadAction",
                    false as usize,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for FeePayerSignatureReadAction {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<FeePayerSignatureReadAction>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = FeePayerSignatureReadAction;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct FeePayerSignatureReadAction",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        _: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        _serde::__private::Ok(FeePayerSignatureReadAction {})
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        _serde::__private::Ok(FeePayerSignatureReadAction {})
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "FeePayerSignatureReadAction",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<
                            FeePayerSignatureReadAction,
                        >,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::default::Default for FeePayerSignatureReadAction {
        #[inline]
        fn default() -> FeePayerSignatureReadAction {
            FeePayerSignatureReadAction {}
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for FeePayerSignatureReadAction {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for FeePayerSignatureReadAction {
        #[inline]
        fn eq(&self, other: &FeePayerSignatureReadAction) -> bool {
            true
        }
    }
    impl std::fmt::Display for FeePayerSignatureReadAction {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let query = serde_urlencoded::to_string(&self).map_err(|_| std::fmt::Error)?;
            f.write_fmt(format_args!("{0}", query))
        }
    }
    impl FeePayerSignatureReadAction {
        pub fn new() -> Self {
            Self::default()
        }
    }
    impl FeePayerSignatureClient {}
    #[serde(tag = "param-type", rename_all = "kebab-case")]
    pub enum FeePayerSignatureParam {
        Query(FeePayerSignatureQuery),
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for FeePayerSignatureParam {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                FeePayerSignatureParam::Query(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Query",
                        &__self_0,
                    )
                }
            }
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for FeePayerSignatureParam {
        #[inline]
        fn clone(&self) -> FeePayerSignatureParam {
            match self {
                FeePayerSignatureParam::Query(__self_0) => {
                    FeePayerSignatureParam::Query(::core::clone::Clone::clone(__self_0))
                }
            }
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for FeePayerSignatureParam {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    FeePayerSignatureParam::Query(ref __field0) => {
                        _serde::__private::ser::serialize_tagged_newtype(
                            __serializer,
                            "FeePayerSignatureParam",
                            "Query",
                            "param-type",
                            "query",
                            __field0,
                        )
                    }
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for FeePayerSignatureParam {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "variant identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::invalid_value(
                                        _serde::de::Unexpected::Unsigned(__value),
                                        &"variant index 0 <= i < 1",
                                    ),
                                )
                            }
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "query" => _serde::__private::Ok(__Field::__field0),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"query" => _serde::__private::Ok(__Field::__field0),
                            _ => {
                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                const VARIANTS: &'static [&'static str] = &["query"];
                let (__tag, __content) = _serde::Deserializer::deserialize_any(
                    __deserializer,
                    _serde::__private::de::TaggedContentVisitor::<
                        __Field,
                    >::new("param-type", "internally tagged enum FeePayerSignatureParam"),
                )?;
                let __deserializer = _serde::__private::de::ContentDeserializer::<
                    __D::Error,
                >::new(__content);
                match __tag {
                    __Field::__field0 => {
                        _serde::__private::Result::map(
                            <FeePayerSignatureQuery as _serde::Deserialize>::deserialize(
                                __deserializer,
                            ),
                            FeePayerSignatureParam::Query,
                        )
                    }
                }
            }
        }
    };
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for FeePayerSignatureParam {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for FeePayerSignatureParam {
        #[inline]
        fn eq(&self, other: &FeePayerSignatureParam) -> bool {
            match (self, other) {
                (
                    FeePayerSignatureParam::Query(__self_0),
                    FeePayerSignatureParam::Query(__arg1_0),
                ) => __self_0 == __arg1_0,
            }
        }
    }
    impl std::fmt::Display for FeePayerSignatureParam {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let query = serde_urlencoded::to_string(&self).map_err(|_| std::fmt::Error)?;
            f.write_fmt(format_args!("{0}", query))
        }
    }
    #[serde(tag = "param_type")]
    #[serde(rename_all = "snake_case")]
    pub enum FeePayerSignatureGetResponse {
        Query(by_types::QueryResponse<FeePayerSignature>),
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for FeePayerSignatureGetResponse {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                FeePayerSignatureGetResponse::Query(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Query",
                        &__self_0,
                    )
                }
            }
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for FeePayerSignatureGetResponse {
        #[inline]
        fn clone(&self) -> FeePayerSignatureGetResponse {
            match self {
                FeePayerSignatureGetResponse::Query(__self_0) => {
                    FeePayerSignatureGetResponse::Query(
                        ::core::clone::Clone::clone(__self_0),
                    )
                }
            }
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for FeePayerSignatureGetResponse {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    FeePayerSignatureGetResponse::Query(ref __field0) => {
                        _serde::__private::ser::serialize_tagged_newtype(
                            __serializer,
                            "FeePayerSignatureGetResponse",
                            "Query",
                            "param_type",
                            "query",
                            __field0,
                        )
                    }
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for FeePayerSignatureGetResponse {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "variant identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::invalid_value(
                                        _serde::de::Unexpected::Unsigned(__value),
                                        &"variant index 0 <= i < 1",
                                    ),
                                )
                            }
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "query" => _serde::__private::Ok(__Field::__field0),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"query" => _serde::__private::Ok(__Field::__field0),
                            _ => {
                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                const VARIANTS: &'static [&'static str] = &["query"];
                let (__tag, __content) = _serde::Deserializer::deserialize_any(
                    __deserializer,
                    _serde::__private::de::TaggedContentVisitor::<
                        __Field,
                    >::new(
                        "param_type",
                        "internally tagged enum FeePayerSignatureGetResponse",
                    ),
                )?;
                let __deserializer = _serde::__private::de::ContentDeserializer::<
                    __D::Error,
                >::new(__content);
                match __tag {
                    __Field::__field0 => {
                        _serde::__private::Result::map(
                            <by_types::QueryResponse<
                                FeePayerSignature,
                            > as _serde::Deserialize>::deserialize(__deserializer),
                            FeePayerSignatureGetResponse::Query,
                        )
                    }
                }
            }
        }
    };
    impl From<Signature> for FeePayerSignature {
        fn from(signature: Signature) -> Self {
            let r = signature.r.as_ref().to_vec();
            let s = signature.s.as_ref().to_vec();
            Self { r, s, v: signature.v }
        }
    }
    impl Into<Signature> for FeePayerSignature {
        fn into(self) -> Signature {
            Signature {
                r: U256(self.r.try_into().expect("invalid r")),
                s: U256(self.s.try_into().expect("invalid s")),
                v: self.v,
            }
        }
    }
}
pub mod nft {
    use candid::{CandidType, Principal};
    use serde::{Deserialize, Serialize};
    pub struct Event {
        pub token_id: u64,
        pub event_name: String,
        pub from: Principal,
        pub to: Principal,
    }
    impl ::candid::types::CandidType for Event {
        fn _ty() -> ::candid::types::Type {
            ::candid::types::TypeInner::Record(
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named("to".to_string()).into(),
                                ty: <Principal as ::candid::types::CandidType>::ty(),
                            },
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named("token_id".to_string())
                                    .into(),
                                ty: <u64 as ::candid::types::CandidType>::ty(),
                            },
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named("from".to_string())
                                    .into(),
                                ty: <Principal as ::candid::types::CandidType>::ty(),
                            },
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named("event_name".to_string())
                                    .into(),
                                ty: <String as ::candid::types::CandidType>::ty(),
                            },
                        ]),
                    ),
                )
                .into()
        }
        fn id() -> ::candid::types::TypeId {
            ::candid::types::TypeId::of::<Event>()
        }
        fn idl_serialize<__S>(
            &self,
            __serializer: __S,
        ) -> ::std::result::Result<(), __S::Error>
        where
            __S: ::candid::types::Serializer,
        {
            let mut ser = __serializer.serialize_struct()?;
            ::candid::types::Compound::serialize_element(&mut ser, &self.to)?;
            ::candid::types::Compound::serialize_element(&mut ser, &self.token_id)?;
            ::candid::types::Compound::serialize_element(&mut ser, &self.from)?;
            ::candid::types::Compound::serialize_element(&mut ser, &self.event_name)?;
            Ok(())
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Event {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field4_finish(
                f,
                "Event",
                "token_id",
                &self.token_id,
                "event_name",
                &self.event_name,
                "from",
                &self.from,
                "to",
                &&self.to,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Event {
        #[inline]
        fn clone(&self) -> Event {
            Event {
                token_id: ::core::clone::Clone::clone(&self.token_id),
                event_name: ::core::clone::Clone::clone(&self.event_name),
                from: ::core::clone::Clone::clone(&self.from),
                to: ::core::clone::Clone::clone(&self.to),
            }
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for Event {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "Event",
                    false as usize + 1 + 1 + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "token_id",
                    &self.token_id,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "event_name",
                    &self.event_name,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "from",
                    &self.from,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "to",
                    &self.to,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for Event {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "token_id" => _serde::__private::Ok(__Field::__field0),
                            "event_name" => _serde::__private::Ok(__Field::__field1),
                            "from" => _serde::__private::Ok(__Field::__field2),
                            "to" => _serde::__private::Ok(__Field::__field3),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"token_id" => _serde::__private::Ok(__Field::__field0),
                            b"event_name" => _serde::__private::Ok(__Field::__field1),
                            b"from" => _serde::__private::Ok(__Field::__field2),
                            b"to" => _serde::__private::Ok(__Field::__field3),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<Event>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = Event;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct Event",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            u64,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct Event with 4 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct Event with 4 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match _serde::de::SeqAccess::next_element::<
                            Principal,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct Event with 4 elements",
                                    ),
                                );
                            }
                        };
                        let __field3 = match _serde::de::SeqAccess::next_element::<
                            Principal,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        3usize,
                                        &"struct Event with 4 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(Event {
                            token_id: __field0,
                            event_name: __field1,
                            from: __field2,
                            to: __field3,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<u64> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<Principal> = _serde::__private::None;
                        let mut __field3: _serde::__private::Option<Principal> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "token_id",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<u64>(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "event_name",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("from"),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<Principal>(&mut __map)?,
                                    );
                                }
                                __Field::__field3 => {
                                    if _serde::__private::Option::is_some(&__field3) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("to"),
                                        );
                                    }
                                    __field3 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<Principal>(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("token_id")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("event_name")?
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("from")?
                            }
                        };
                        let __field3 = match __field3 {
                            _serde::__private::Some(__field3) => __field3,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("to")?
                            }
                        };
                        _serde::__private::Ok(Event {
                            token_id: __field0,
                            event_name: __field1,
                            from: __field2,
                            to: __field3,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "token_id",
                    "event_name",
                    "from",
                    "to",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "Event",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<Event>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    pub struct Nft {
        pub owner: Principal,
        pub approved: Option<Principal>,
        pub id: u64,
        pub metadata: Metadata,
    }
    impl ::candid::types::CandidType for Nft {
        fn _ty() -> ::candid::types::Type {
            ::candid::types::TypeInner::Record(
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named("id".to_string()).into(),
                                ty: <u64 as ::candid::types::CandidType>::ty(),
                            },
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named("owner".to_string())
                                    .into(),
                                ty: <Principal as ::candid::types::CandidType>::ty(),
                            },
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named("metadata".to_string())
                                    .into(),
                                ty: <Metadata as ::candid::types::CandidType>::ty(),
                            },
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named("approved".to_string())
                                    .into(),
                                ty: <Option<Principal> as ::candid::types::CandidType>::ty(),
                            },
                        ]),
                    ),
                )
                .into()
        }
        fn id() -> ::candid::types::TypeId {
            ::candid::types::TypeId::of::<Nft>()
        }
        fn idl_serialize<__S>(
            &self,
            __serializer: __S,
        ) -> ::std::result::Result<(), __S::Error>
        where
            __S: ::candid::types::Serializer,
        {
            let mut ser = __serializer.serialize_struct()?;
            ::candid::types::Compound::serialize_element(&mut ser, &self.id)?;
            ::candid::types::Compound::serialize_element(&mut ser, &self.owner)?;
            ::candid::types::Compound::serialize_element(&mut ser, &self.metadata)?;
            ::candid::types::Compound::serialize_element(&mut ser, &self.approved)?;
            Ok(())
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Nft {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field4_finish(
                f,
                "Nft",
                "owner",
                &self.owner,
                "approved",
                &self.approved,
                "id",
                &self.id,
                "metadata",
                &&self.metadata,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Nft {
        #[inline]
        fn clone(&self) -> Nft {
            Nft {
                owner: ::core::clone::Clone::clone(&self.owner),
                approved: ::core::clone::Clone::clone(&self.approved),
                id: ::core::clone::Clone::clone(&self.id),
                metadata: ::core::clone::Clone::clone(&self.metadata),
            }
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for Nft {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "Nft",
                    false as usize + 1 + 1 + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "owner",
                    &self.owner,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "approved",
                    &self.approved,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "id",
                    &self.id,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "metadata",
                    &self.metadata,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for Nft {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "owner" => _serde::__private::Ok(__Field::__field0),
                            "approved" => _serde::__private::Ok(__Field::__field1),
                            "id" => _serde::__private::Ok(__Field::__field2),
                            "metadata" => _serde::__private::Ok(__Field::__field3),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"owner" => _serde::__private::Ok(__Field::__field0),
                            b"approved" => _serde::__private::Ok(__Field::__field1),
                            b"id" => _serde::__private::Ok(__Field::__field2),
                            b"metadata" => _serde::__private::Ok(__Field::__field3),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<Nft>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = Nft;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct Nft",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            Principal,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct Nft with 4 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            Option<Principal>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct Nft with 4 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match _serde::de::SeqAccess::next_element::<
                            u64,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct Nft with 4 elements",
                                    ),
                                );
                            }
                        };
                        let __field3 = match _serde::de::SeqAccess::next_element::<
                            Metadata,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        3usize,
                                        &"struct Nft with 4 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(Nft {
                            owner: __field0,
                            approved: __field1,
                            id: __field2,
                            metadata: __field3,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<Principal> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<Option<Principal>> = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<u64> = _serde::__private::None;
                        let mut __field3: _serde::__private::Option<Metadata> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("owner"),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<Principal>(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "approved",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<Principal>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("id"),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<u64>(&mut __map)?,
                                    );
                                }
                                __Field::__field3 => {
                                    if _serde::__private::Option::is_some(&__field3) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "metadata",
                                            ),
                                        );
                                    }
                                    __field3 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<Metadata>(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("owner")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("approved")?
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("id")?
                            }
                        };
                        let __field3 = match __field3 {
                            _serde::__private::Some(__field3) => __field3,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("metadata")?
                            }
                        };
                        _serde::__private::Ok(Nft {
                            owner: __field0,
                            approved: __field1,
                            id: __field2,
                            metadata: __field3,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "owner",
                    "approved",
                    "id",
                    "metadata",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "Nft",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<Nft>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    pub struct Metadata {
        pub name: String,
        pub description: String,
        pub image: String,
        pub external_url: Option<String>,
        pub background_color: Option<String>,
        pub animation_url: Option<String>,
        pub youtube_url: Option<String>,
        pub attributes: Vec<Attribute>,
    }
    impl ::candid::types::CandidType for Metadata {
        fn _ty() -> ::candid::types::Type {
            ::candid::types::TypeInner::Record(
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named("youtube_url".to_string())
                                    .into(),
                                ty: <Option<String> as ::candid::types::CandidType>::ty(),
                            },
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named(
                                        "external_url".to_string(),
                                    )
                                    .into(),
                                ty: <Option<String> as ::candid::types::CandidType>::ty(),
                            },
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named(
                                        "animation_url".to_string(),
                                    )
                                    .into(),
                                ty: <Option<String> as ::candid::types::CandidType>::ty(),
                            },
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named("name".to_string())
                                    .into(),
                                ty: <String as ::candid::types::CandidType>::ty(),
                            },
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named("description".to_string())
                                    .into(),
                                ty: <String as ::candid::types::CandidType>::ty(),
                            },
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named("attributes".to_string())
                                    .into(),
                                ty: <Vec<Attribute> as ::candid::types::CandidType>::ty(),
                            },
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named("image".to_string())
                                    .into(),
                                ty: <String as ::candid::types::CandidType>::ty(),
                            },
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named(
                                        "background_color".to_string(),
                                    )
                                    .into(),
                                ty: <Option<String> as ::candid::types::CandidType>::ty(),
                            },
                        ]),
                    ),
                )
                .into()
        }
        fn id() -> ::candid::types::TypeId {
            ::candid::types::TypeId::of::<Metadata>()
        }
        fn idl_serialize<__S>(
            &self,
            __serializer: __S,
        ) -> ::std::result::Result<(), __S::Error>
        where
            __S: ::candid::types::Serializer,
        {
            let mut ser = __serializer.serialize_struct()?;
            ::candid::types::Compound::serialize_element(&mut ser, &self.youtube_url)?;
            ::candid::types::Compound::serialize_element(&mut ser, &self.external_url)?;
            ::candid::types::Compound::serialize_element(&mut ser, &self.animation_url)?;
            ::candid::types::Compound::serialize_element(&mut ser, &self.name)?;
            ::candid::types::Compound::serialize_element(&mut ser, &self.description)?;
            ::candid::types::Compound::serialize_element(&mut ser, &self.attributes)?;
            ::candid::types::Compound::serialize_element(&mut ser, &self.image)?;
            ::candid::types::Compound::serialize_element(
                &mut ser,
                &self.background_color,
            )?;
            Ok(())
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Metadata {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let names: &'static _ = &[
                "name",
                "description",
                "image",
                "external_url",
                "background_color",
                "animation_url",
                "youtube_url",
                "attributes",
            ];
            let values: &[&dyn ::core::fmt::Debug] = &[
                &self.name,
                &self.description,
                &self.image,
                &self.external_url,
                &self.background_color,
                &self.animation_url,
                &self.youtube_url,
                &&self.attributes,
            ];
            ::core::fmt::Formatter::debug_struct_fields_finish(
                f,
                "Metadata",
                names,
                values,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Metadata {
        #[inline]
        fn clone(&self) -> Metadata {
            Metadata {
                name: ::core::clone::Clone::clone(&self.name),
                description: ::core::clone::Clone::clone(&self.description),
                image: ::core::clone::Clone::clone(&self.image),
                external_url: ::core::clone::Clone::clone(&self.external_url),
                background_color: ::core::clone::Clone::clone(&self.background_color),
                animation_url: ::core::clone::Clone::clone(&self.animation_url),
                youtube_url: ::core::clone::Clone::clone(&self.youtube_url),
                attributes: ::core::clone::Clone::clone(&self.attributes),
            }
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for Metadata {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "Metadata",
                    false as usize + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "name",
                    &self.name,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "description",
                    &self.description,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "image",
                    &self.image,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "external_url",
                    &self.external_url,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "background_color",
                    &self.background_color,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "animation_url",
                    &self.animation_url,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "youtube_url",
                    &self.youtube_url,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "attributes",
                    &self.attributes,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for Metadata {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __field4,
                    __field5,
                    __field6,
                    __field7,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            4u64 => _serde::__private::Ok(__Field::__field4),
                            5u64 => _serde::__private::Ok(__Field::__field5),
                            6u64 => _serde::__private::Ok(__Field::__field6),
                            7u64 => _serde::__private::Ok(__Field::__field7),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "name" => _serde::__private::Ok(__Field::__field0),
                            "description" => _serde::__private::Ok(__Field::__field1),
                            "image" => _serde::__private::Ok(__Field::__field2),
                            "external_url" => _serde::__private::Ok(__Field::__field3),
                            "background_color" => {
                                _serde::__private::Ok(__Field::__field4)
                            }
                            "animation_url" => _serde::__private::Ok(__Field::__field5),
                            "youtube_url" => _serde::__private::Ok(__Field::__field6),
                            "attributes" => _serde::__private::Ok(__Field::__field7),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"name" => _serde::__private::Ok(__Field::__field0),
                            b"description" => _serde::__private::Ok(__Field::__field1),
                            b"image" => _serde::__private::Ok(__Field::__field2),
                            b"external_url" => _serde::__private::Ok(__Field::__field3),
                            b"background_color" => {
                                _serde::__private::Ok(__Field::__field4)
                            }
                            b"animation_url" => _serde::__private::Ok(__Field::__field5),
                            b"youtube_url" => _serde::__private::Ok(__Field::__field6),
                            b"attributes" => _serde::__private::Ok(__Field::__field7),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<Metadata>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = Metadata;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct Metadata",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct Metadata with 8 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct Metadata with 8 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct Metadata with 8 elements",
                                    ),
                                );
                            }
                        };
                        let __field3 = match _serde::de::SeqAccess::next_element::<
                            Option<String>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        3usize,
                                        &"struct Metadata with 8 elements",
                                    ),
                                );
                            }
                        };
                        let __field4 = match _serde::de::SeqAccess::next_element::<
                            Option<String>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        4usize,
                                        &"struct Metadata with 8 elements",
                                    ),
                                );
                            }
                        };
                        let __field5 = match _serde::de::SeqAccess::next_element::<
                            Option<String>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        5usize,
                                        &"struct Metadata with 8 elements",
                                    ),
                                );
                            }
                        };
                        let __field6 = match _serde::de::SeqAccess::next_element::<
                            Option<String>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        6usize,
                                        &"struct Metadata with 8 elements",
                                    ),
                                );
                            }
                        };
                        let __field7 = match _serde::de::SeqAccess::next_element::<
                            Vec<Attribute>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        7usize,
                                        &"struct Metadata with 8 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(Metadata {
                            name: __field0,
                            description: __field1,
                            image: __field2,
                            external_url: __field3,
                            background_color: __field4,
                            animation_url: __field5,
                            youtube_url: __field6,
                            attributes: __field7,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field3: _serde::__private::Option<Option<String>> = _serde::__private::None;
                        let mut __field4: _serde::__private::Option<Option<String>> = _serde::__private::None;
                        let mut __field5: _serde::__private::Option<Option<String>> = _serde::__private::None;
                        let mut __field6: _serde::__private::Option<Option<String>> = _serde::__private::None;
                        let mut __field7: _serde::__private::Option<Vec<Attribute>> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("name"),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "description",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("image"),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field3 => {
                                    if _serde::__private::Option::is_some(&__field3) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "external_url",
                                            ),
                                        );
                                    }
                                    __field3 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<String>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field4 => {
                                    if _serde::__private::Option::is_some(&__field4) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "background_color",
                                            ),
                                        );
                                    }
                                    __field4 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<String>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field5 => {
                                    if _serde::__private::Option::is_some(&__field5) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "animation_url",
                                            ),
                                        );
                                    }
                                    __field5 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<String>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field6 => {
                                    if _serde::__private::Option::is_some(&__field6) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "youtube_url",
                                            ),
                                        );
                                    }
                                    __field6 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<String>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field7 => {
                                    if _serde::__private::Option::is_some(&__field7) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "attributes",
                                            ),
                                        );
                                    }
                                    __field7 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Vec<Attribute>,
                                        >(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("name")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("description")?
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("image")?
                            }
                        };
                        let __field3 = match __field3 {
                            _serde::__private::Some(__field3) => __field3,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("external_url")?
                            }
                        };
                        let __field4 = match __field4 {
                            _serde::__private::Some(__field4) => __field4,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("background_color")?
                            }
                        };
                        let __field5 = match __field5 {
                            _serde::__private::Some(__field5) => __field5,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("animation_url")?
                            }
                        };
                        let __field6 = match __field6 {
                            _serde::__private::Some(__field6) => __field6,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("youtube_url")?
                            }
                        };
                        let __field7 = match __field7 {
                            _serde::__private::Some(__field7) => __field7,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("attributes")?
                            }
                        };
                        _serde::__private::Ok(Metadata {
                            name: __field0,
                            description: __field1,
                            image: __field2,
                            external_url: __field3,
                            background_color: __field4,
                            animation_url: __field5,
                            youtube_url: __field6,
                            attributes: __field7,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "name",
                    "description",
                    "image",
                    "external_url",
                    "background_color",
                    "animation_url",
                    "youtube_url",
                    "attributes",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "Metadata",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<Metadata>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    pub enum DisplayType {
        #[serde(rename = "number")]
        Number,
        #[serde(rename = "boost_number")]
        BoostNumber,
        #[serde(rename = "boost_percentage")]
        BoostPercentage,
    }
    impl ::candid::types::CandidType for DisplayType {
        fn _ty() -> ::candid::types::Type {
            ::candid::types::TypeInner::Variant(
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named(
                                        "boost_percentage".to_owned(),
                                    )
                                    .into(),
                                ty: ::candid::types::TypeInner::Null.into(),
                            },
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named("boost_number".to_owned())
                                    .into(),
                                ty: ::candid::types::TypeInner::Null.into(),
                            },
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named("number".to_owned())
                                    .into(),
                                ty: ::candid::types::TypeInner::Null.into(),
                            },
                        ]),
                    ),
                )
                .into()
        }
        fn id() -> ::candid::types::TypeId {
            ::candid::types::TypeId::of::<DisplayType>()
        }
        fn idl_serialize<__S>(
            &self,
            __serializer: __S,
        ) -> ::std::result::Result<(), __S::Error>
        where
            __S: ::candid::types::Serializer,
        {
            match *self {
                DisplayType::BoostPercentage => {
                    let mut ser = __serializer.serialize_variant(0u64)?;
                }
                DisplayType::BoostNumber => {
                    let mut ser = __serializer.serialize_variant(1u64)?;
                }
                DisplayType::Number => {
                    let mut ser = __serializer.serialize_variant(2u64)?;
                }
            };
            Ok(())
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for DisplayType {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(
                f,
                match self {
                    DisplayType::Number => "Number",
                    DisplayType::BoostNumber => "BoostNumber",
                    DisplayType::BoostPercentage => "BoostPercentage",
                },
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for DisplayType {
        #[inline]
        fn clone(&self) -> DisplayType {
            match self {
                DisplayType::Number => DisplayType::Number,
                DisplayType::BoostNumber => DisplayType::BoostNumber,
                DisplayType::BoostPercentage => DisplayType::BoostPercentage,
            }
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for DisplayType {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    DisplayType::Number => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "DisplayType",
                            0u32,
                            "number",
                        )
                    }
                    DisplayType::BoostNumber => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "DisplayType",
                            1u32,
                            "boost_number",
                        )
                    }
                    DisplayType::BoostPercentage => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "DisplayType",
                            2u32,
                            "boost_percentage",
                        )
                    }
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for DisplayType {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "variant identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::invalid_value(
                                        _serde::de::Unexpected::Unsigned(__value),
                                        &"variant index 0 <= i < 3",
                                    ),
                                )
                            }
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "number" => _serde::__private::Ok(__Field::__field0),
                            "boost_number" => _serde::__private::Ok(__Field::__field1),
                            "boost_percentage" => {
                                _serde::__private::Ok(__Field::__field2)
                            }
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"number" => _serde::__private::Ok(__Field::__field0),
                            b"boost_number" => _serde::__private::Ok(__Field::__field1),
                            b"boost_percentage" => {
                                _serde::__private::Ok(__Field::__field2)
                            }
                            _ => {
                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<DisplayType>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = DisplayType;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "enum DisplayType",
                        )
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match _serde::de::EnumAccess::variant(__data)? {
                            (__Field::__field0, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(DisplayType::Number)
                            }
                            (__Field::__field1, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(DisplayType::BoostNumber)
                            }
                            (__Field::__field2, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(DisplayType::BoostPercentage)
                            }
                        }
                    }
                }
                #[doc(hidden)]
                const VARIANTS: &'static [&'static str] = &[
                    "number",
                    "boost_number",
                    "boost_percentage",
                ];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "DisplayType",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<DisplayType>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    pub struct Attribute {
        pub trait_type: String,
        pub display_type: Option<DisplayType>,
        pub value: String,
    }
    impl ::candid::types::CandidType for Attribute {
        fn _ty() -> ::candid::types::Type {
            ::candid::types::TypeInner::Record(
                    <[_]>::into_vec(
                        #[rustc_box]
                        ::alloc::boxed::Box::new([
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named("trait_type".to_string())
                                    .into(),
                                ty: <String as ::candid::types::CandidType>::ty(),
                            },
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named("value".to_string())
                                    .into(),
                                ty: <String as ::candid::types::CandidType>::ty(),
                            },
                            ::candid::types::Field {
                                id: ::candid::types::Label::Named(
                                        "display_type".to_string(),
                                    )
                                    .into(),
                                ty: <Option<
                                    DisplayType,
                                > as ::candid::types::CandidType>::ty(),
                            },
                        ]),
                    ),
                )
                .into()
        }
        fn id() -> ::candid::types::TypeId {
            ::candid::types::TypeId::of::<Attribute>()
        }
        fn idl_serialize<__S>(
            &self,
            __serializer: __S,
        ) -> ::std::result::Result<(), __S::Error>
        where
            __S: ::candid::types::Serializer,
        {
            let mut ser = __serializer.serialize_struct()?;
            ::candid::types::Compound::serialize_element(&mut ser, &self.trait_type)?;
            ::candid::types::Compound::serialize_element(&mut ser, &self.value)?;
            ::candid::types::Compound::serialize_element(&mut ser, &self.display_type)?;
            Ok(())
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Attribute {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "Attribute",
                "trait_type",
                &self.trait_type,
                "display_type",
                &self.display_type,
                "value",
                &&self.value,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Attribute {
        #[inline]
        fn clone(&self) -> Attribute {
            Attribute {
                trait_type: ::core::clone::Clone::clone(&self.trait_type),
                display_type: ::core::clone::Clone::clone(&self.display_type),
                value: ::core::clone::Clone::clone(&self.value),
            }
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for Attribute {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "Attribute",
                    false as usize + 1 + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "trait_type",
                    &self.trait_type,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "display_type",
                    &self.display_type,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "value",
                    &self.value,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for Attribute {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "trait_type" => _serde::__private::Ok(__Field::__field0),
                            "display_type" => _serde::__private::Ok(__Field::__field1),
                            "value" => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"trait_type" => _serde::__private::Ok(__Field::__field0),
                            b"display_type" => _serde::__private::Ok(__Field::__field1),
                            b"value" => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<Attribute>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = Attribute;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct Attribute",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct Attribute with 3 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            Option<DisplayType>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct Attribute with 3 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct Attribute with 3 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(Attribute {
                            trait_type: __field0,
                            display_type: __field1,
                            value: __field2,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<
                            Option<DisplayType>,
                        > = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<String> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "trait_type",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "display_type",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<DisplayType>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("value"),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("trait_type")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("display_type")?
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("value")?
                            }
                        };
                        _serde::__private::Ok(Attribute {
                            trait_type: __field0,
                            display_type: __field1,
                            value: __field2,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "trait_type",
                    "display_type",
                    "value",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "Attribute",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<Attribute>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
}
pub mod user {
    #![allow(unused_variables)]
    use by_macros::{ApiModel, api_model};
    use validator::Validate;
    use crate::ContentSummary;
    /// User is a generated struct that represents the model
    ///
    /// For making API calls related to this model, use `User::get_client(endpoint: &str)`.
    /// It will returns UserClient struct that implements the API calls.
    ///
    /// In server side, you can use `User::get_repository()` to interact with the database.
    /// Recommend to use `UserRepository` to insert or update the model.
    /// To query the model, use `User::query_builder()`.
    /// For more detail, refer to the documentation of the query builder.
    pub struct User {
        pub id: i64,
        pub created_at: i64,
        pub updated_at: i64,
        pub evm_address: String,
        #[validate(email)]
        pub email: String,
        pub subject: String,
        #[validate(url)]
        pub profile_url: String,
        pub provider: UserAuthProvider,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for User {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let names: &'static _ = &[
                "id",
                "created_at",
                "updated_at",
                "evm_address",
                "email",
                "subject",
                "profile_url",
                "provider",
            ];
            let values: &[&dyn ::core::fmt::Debug] = &[
                &self.id,
                &self.created_at,
                &self.updated_at,
                &self.evm_address,
                &self.email,
                &self.subject,
                &self.profile_url,
                &&self.provider,
            ];
            ::core::fmt::Formatter::debug_struct_fields_finish(f, "User", names, values)
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for User {
        #[inline]
        fn clone(&self) -> User {
            User {
                id: ::core::clone::Clone::clone(&self.id),
                created_at: ::core::clone::Clone::clone(&self.created_at),
                updated_at: ::core::clone::Clone::clone(&self.updated_at),
                evm_address: ::core::clone::Clone::clone(&self.evm_address),
                email: ::core::clone::Clone::clone(&self.email),
                subject: ::core::clone::Clone::clone(&self.subject),
                profile_url: ::core::clone::Clone::clone(&self.profile_url),
                provider: ::core::clone::Clone::clone(&self.provider),
            }
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for User {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __field4,
                    __field5,
                    __field6,
                    __field7,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            4u64 => _serde::__private::Ok(__Field::__field4),
                            5u64 => _serde::__private::Ok(__Field::__field5),
                            6u64 => _serde::__private::Ok(__Field::__field6),
                            7u64 => _serde::__private::Ok(__Field::__field7),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "id" => _serde::__private::Ok(__Field::__field0),
                            "created_at" => _serde::__private::Ok(__Field::__field1),
                            "updated_at" => _serde::__private::Ok(__Field::__field2),
                            "evm_address" => _serde::__private::Ok(__Field::__field3),
                            "email" => _serde::__private::Ok(__Field::__field4),
                            "subject" => _serde::__private::Ok(__Field::__field5),
                            "profile_url" => _serde::__private::Ok(__Field::__field6),
                            "provider" => _serde::__private::Ok(__Field::__field7),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"id" => _serde::__private::Ok(__Field::__field0),
                            b"created_at" => _serde::__private::Ok(__Field::__field1),
                            b"updated_at" => _serde::__private::Ok(__Field::__field2),
                            b"evm_address" => _serde::__private::Ok(__Field::__field3),
                            b"email" => _serde::__private::Ok(__Field::__field4),
                            b"subject" => _serde::__private::Ok(__Field::__field5),
                            b"profile_url" => _serde::__private::Ok(__Field::__field6),
                            b"provider" => _serde::__private::Ok(__Field::__field7),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<User>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = User;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct User",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            i64,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct User with 8 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            i64,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct User with 8 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match _serde::de::SeqAccess::next_element::<
                            i64,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct User with 8 elements",
                                    ),
                                );
                            }
                        };
                        let __field3 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        3usize,
                                        &"struct User with 8 elements",
                                    ),
                                );
                            }
                        };
                        let __field4 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        4usize,
                                        &"struct User with 8 elements",
                                    ),
                                );
                            }
                        };
                        let __field5 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        5usize,
                                        &"struct User with 8 elements",
                                    ),
                                );
                            }
                        };
                        let __field6 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        6usize,
                                        &"struct User with 8 elements",
                                    ),
                                );
                            }
                        };
                        let __field7 = match _serde::de::SeqAccess::next_element::<
                            UserAuthProvider,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        7usize,
                                        &"struct User with 8 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(User {
                            id: __field0,
                            created_at: __field1,
                            updated_at: __field2,
                            evm_address: __field3,
                            email: __field4,
                            subject: __field5,
                            profile_url: __field6,
                            provider: __field7,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<i64> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<i64> = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<i64> = _serde::__private::None;
                        let mut __field3: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field4: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field5: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field6: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field7: _serde::__private::Option<UserAuthProvider> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("id"),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<i64>(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "created_at",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<i64>(&mut __map)?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "updated_at",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<i64>(&mut __map)?,
                                    );
                                }
                                __Field::__field3 => {
                                    if _serde::__private::Option::is_some(&__field3) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "evm_address",
                                            ),
                                        );
                                    }
                                    __field3 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field4 => {
                                    if _serde::__private::Option::is_some(&__field4) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("email"),
                                        );
                                    }
                                    __field4 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field5 => {
                                    if _serde::__private::Option::is_some(&__field5) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "subject",
                                            ),
                                        );
                                    }
                                    __field5 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field6 => {
                                    if _serde::__private::Option::is_some(&__field6) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "profile_url",
                                            ),
                                        );
                                    }
                                    __field6 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field7 => {
                                    if _serde::__private::Option::is_some(&__field7) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "provider",
                                            ),
                                        );
                                    }
                                    __field7 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            UserAuthProvider,
                                        >(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("id")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("created_at")?
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("updated_at")?
                            }
                        };
                        let __field3 = match __field3 {
                            _serde::__private::Some(__field3) => __field3,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("evm_address")?
                            }
                        };
                        let __field4 = match __field4 {
                            _serde::__private::Some(__field4) => __field4,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("email")?
                            }
                        };
                        let __field5 = match __field5 {
                            _serde::__private::Some(__field5) => __field5,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("subject")?
                            }
                        };
                        let __field6 = match __field6 {
                            _serde::__private::Some(__field6) => __field6,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("profile_url")?
                            }
                        };
                        let __field7 = match __field7 {
                            _serde::__private::Some(__field7) => __field7,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("provider")?
                            }
                        };
                        _serde::__private::Ok(User {
                            id: __field0,
                            created_at: __field1,
                            updated_at: __field2,
                            evm_address: __field3,
                            email: __field4,
                            subject: __field5,
                            profile_url: __field6,
                            provider: __field7,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "id",
                    "created_at",
                    "updated_at",
                    "evm_address",
                    "email",
                    "subject",
                    "profile_url",
                    "provider",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "User",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<User>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for User {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "User",
                    false as usize + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "id",
                    &self.id,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "created_at",
                    &self.created_at,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "updated_at",
                    &self.updated_at,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "evm_address",
                    &self.evm_address,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "email",
                    &self.email,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "subject",
                    &self.subject,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "profile_url",
                    &self.profile_url,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "provider",
                    &self.provider,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[automatically_derived]
    impl ::core::default::Default for User {
        #[inline]
        fn default() -> User {
            User {
                id: ::core::default::Default::default(),
                created_at: ::core::default::Default::default(),
                updated_at: ::core::default::Default::default(),
                evm_address: ::core::default::Default::default(),
                email: ::core::default::Default::default(),
                subject: ::core::default::Default::default(),
                profile_url: ::core::default::Default::default(),
                provider: ::core::default::Default::default(),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for User {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for User {
        #[inline]
        fn eq(&self, other: &User) -> bool {
            self.id == other.id && self.created_at == other.created_at
                && self.updated_at == other.updated_at
                && self.evm_address == other.evm_address && self.email == other.email
                && self.subject == other.subject && self.profile_url == other.profile_url
                && self.provider == other.provider
        }
    }
    #[serde(rename_all = "snake_case")]
    pub enum UserAction {
        SignupOrLogin(UserSignupOrLoginRequest),
        RegisterOrLogin(UserRegisterOrLoginRequest),
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for UserAction {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                UserAction::SignupOrLogin(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "SignupOrLogin",
                        &__self_0,
                    )
                }
                UserAction::RegisterOrLogin(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "RegisterOrLogin",
                        &__self_0,
                    )
                }
            }
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for UserAction {
        #[inline]
        fn clone(&self) -> UserAction {
            match self {
                UserAction::SignupOrLogin(__self_0) => {
                    UserAction::SignupOrLogin(::core::clone::Clone::clone(__self_0))
                }
                UserAction::RegisterOrLogin(__self_0) => {
                    UserAction::RegisterOrLogin(::core::clone::Clone::clone(__self_0))
                }
            }
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for UserAction {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    UserAction::SignupOrLogin(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "UserAction",
                            0u32,
                            "signup_or_login",
                            __field0,
                        )
                    }
                    UserAction::RegisterOrLogin(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "UserAction",
                            1u32,
                            "register_or_login",
                            __field0,
                        )
                    }
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for UserAction {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "variant identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::invalid_value(
                                        _serde::de::Unexpected::Unsigned(__value),
                                        &"variant index 0 <= i < 2",
                                    ),
                                )
                            }
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "signup_or_login" => _serde::__private::Ok(__Field::__field0),
                            "register_or_login" => {
                                _serde::__private::Ok(__Field::__field1)
                            }
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"signup_or_login" => {
                                _serde::__private::Ok(__Field::__field0)
                            }
                            b"register_or_login" => {
                                _serde::__private::Ok(__Field::__field1)
                            }
                            _ => {
                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<UserAction>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = UserAction;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "enum UserAction",
                        )
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match _serde::de::EnumAccess::variant(__data)? {
                            (__Field::__field0, __variant) => {
                                _serde::__private::Result::map(
                                    _serde::de::VariantAccess::newtype_variant::<
                                        UserSignupOrLoginRequest,
                                    >(__variant),
                                    UserAction::SignupOrLogin,
                                )
                            }
                            (__Field::__field1, __variant) => {
                                _serde::__private::Result::map(
                                    _serde::de::VariantAccess::newtype_variant::<
                                        UserRegisterOrLoginRequest,
                                    >(__variant),
                                    UserAction::RegisterOrLogin,
                                )
                            }
                        }
                    }
                }
                #[doc(hidden)]
                const VARIANTS: &'static [&'static str] = &[
                    "signup_or_login",
                    "register_or_login",
                ];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "UserAction",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<UserAction>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for UserAction {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for UserAction {
        #[inline]
        fn eq(&self, other: &UserAction) -> bool {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            let __arg1_discr = ::core::intrinsics::discriminant_value(other);
            __self_discr == __arg1_discr
                && match (self, other) {
                    (
                        UserAction::SignupOrLogin(__self_0),
                        UserAction::SignupOrLogin(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (
                        UserAction::RegisterOrLogin(__self_0),
                        UserAction::RegisterOrLogin(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    _ => unsafe { ::core::intrinsics::unreachable() }
                }
        }
    }
    impl validator::Validate for UserAction {
        fn validate(&self) -> std::result::Result<(), validator::ValidationErrors> {
            match self {
                UserAction::SignupOrLogin(req) => req.validate(),
                UserAction::RegisterOrLogin(req) => req.validate(),
            }
        }
    }
    pub struct UserSignupOrLoginRequest {
        pub evm_address: String,
        #[validate(email)]
        pub email: String,
        pub subject: String,
        #[validate(url)]
        pub profile_url: String,
        pub provider: UserAuthProvider,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for UserSignupOrLoginRequest {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field5_finish(
                f,
                "UserSignupOrLoginRequest",
                "evm_address",
                &self.evm_address,
                "email",
                &self.email,
                "subject",
                &self.subject,
                "profile_url",
                &self.profile_url,
                "provider",
                &&self.provider,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for UserSignupOrLoginRequest {
        #[inline]
        fn clone(&self) -> UserSignupOrLoginRequest {
            UserSignupOrLoginRequest {
                evm_address: ::core::clone::Clone::clone(&self.evm_address),
                email: ::core::clone::Clone::clone(&self.email),
                subject: ::core::clone::Clone::clone(&self.subject),
                profile_url: ::core::clone::Clone::clone(&self.profile_url),
                provider: ::core::clone::Clone::clone(&self.provider),
            }
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for UserSignupOrLoginRequest {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "UserSignupOrLoginRequest",
                    false as usize + 1 + 1 + 1 + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "evm_address",
                    &self.evm_address,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "email",
                    &self.email,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "subject",
                    &self.subject,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "profile_url",
                    &self.profile_url,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "provider",
                    &self.provider,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for UserSignupOrLoginRequest {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __field4,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            4u64 => _serde::__private::Ok(__Field::__field4),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "evm_address" => _serde::__private::Ok(__Field::__field0),
                            "email" => _serde::__private::Ok(__Field::__field1),
                            "subject" => _serde::__private::Ok(__Field::__field2),
                            "profile_url" => _serde::__private::Ok(__Field::__field3),
                            "provider" => _serde::__private::Ok(__Field::__field4),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"evm_address" => _serde::__private::Ok(__Field::__field0),
                            b"email" => _serde::__private::Ok(__Field::__field1),
                            b"subject" => _serde::__private::Ok(__Field::__field2),
                            b"profile_url" => _serde::__private::Ok(__Field::__field3),
                            b"provider" => _serde::__private::Ok(__Field::__field4),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<UserSignupOrLoginRequest>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = UserSignupOrLoginRequest;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct UserSignupOrLoginRequest",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct UserSignupOrLoginRequest with 5 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct UserSignupOrLoginRequest with 5 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct UserSignupOrLoginRequest with 5 elements",
                                    ),
                                );
                            }
                        };
                        let __field3 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        3usize,
                                        &"struct UserSignupOrLoginRequest with 5 elements",
                                    ),
                                );
                            }
                        };
                        let __field4 = match _serde::de::SeqAccess::next_element::<
                            UserAuthProvider,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        4usize,
                                        &"struct UserSignupOrLoginRequest with 5 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(UserSignupOrLoginRequest {
                            evm_address: __field0,
                            email: __field1,
                            subject: __field2,
                            profile_url: __field3,
                            provider: __field4,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field3: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field4: _serde::__private::Option<UserAuthProvider> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "evm_address",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("email"),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "subject",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field3 => {
                                    if _serde::__private::Option::is_some(&__field3) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "profile_url",
                                            ),
                                        );
                                    }
                                    __field3 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field4 => {
                                    if _serde::__private::Option::is_some(&__field4) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "provider",
                                            ),
                                        );
                                    }
                                    __field4 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            UserAuthProvider,
                                        >(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("evm_address")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("email")?
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("subject")?
                            }
                        };
                        let __field3 = match __field3 {
                            _serde::__private::Some(__field3) => __field3,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("profile_url")?
                            }
                        };
                        let __field4 = match __field4 {
                            _serde::__private::Some(__field4) => __field4,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("provider")?
                            }
                        };
                        _serde::__private::Ok(UserSignupOrLoginRequest {
                            evm_address: __field0,
                            email: __field1,
                            subject: __field2,
                            profile_url: __field3,
                            provider: __field4,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "evm_address",
                    "email",
                    "subject",
                    "profile_url",
                    "provider",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "UserSignupOrLoginRequest",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<
                            UserSignupOrLoginRequest,
                        >,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::default::Default for UserSignupOrLoginRequest {
        #[inline]
        fn default() -> UserSignupOrLoginRequest {
            UserSignupOrLoginRequest {
                evm_address: ::core::default::Default::default(),
                email: ::core::default::Default::default(),
                subject: ::core::default::Default::default(),
                profile_url: ::core::default::Default::default(),
                provider: ::core::default::Default::default(),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for UserSignupOrLoginRequest {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for UserSignupOrLoginRequest {
        #[inline]
        fn eq(&self, other: &UserSignupOrLoginRequest) -> bool {
            self.evm_address == other.evm_address && self.email == other.email
                && self.subject == other.subject && self.profile_url == other.profile_url
                && self.provider == other.provider
        }
    }
    impl ::validator::Validate for UserSignupOrLoginRequest {
        fn validate(&self) -> ::std::result::Result<(), ::validator::ValidationErrors> {
            use ::validator::ValidateArgs;
            self.validate_with_args(())
        }
    }
    impl<'v_a> ::validator::ValidateArgs<'v_a> for UserSignupOrLoginRequest {
        type Args = ();
        fn validate_with_args(
            &self,
            args: Self::Args,
        ) -> ::std::result::Result<(), ::validator::ValidationErrors> {
            use ::validator::ValidateEmail;
            use ::validator::ValidateUrl;
            let mut errors = ::validator::ValidationErrors::new();
            if !self.email.validate_email() {
                let mut err = ::validator::ValidationError::new("email");
                err.add_param(::std::borrow::Cow::from("value"), &self.email);
                errors.add("email", err);
            }
            if !self.profile_url.validate_url() {
                let mut err = ::validator::ValidationError::new("url");
                err.add_param(::std::borrow::Cow::from("value"), &self.profile_url);
                errors.add("profile_url", err);
            }
            if errors.is_empty() {
                ::std::result::Result::Ok(())
            } else {
                ::std::result::Result::Err(errors)
            }
        }
    }
    pub struct UserRegisterOrLoginRequest {
        pub evm_address: String,
        pub provider: UserAuthProvider,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for UserRegisterOrLoginRequest {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(
                f,
                "UserRegisterOrLoginRequest",
                "evm_address",
                &self.evm_address,
                "provider",
                &&self.provider,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for UserRegisterOrLoginRequest {
        #[inline]
        fn clone(&self) -> UserRegisterOrLoginRequest {
            UserRegisterOrLoginRequest {
                evm_address: ::core::clone::Clone::clone(&self.evm_address),
                provider: ::core::clone::Clone::clone(&self.provider),
            }
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for UserRegisterOrLoginRequest {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "UserRegisterOrLoginRequest",
                    false as usize + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "evm_address",
                    &self.evm_address,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "provider",
                    &self.provider,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for UserRegisterOrLoginRequest {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "evm_address" => _serde::__private::Ok(__Field::__field0),
                            "provider" => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"evm_address" => _serde::__private::Ok(__Field::__field0),
                            b"provider" => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<UserRegisterOrLoginRequest>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = UserRegisterOrLoginRequest;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct UserRegisterOrLoginRequest",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct UserRegisterOrLoginRequest with 2 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            UserAuthProvider,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct UserRegisterOrLoginRequest with 2 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(UserRegisterOrLoginRequest {
                            evm_address: __field0,
                            provider: __field1,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<UserAuthProvider> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "evm_address",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "provider",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            UserAuthProvider,
                                        >(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("evm_address")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("provider")?
                            }
                        };
                        _serde::__private::Ok(UserRegisterOrLoginRequest {
                            evm_address: __field0,
                            provider: __field1,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &["evm_address", "provider"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "UserRegisterOrLoginRequest",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<
                            UserRegisterOrLoginRequest,
                        >,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::default::Default for UserRegisterOrLoginRequest {
        #[inline]
        fn default() -> UserRegisterOrLoginRequest {
            UserRegisterOrLoginRequest {
                evm_address: ::core::default::Default::default(),
                provider: ::core::default::Default::default(),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for UserRegisterOrLoginRequest {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for UserRegisterOrLoginRequest {
        #[inline]
        fn eq(&self, other: &UserRegisterOrLoginRequest) -> bool {
            self.evm_address == other.evm_address && self.provider == other.provider
        }
    }
    impl ::validator::Validate for UserRegisterOrLoginRequest {
        fn validate(&self) -> ::std::result::Result<(), ::validator::ValidationErrors> {
            use ::validator::ValidateArgs;
            self.validate_with_args(())
        }
    }
    impl<'v_a> ::validator::ValidateArgs<'v_a> for UserRegisterOrLoginRequest {
        type Args = ();
        fn validate_with_args(
            &self,
            args: Self::Args,
        ) -> ::std::result::Result<(), ::validator::ValidationErrors> {
            let mut errors = ::validator::ValidationErrors::new();
            if errors.is_empty() {
                ::std::result::Result::Ok(())
            } else {
                ::std::result::Result::Err(errors)
            }
        }
    }
    impl UserClient {
        pub async fn act(&self, params: UserAction) -> crate::Result<User> {
            let path = ::alloc::__export::must_use({
                let res = ::alloc::fmt::format(format_args!("/v1/users"));
                res
            });
            let endpoint = ::alloc::__export::must_use({
                let res = ::alloc::fmt::format(
                    format_args!("{0}{1}", self.endpoint, path),
                );
                res
            });
            rest_api::post(&endpoint, params).await
        }
        pub async fn signup_or_login(
            &self,
            evm_address: String,
            email: String,
            subject: String,
            profile_url: String,
            provider: UserAuthProvider,
        ) -> crate::Result<UserResponse> {
            let path = ::alloc::__export::must_use({
                let res = ::alloc::fmt::format(format_args!("/v1/users"));
                res
            });
            let endpoint = ::alloc::__export::must_use({
                let res = ::alloc::fmt::format(
                    format_args!("{0}{1}", self.endpoint, path),
                );
                res
            });
            let req = UserAction::SignupOrLogin(UserSignupOrLoginRequest {
                evm_address,
                email,
                subject,
                profile_url,
                provider,
            });
            rest_api::post(&endpoint, req).await
        }
        pub async fn register_or_login(
            &self,
            evm_address: String,
            provider: UserAuthProvider,
        ) -> crate::Result<User> {
            let path = ::alloc::__export::must_use({
                let res = ::alloc::fmt::format(format_args!("/v1/users"));
                res
            });
            let endpoint = ::alloc::__export::must_use({
                let res = ::alloc::fmt::format(
                    format_args!("{0}{1}", self.endpoint, path),
                );
                res
            });
            let req = UserAction::RegisterOrLogin(UserRegisterOrLoginRequest {
                evm_address,
                provider,
            });
            rest_api::post(&endpoint, req).await
        }
    }
    pub struct UserSummary {
        pub id: i64,
        pub created_at: i64,
        pub updated_at: i64,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for UserSummary {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "UserSummary",
                "id",
                &self.id,
                "created_at",
                &self.created_at,
                "updated_at",
                &&self.updated_at,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for UserSummary {
        #[inline]
        fn clone(&self) -> UserSummary {
            UserSummary {
                id: ::core::clone::Clone::clone(&self.id),
                created_at: ::core::clone::Clone::clone(&self.created_at),
                updated_at: ::core::clone::Clone::clone(&self.updated_at),
            }
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for UserSummary {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "UserSummary",
                    false as usize + 1 + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "id",
                    &self.id,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "created_at",
                    &self.created_at,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "updated_at",
                    &self.updated_at,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for UserSummary {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "id" => _serde::__private::Ok(__Field::__field0),
                            "created_at" => _serde::__private::Ok(__Field::__field1),
                            "updated_at" => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"id" => _serde::__private::Ok(__Field::__field0),
                            b"created_at" => _serde::__private::Ok(__Field::__field1),
                            b"updated_at" => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<UserSummary>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = UserSummary;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct UserSummary",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            i64,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct UserSummary with 3 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            i64,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct UserSummary with 3 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match _serde::de::SeqAccess::next_element::<
                            i64,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct UserSummary with 3 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(UserSummary {
                            id: __field0,
                            created_at: __field1,
                            updated_at: __field2,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<i64> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<i64> = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<i64> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("id"),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<i64>(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "created_at",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<i64>(&mut __map)?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "updated_at",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<i64>(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("id")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("created_at")?
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("updated_at")?
                            }
                        };
                        _serde::__private::Ok(UserSummary {
                            id: __field0,
                            created_at: __field1,
                            updated_at: __field2,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "id",
                    "created_at",
                    "updated_at",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "UserSummary",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<UserSummary>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::default::Default for UserSummary {
        #[inline]
        fn default() -> UserSummary {
            UserSummary {
                id: ::core::default::Default::default(),
                created_at: ::core::default::Default::default(),
                updated_at: ::core::default::Default::default(),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for UserSummary {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for UserSummary {
        #[inline]
        fn eq(&self, other: &UserSummary) -> bool {
            self.id == other.id && self.created_at == other.created_at
                && self.updated_at == other.updated_at
        }
    }
    impl From<User> for UserSummary {
        fn from(item: User) -> Self {
            Self {
                id: item.id,
                created_at: item.created_at,
                updated_at: item.updated_at,
            }
        }
    }
    impl Into<User> for UserSummary {
        fn into(self) -> User {
            User {
                id: self.id,
                created_at: self.created_at,
                updated_at: self.updated_at,
                ..Default::default()
            }
        }
    }
    #[serde(rename_all = "kebab-case")]
    pub struct UserQuery {
        #[serde(deserialize_with = "parse_size_of_user_query", default)]
        pub size: usize,
        pub bookmark: Option<String>,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for UserQuery {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(
                f,
                "UserQuery",
                "size",
                &self.size,
                "bookmark",
                &&self.bookmark,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for UserQuery {
        #[inline]
        fn clone(&self) -> UserQuery {
            UserQuery {
                size: ::core::clone::Clone::clone(&self.size),
                bookmark: ::core::clone::Clone::clone(&self.bookmark),
            }
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for UserQuery {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "UserQuery",
                    false as usize + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "size",
                    &self.size,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "bookmark",
                    &self.bookmark,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for UserQuery {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "size" => _serde::__private::Ok(__Field::__field0),
                            "bookmark" => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"size" => _serde::__private::Ok(__Field::__field0),
                            b"bookmark" => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<UserQuery>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = UserQuery;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct UserQuery",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match {
                            #[doc(hidden)]
                            struct __DeserializeWith<'de> {
                                value: usize,
                                phantom: _serde::__private::PhantomData<UserQuery>,
                                lifetime: _serde::__private::PhantomData<&'de ()>,
                            }
                            #[automatically_derived]
                            impl<'de> _serde::Deserialize<'de>
                            for __DeserializeWith<'de> {
                                fn deserialize<__D>(
                                    __deserializer: __D,
                                ) -> _serde::__private::Result<Self, __D::Error>
                                where
                                    __D: _serde::Deserializer<'de>,
                                {
                                    _serde::__private::Ok(__DeserializeWith {
                                        value: parse_size_of_user_query(__deserializer)?,
                                        phantom: _serde::__private::PhantomData,
                                        lifetime: _serde::__private::PhantomData,
                                    })
                                }
                            }
                            _serde::__private::Option::map(
                                _serde::de::SeqAccess::next_element::<
                                    __DeserializeWith<'de>,
                                >(&mut __seq)?,
                                |__wrap| __wrap.value,
                            )
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                _serde::__private::Default::default()
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            Option<String>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct UserQuery with 2 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(UserQuery {
                            size: __field0,
                            bookmark: __field1,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<usize> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<Option<String>> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("size"),
                                        );
                                    }
                                    __field0 = _serde::__private::Some({
                                        #[doc(hidden)]
                                        struct __DeserializeWith<'de> {
                                            value: usize,
                                            phantom: _serde::__private::PhantomData<UserQuery>,
                                            lifetime: _serde::__private::PhantomData<&'de ()>,
                                        }
                                        #[automatically_derived]
                                        impl<'de> _serde::Deserialize<'de>
                                        for __DeserializeWith<'de> {
                                            fn deserialize<__D>(
                                                __deserializer: __D,
                                            ) -> _serde::__private::Result<Self, __D::Error>
                                            where
                                                __D: _serde::Deserializer<'de>,
                                            {
                                                _serde::__private::Ok(__DeserializeWith {
                                                    value: parse_size_of_user_query(__deserializer)?,
                                                    phantom: _serde::__private::PhantomData,
                                                    lifetime: _serde::__private::PhantomData,
                                                })
                                            }
                                        }
                                        match _serde::de::MapAccess::next_value::<
                                            __DeserializeWith<'de>,
                                        >(&mut __map) {
                                            _serde::__private::Ok(__wrapper) => __wrapper.value,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        }
                                    });
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "bookmark",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<String>,
                                        >(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::Default::default()
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("bookmark")?
                            }
                        };
                        _serde::__private::Ok(UserQuery {
                            size: __field0,
                            bookmark: __field1,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &["size", "bookmark"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "UserQuery",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<UserQuery>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::default::Default for UserQuery {
        #[inline]
        fn default() -> UserQuery {
            UserQuery {
                size: ::core::default::Default::default(),
                bookmark: ::core::default::Default::default(),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for UserQuery {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for UserQuery {
        #[inline]
        fn eq(&self, other: &UserQuery) -> bool {
            self.size == other.size && self.bookmark == other.bookmark
        }
    }
    impl std::fmt::Display for UserQuery {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let query = serde_urlencoded::to_string(&self).map_err(|_| std::fmt::Error)?;
            f.write_fmt(format_args!("{0}", query))
        }
    }
    impl ::validator::Validate for UserQuery {
        fn validate(&self) -> ::std::result::Result<(), ::validator::ValidationErrors> {
            use ::validator::ValidateArgs;
            self.validate_with_args(())
        }
    }
    impl<'v_a> ::validator::ValidateArgs<'v_a> for UserQuery {
        type Args = ();
        fn validate_with_args(
            &self,
            args: Self::Args,
        ) -> ::std::result::Result<(), ::validator::ValidationErrors> {
            let mut errors = ::validator::ValidationErrors::new();
            if errors.is_empty() {
                ::std::result::Result::Ok(())
            } else {
                ::std::result::Result::Err(errors)
            }
        }
    }
    pub fn parse_size_of_user_query<'de, D>(
        deserializer: D,
    ) -> std::result::Result<usize, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::Deserialize;
        let s: Option<String> = Option::deserialize(deserializer)?;
        s.unwrap_or_else(|| Default::default())
            .parse::<usize>()
            .map_err(serde::de::Error::custom)
    }
    impl UserQuery {
        pub fn new(size: usize) -> Self {
            Self { size, ..Self::default() }
        }
        pub fn with_bookmark(mut self, bookmark: String) -> Self {
            self.bookmark = Some(bookmark);
            self
        }
        pub fn with_page(mut self, page: usize) -> Self {
            self.bookmark = Some(page.to_string());
            self
        }
        /// Returns the size(i32) of the query
        pub fn size(&self) -> i32 {
            self.size as i32
        }
        pub fn page(&self) -> i32 {
            self.bookmark.as_ref().unwrap_or(&"1".to_string()).parse().unwrap_or(1)
        }
    }
    impl UserClient {}
    impl User {
        pub fn get_client(endpoint: &str) -> UserClient {
            UserClient {
                endpoint: endpoint.to_string(),
            }
        }
    }
    pub struct UserClient {
        pub endpoint: String,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for UserClient {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field1_finish(
                f,
                "UserClient",
                "endpoint",
                &&self.endpoint,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for UserClient {
        #[inline]
        fn clone(&self) -> UserClient {
            UserClient {
                endpoint: ::core::clone::Clone::clone(&self.endpoint),
            }
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for UserClient {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "UserClient",
                    false as usize + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "endpoint",
                    &self.endpoint,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for UserClient {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "endpoint" => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"endpoint" => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<UserClient>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = UserClient;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct UserClient",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct UserClient with 1 element",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(UserClient { endpoint: __field0 })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "endpoint",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("endpoint")?
                            }
                        };
                        _serde::__private::Ok(UserClient { endpoint: __field0 })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &["endpoint"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "UserClient",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<UserClient>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::default::Default for UserClient {
        #[inline]
        fn default() -> UserClient {
            UserClient {
                endpoint: ::core::default::Default::default(),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for UserClient {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for UserClient {
        #[inline]
        fn eq(&self, other: &UserClient) -> bool {
            self.endpoint == other.endpoint
        }
    }
    impl UserClient {
        pub async fn query(
            &self,
            params: UserQuery,
        ) -> crate::Result<by_types::QueryResponse<UserSummary>> {
            let path = ::alloc::__export::must_use({
                let res = ::alloc::fmt::format(format_args!("/v1/users"));
                res
            });
            let endpoint = ::alloc::__export::must_use({
                let res = ::alloc::fmt::format(
                    format_args!("{0}{1}", self.endpoint, path),
                );
                res
            });
            let query = ::alloc::__export::must_use({
                let res = ::alloc::fmt::format(
                    format_args!("{0}?{1}", endpoint, UserParam::Query(params)),
                );
                res
            });
            rest_api::get(&query).await
        }
        pub async fn get(&self, id: i64) -> crate::Result<User> {
            let path = ::alloc::__export::must_use({
                let res = ::alloc::fmt::format(format_args!("/v1/users"));
                res
            });
            let endpoint = ::alloc::__export::must_use({
                let res = ::alloc::fmt::format(
                    format_args!("{0}{1}/{2}", self.endpoint, path, id),
                );
                res
            });
            rest_api::get(&endpoint).await
        }
    }
    impl User {
        pub fn url() -> String {
            "/v1/users".to_string()
        }
    }
    pub struct UserReadAction {
        pub action: Option<UserReadActionType>,
        pub evm_address: Option<String>,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for UserReadAction {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(
                f,
                "UserReadAction",
                "action",
                &self.action,
                "evm_address",
                &&self.evm_address,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for UserReadAction {
        #[inline]
        fn clone(&self) -> UserReadAction {
            UserReadAction {
                action: ::core::clone::Clone::clone(&self.action),
                evm_address: ::core::clone::Clone::clone(&self.evm_address),
            }
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for UserReadAction {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "UserReadAction",
                    false as usize + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "action",
                    &self.action,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "evm_address",
                    &self.evm_address,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for UserReadAction {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "action" => _serde::__private::Ok(__Field::__field0),
                            "evm_address" => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"action" => _serde::__private::Ok(__Field::__field0),
                            b"evm_address" => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<UserReadAction>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = UserReadAction;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct UserReadAction",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            Option<UserReadActionType>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct UserReadAction with 2 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            Option<String>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct UserReadAction with 2 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(UserReadAction {
                            action: __field0,
                            evm_address: __field1,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<
                            Option<UserReadActionType>,
                        > = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<Option<String>> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("action"),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<UserReadActionType>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "evm_address",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<String>,
                                        >(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("action")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("evm_address")?
                            }
                        };
                        _serde::__private::Ok(UserReadAction {
                            action: __field0,
                            evm_address: __field1,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &["action", "evm_address"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "UserReadAction",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<UserReadAction>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::default::Default for UserReadAction {
        #[inline]
        fn default() -> UserReadAction {
            UserReadAction {
                action: ::core::default::Default::default(),
                evm_address: ::core::default::Default::default(),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for UserReadAction {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for UserReadAction {
        #[inline]
        fn eq(&self, other: &UserReadAction) -> bool {
            self.action == other.action && self.evm_address == other.evm_address
        }
    }
    impl std::fmt::Display for UserReadAction {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let query = serde_urlencoded::to_string(&self).map_err(|_| std::fmt::Error)?;
            f.write_fmt(format_args!("{0}", query))
        }
    }
    impl ::validator::Validate for UserReadAction {
        fn validate(&self) -> ::std::result::Result<(), ::validator::ValidationErrors> {
            use ::validator::ValidateArgs;
            self.validate_with_args(())
        }
    }
    impl<'v_a> ::validator::ValidateArgs<'v_a> for UserReadAction {
        type Args = ();
        fn validate_with_args(
            &self,
            args: Self::Args,
        ) -> ::std::result::Result<(), ::validator::ValidationErrors> {
            let mut errors = ::validator::ValidationErrors::new();
            if errors.is_empty() {
                ::std::result::Result::Ok(())
            } else {
                ::std::result::Result::Err(errors)
            }
        }
    }
    impl UserReadAction {
        pub fn new() -> Self {
            Self::default()
        }
        pub fn get_user_by_address(mut self, evm_address: String) -> Self {
            self.evm_address = Some(evm_address);
            self.action = Some(UserReadActionType::GetUserByAddress);
            self
        }
    }
    #[serde(rename_all = "kebab-case")]
    pub enum UserReadActionType {
        GetUserByAddress,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for UserReadActionType {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "GetUserByAddress")
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for UserReadActionType {
        #[inline]
        fn clone(&self) -> UserReadActionType {
            UserReadActionType::GetUserByAddress
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for UserReadActionType {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for UserReadActionType {
        #[inline]
        fn eq(&self, other: &UserReadActionType) -> bool {
            true
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for UserReadActionType {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    UserReadActionType::GetUserByAddress => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "UserReadActionType",
                            0u32,
                            "get-user-by-address",
                        )
                    }
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for UserReadActionType {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "variant identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::invalid_value(
                                        _serde::de::Unexpected::Unsigned(__value),
                                        &"variant index 0 <= i < 1",
                                    ),
                                )
                            }
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "get-user-by-address" => {
                                _serde::__private::Ok(__Field::__field0)
                            }
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"get-user-by-address" => {
                                _serde::__private::Ok(__Field::__field0)
                            }
                            _ => {
                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<UserReadActionType>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = UserReadActionType;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "enum UserReadActionType",
                        )
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match _serde::de::EnumAccess::variant(__data)? {
                            (__Field::__field0, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(UserReadActionType::GetUserByAddress)
                            }
                        }
                    }
                }
                #[doc(hidden)]
                const VARIANTS: &'static [&'static str] = &["get-user-by-address"];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "UserReadActionType",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<UserReadActionType>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    impl UserClient {
        pub async fn get_user_by_address(
            &self,
            evm_address: String,
        ) -> crate::Result<User> {
            let path = ::alloc::__export::must_use({
                let res = ::alloc::fmt::format(format_args!("/v1/users"));
                res
            });
            let endpoint = ::alloc::__export::must_use({
                let res = ::alloc::fmt::format(
                    format_args!("{0}{1}", self.endpoint, path),
                );
                res
            });
            let params = UserReadAction::new().get_user_by_address(evm_address);
            let query = ::alloc::__export::must_use({
                let res = ::alloc::fmt::format(
                    format_args!("{0}?{1}", endpoint, UserParam::Read(params)),
                );
                res
            });
            rest_api::get(&query).await
        }
    }
    #[serde(tag = "param-type", rename_all = "kebab-case")]
    pub enum UserParam {
        Query(UserQuery),
        Read(UserReadAction),
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for UserParam {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                UserParam::Query(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Query",
                        &__self_0,
                    )
                }
                UserParam::Read(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Read",
                        &__self_0,
                    )
                }
            }
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for UserParam {
        #[inline]
        fn clone(&self) -> UserParam {
            match self {
                UserParam::Query(__self_0) => {
                    UserParam::Query(::core::clone::Clone::clone(__self_0))
                }
                UserParam::Read(__self_0) => {
                    UserParam::Read(::core::clone::Clone::clone(__self_0))
                }
            }
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for UserParam {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    UserParam::Query(ref __field0) => {
                        _serde::__private::ser::serialize_tagged_newtype(
                            __serializer,
                            "UserParam",
                            "Query",
                            "param-type",
                            "query",
                            __field0,
                        )
                    }
                    UserParam::Read(ref __field0) => {
                        _serde::__private::ser::serialize_tagged_newtype(
                            __serializer,
                            "UserParam",
                            "Read",
                            "param-type",
                            "read",
                            __field0,
                        )
                    }
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for UserParam {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "variant identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::invalid_value(
                                        _serde::de::Unexpected::Unsigned(__value),
                                        &"variant index 0 <= i < 2",
                                    ),
                                )
                            }
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "query" => _serde::__private::Ok(__Field::__field0),
                            "read" => _serde::__private::Ok(__Field::__field1),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"query" => _serde::__private::Ok(__Field::__field0),
                            b"read" => _serde::__private::Ok(__Field::__field1),
                            _ => {
                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                const VARIANTS: &'static [&'static str] = &["query", "read"];
                let (__tag, __content) = _serde::Deserializer::deserialize_any(
                    __deserializer,
                    _serde::__private::de::TaggedContentVisitor::<
                        __Field,
                    >::new("param-type", "internally tagged enum UserParam"),
                )?;
                let __deserializer = _serde::__private::de::ContentDeserializer::<
                    __D::Error,
                >::new(__content);
                match __tag {
                    __Field::__field0 => {
                        _serde::__private::Result::map(
                            <UserQuery as _serde::Deserialize>::deserialize(
                                __deserializer,
                            ),
                            UserParam::Query,
                        )
                    }
                    __Field::__field1 => {
                        _serde::__private::Result::map(
                            <UserReadAction as _serde::Deserialize>::deserialize(
                                __deserializer,
                            ),
                            UserParam::Read,
                        )
                    }
                }
            }
        }
    };
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for UserParam {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for UserParam {
        #[inline]
        fn eq(&self, other: &UserParam) -> bool {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            let __arg1_discr = ::core::intrinsics::discriminant_value(other);
            __self_discr == __arg1_discr
                && match (self, other) {
                    (UserParam::Query(__self_0), UserParam::Query(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    (UserParam::Read(__self_0), UserParam::Read(__arg1_0)) => {
                        __self_0 == __arg1_0
                    }
                    _ => unsafe { ::core::intrinsics::unreachable() }
                }
        }
    }
    impl std::fmt::Display for UserParam {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let query = serde_urlencoded::to_string(&self).map_err(|_| std::fmt::Error)?;
            f.write_fmt(format_args!("{0}", query))
        }
    }
    #[serde(tag = "param_type")]
    #[serde(rename_all = "snake_case")]
    pub enum UserGetResponse {
        Query(by_types::QueryResponse<UserSummary>),
        Read(User),
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for UserGetResponse {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                UserGetResponse::Query(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Query",
                        &__self_0,
                    )
                }
                UserGetResponse::Read(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Read",
                        &__self_0,
                    )
                }
            }
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for UserGetResponse {
        #[inline]
        fn clone(&self) -> UserGetResponse {
            match self {
                UserGetResponse::Query(__self_0) => {
                    UserGetResponse::Query(::core::clone::Clone::clone(__self_0))
                }
                UserGetResponse::Read(__self_0) => {
                    UserGetResponse::Read(::core::clone::Clone::clone(__self_0))
                }
            }
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for UserGetResponse {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    UserGetResponse::Query(ref __field0) => {
                        _serde::__private::ser::serialize_tagged_newtype(
                            __serializer,
                            "UserGetResponse",
                            "Query",
                            "param_type",
                            "query",
                            __field0,
                        )
                    }
                    UserGetResponse::Read(ref __field0) => {
                        _serde::__private::ser::serialize_tagged_newtype(
                            __serializer,
                            "UserGetResponse",
                            "Read",
                            "param_type",
                            "read",
                            __field0,
                        )
                    }
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for UserGetResponse {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "variant identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::invalid_value(
                                        _serde::de::Unexpected::Unsigned(__value),
                                        &"variant index 0 <= i < 2",
                                    ),
                                )
                            }
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "query" => _serde::__private::Ok(__Field::__field0),
                            "read" => _serde::__private::Ok(__Field::__field1),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"query" => _serde::__private::Ok(__Field::__field0),
                            b"read" => _serde::__private::Ok(__Field::__field1),
                            _ => {
                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                const VARIANTS: &'static [&'static str] = &["query", "read"];
                let (__tag, __content) = _serde::Deserializer::deserialize_any(
                    __deserializer,
                    _serde::__private::de::TaggedContentVisitor::<
                        __Field,
                    >::new("param_type", "internally tagged enum UserGetResponse"),
                )?;
                let __deserializer = _serde::__private::de::ContentDeserializer::<
                    __D::Error,
                >::new(__content);
                match __tag {
                    __Field::__field0 => {
                        _serde::__private::Result::map(
                            <by_types::QueryResponse<
                                UserSummary,
                            > as _serde::Deserialize>::deserialize(__deserializer),
                            UserGetResponse::Query,
                        )
                    }
                    __Field::__field1 => {
                        _serde::__private::Result::map(
                            <User as _serde::Deserialize>::deserialize(__deserializer),
                            UserGetResponse::Read,
                        )
                    }
                }
            }
        }
    };
    impl ::validator::Validate for User {
        fn validate(&self) -> ::std::result::Result<(), ::validator::ValidationErrors> {
            use ::validator::ValidateArgs;
            self.validate_with_args(())
        }
    }
    impl<'v_a> ::validator::ValidateArgs<'v_a> for User {
        type Args = ();
        fn validate_with_args(
            &self,
            args: Self::Args,
        ) -> ::std::result::Result<(), ::validator::ValidationErrors> {
            use ::validator::ValidateEmail;
            use ::validator::ValidateUrl;
            let mut errors = ::validator::ValidationErrors::new();
            if !self.email.validate_email() {
                let mut err = ::validator::ValidationError::new("email");
                err.add_param(::std::borrow::Cow::from("value"), &self.email);
                errors.add("email", err);
            }
            if !self.profile_url.validate_url() {
                let mut err = ::validator::ValidationError::new("url");
                err.add_param(::std::borrow::Cow::from("value"), &self.profile_url);
                errors.add("profile_url", err);
            }
            if errors.is_empty() {
                ::std::result::Result::Ok(())
            } else {
                ::std::result::Result::Err(errors)
            }
        }
    }
    pub struct UserResponse {
        #[serde(flatten)]
        pub user: User,
        pub action: UserResponseType,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for UserResponse {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(
                f,
                "UserResponse",
                "user",
                &self.user,
                "action",
                &&self.action,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for UserResponse {
        #[inline]
        fn clone(&self) -> UserResponse {
            UserResponse {
                user: ::core::clone::Clone::clone(&self.user),
                action: ::core::clone::Clone::clone(&self.action),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for UserResponse {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for UserResponse {
        #[inline]
        fn eq(&self, other: &UserResponse) -> bool {
            self.user == other.user && self.action == other.action
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for UserResponse {
        #[inline]
        fn default() -> UserResponse {
            UserResponse {
                user: ::core::default::Default::default(),
                action: ::core::default::Default::default(),
            }
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for UserResponse {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_map(
                    __serializer,
                    _serde::__private::None,
                )?;
                _serde::Serialize::serialize(
                    &&self.user,
                    _serde::__private::ser::FlatMapSerializer(&mut __serde_state),
                )?;
                _serde::ser::SerializeMap::serialize_entry(
                    &mut __serde_state,
                    "action",
                    &self.action,
                )?;
                _serde::ser::SerializeMap::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for UserResponse {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field<'de> {
                    __field1,
                    __other(_serde::__private::de::Content<'de>),
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field<'de>;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_bool<__E>(
                        self,
                        __value: bool,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        _serde::__private::Ok(
                            __Field::__other(
                                _serde::__private::de::Content::Bool(__value),
                            ),
                        )
                    }
                    fn visit_i8<__E>(
                        self,
                        __value: i8,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        _serde::__private::Ok(
                            __Field::__other(_serde::__private::de::Content::I8(__value)),
                        )
                    }
                    fn visit_i16<__E>(
                        self,
                        __value: i16,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        _serde::__private::Ok(
                            __Field::__other(
                                _serde::__private::de::Content::I16(__value),
                            ),
                        )
                    }
                    fn visit_i32<__E>(
                        self,
                        __value: i32,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        _serde::__private::Ok(
                            __Field::__other(
                                _serde::__private::de::Content::I32(__value),
                            ),
                        )
                    }
                    fn visit_i64<__E>(
                        self,
                        __value: i64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        _serde::__private::Ok(
                            __Field::__other(
                                _serde::__private::de::Content::I64(__value),
                            ),
                        )
                    }
                    fn visit_u8<__E>(
                        self,
                        __value: u8,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        _serde::__private::Ok(
                            __Field::__other(_serde::__private::de::Content::U8(__value)),
                        )
                    }
                    fn visit_u16<__E>(
                        self,
                        __value: u16,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        _serde::__private::Ok(
                            __Field::__other(
                                _serde::__private::de::Content::U16(__value),
                            ),
                        )
                    }
                    fn visit_u32<__E>(
                        self,
                        __value: u32,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        _serde::__private::Ok(
                            __Field::__other(
                                _serde::__private::de::Content::U32(__value),
                            ),
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        _serde::__private::Ok(
                            __Field::__other(
                                _serde::__private::de::Content::U64(__value),
                            ),
                        )
                    }
                    fn visit_f32<__E>(
                        self,
                        __value: f32,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        _serde::__private::Ok(
                            __Field::__other(
                                _serde::__private::de::Content::F32(__value),
                            ),
                        )
                    }
                    fn visit_f64<__E>(
                        self,
                        __value: f64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        _serde::__private::Ok(
                            __Field::__other(
                                _serde::__private::de::Content::F64(__value),
                            ),
                        )
                    }
                    fn visit_char<__E>(
                        self,
                        __value: char,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        _serde::__private::Ok(
                            __Field::__other(
                                _serde::__private::de::Content::Char(__value),
                            ),
                        )
                    }
                    fn visit_unit<__E>(
                        self,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        _serde::__private::Ok(
                            __Field::__other(_serde::__private::de::Content::Unit),
                        )
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "action" => _serde::__private::Ok(__Field::__field1),
                            _ => {
                                let __value = _serde::__private::de::Content::String(
                                    _serde::__private::ToString::to_string(__value),
                                );
                                _serde::__private::Ok(__Field::__other(__value))
                            }
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"action" => _serde::__private::Ok(__Field::__field1),
                            _ => {
                                let __value = _serde::__private::de::Content::ByteBuf(
                                    __value.to_vec(),
                                );
                                _serde::__private::Ok(__Field::__other(__value))
                            }
                        }
                    }
                    fn visit_borrowed_str<__E>(
                        self,
                        __value: &'de str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "action" => _serde::__private::Ok(__Field::__field1),
                            _ => {
                                let __value = _serde::__private::de::Content::Str(__value);
                                _serde::__private::Ok(__Field::__other(__value))
                            }
                        }
                    }
                    fn visit_borrowed_bytes<__E>(
                        self,
                        __value: &'de [u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"action" => _serde::__private::Ok(__Field::__field1),
                            _ => {
                                let __value = _serde::__private::de::Content::Bytes(
                                    __value,
                                );
                                _serde::__private::Ok(__Field::__other(__value))
                            }
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field<'de> {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<UserResponse>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = UserResponse;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct UserResponse",
                        )
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field1: _serde::__private::Option<UserResponseType> = _serde::__private::None;
                        let mut __collect = _serde::__private::Vec::<
                            _serde::__private::Option<
                                (
                                    _serde::__private::de::Content,
                                    _serde::__private::de::Content,
                                ),
                            >,
                        >::new();
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("action"),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            UserResponseType,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__other(__name) => {
                                    __collect
                                        .push(
                                            _serde::__private::Some((
                                                __name,
                                                _serde::de::MapAccess::next_value(&mut __map)?,
                                            )),
                                        );
                                }
                            }
                        }
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("action")?
                            }
                        };
                        let __field0: User = _serde::de::Deserialize::deserialize(
                            _serde::__private::de::FlatMapDeserializer(
                                &mut __collect,
                                _serde::__private::PhantomData,
                            ),
                        )?;
                        _serde::__private::Ok(UserResponse {
                            user: __field0,
                            action: __field1,
                        })
                    }
                }
                _serde::Deserializer::deserialize_map(
                    __deserializer,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<UserResponse>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    pub enum UserResponseType {
        #[default]
        SignUp = 1,
        Login = 2,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for UserResponseType {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(
                f,
                match self {
                    UserResponseType::SignUp => "SignUp",
                    UserResponseType::Login => "Login",
                },
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for UserResponseType {
        #[inline]
        fn clone(&self) -> UserResponseType {
            match self {
                UserResponseType::SignUp => UserResponseType::SignUp,
                UserResponseType::Login => UserResponseType::Login,
            }
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Eq for UserResponseType {
        #[inline]
        #[doc(hidden)]
        #[coverage(off)]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for UserResponseType {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for UserResponseType {
        #[inline]
        fn eq(&self, other: &UserResponseType) -> bool {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            let __arg1_discr = ::core::intrinsics::discriminant_value(other);
            __self_discr == __arg1_discr
        }
    }
    impl std::convert::TryFrom<i32> for UserResponseType {
        type Error = String;
        fn try_from(value: i32) -> std::result::Result<Self, Self::Error> {
            match value {
                1 => Ok(UserResponseType::SignUp),
                2 => Ok(UserResponseType::Login),
                _ => {
                    Err(
                        ::alloc::__export::must_use({
                            let res = ::alloc::fmt::format(
                                format_args!("Invalid {0}: {1}", "UserResponseType", value),
                            );
                            res
                        }),
                    )
                }
            }
        }
    }
    impl std::convert::Into<i32> for UserResponseType {
        fn into(self) -> i32 {
            self as i32
        }
    }
    impl serde::Serialize for UserResponseType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            serializer.serialize_i32(self.clone() as i32)
        }
    }
    impl<'de> serde::Deserialize<'de> for UserResponseType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            let value = i32::deserialize(deserializer)?;
            Self::try_from(value)
                .map_err(|v| serde::de::Error::custom(
                    ::alloc::__export::must_use({
                        let res = ::alloc::fmt::format(
                            format_args!("Failed to parse ApiModel: {0}", v),
                        );
                        res
                    }),
                ))
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for UserResponseType {
        #[inline]
        fn default() -> UserResponseType {
            Self::SignUp
        }
    }
    pub enum UserAuthProvider {
        #[default]
        Kakao = 1,
        Google = 2,
        Kaia = 3,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for UserAuthProvider {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(
                f,
                match self {
                    UserAuthProvider::Kakao => "Kakao",
                    UserAuthProvider::Google => "Google",
                    UserAuthProvider::Kaia => "Kaia",
                },
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for UserAuthProvider {
        #[inline]
        fn clone(&self) -> UserAuthProvider {
            match self {
                UserAuthProvider::Kakao => UserAuthProvider::Kakao,
                UserAuthProvider::Google => UserAuthProvider::Google,
                UserAuthProvider::Kaia => UserAuthProvider::Kaia,
            }
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Eq for UserAuthProvider {
        #[inline]
        #[doc(hidden)]
        #[coverage(off)]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for UserAuthProvider {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for UserAuthProvider {
        #[inline]
        fn eq(&self, other: &UserAuthProvider) -> bool {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            let __arg1_discr = ::core::intrinsics::discriminant_value(other);
            __self_discr == __arg1_discr
        }
    }
    impl std::convert::TryFrom<i32> for UserAuthProvider {
        type Error = String;
        fn try_from(value: i32) -> std::result::Result<Self, Self::Error> {
            match value {
                1 => Ok(UserAuthProvider::Kakao),
                2 => Ok(UserAuthProvider::Google),
                3 => Ok(UserAuthProvider::Kaia),
                _ => {
                    Err(
                        ::alloc::__export::must_use({
                            let res = ::alloc::fmt::format(
                                format_args!("Invalid {0}: {1}", "UserAuthProvider", value),
                            );
                            res
                        }),
                    )
                }
            }
        }
    }
    impl std::convert::Into<i32> for UserAuthProvider {
        fn into(self) -> i32 {
            self as i32
        }
    }
    impl serde::Serialize for UserAuthProvider {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            serializer.serialize_i32(self.clone() as i32)
        }
    }
    impl<'de> serde::Deserialize<'de> for UserAuthProvider {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            let value = i32::deserialize(deserializer)?;
            Self::try_from(value)
                .map_err(|v| serde::de::Error::custom(
                    ::alloc::__export::must_use({
                        let res = ::alloc::fmt::format(
                            format_args!("Failed to parse ApiModel: {0}", v),
                        );
                        res
                    }),
                ))
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for UserAuthProvider {
        #[inline]
        fn default() -> UserAuthProvider {
            Self::Kakao
        }
    }
    /// UserContents is a generated struct that represents the model
    ///
    /// For making API calls related to this model, use `UserContents::get_client(endpoint: &str)`.
    /// It will returns UserContentsClient struct that implements the API calls.
    ///
    /// In server side, you can use `UserContents::get_repository()` to interact with the database.
    /// Recommend to use `UserContentsRepository` to insert or update the model.
    /// To query the model, use `UserContents::query_builder()`.
    /// For more detail, refer to the documentation of the query builder.
    /// UserContents is read-only model for users table with contents.
    pub struct UserContents {
        pub id: i64,
        pub profile_url: String,
        pub evm_address: String,
        pub contents: Vec<UserContent>,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for UserContents {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field4_finish(
                f,
                "UserContents",
                "id",
                &self.id,
                "profile_url",
                &self.profile_url,
                "evm_address",
                &self.evm_address,
                "contents",
                &&self.contents,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for UserContents {
        #[inline]
        fn clone(&self) -> UserContents {
            UserContents {
                id: ::core::clone::Clone::clone(&self.id),
                profile_url: ::core::clone::Clone::clone(&self.profile_url),
                evm_address: ::core::clone::Clone::clone(&self.evm_address),
                contents: ::core::clone::Clone::clone(&self.contents),
            }
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for UserContents {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "id" => _serde::__private::Ok(__Field::__field0),
                            "profile_url" => _serde::__private::Ok(__Field::__field1),
                            "evm_address" => _serde::__private::Ok(__Field::__field2),
                            "contents" => _serde::__private::Ok(__Field::__field3),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"id" => _serde::__private::Ok(__Field::__field0),
                            b"profile_url" => _serde::__private::Ok(__Field::__field1),
                            b"evm_address" => _serde::__private::Ok(__Field::__field2),
                            b"contents" => _serde::__private::Ok(__Field::__field3),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<UserContents>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = UserContents;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct UserContents",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            i64,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct UserContents with 4 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct UserContents with 4 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct UserContents with 4 elements",
                                    ),
                                );
                            }
                        };
                        let __field3 = match _serde::de::SeqAccess::next_element::<
                            Vec<UserContent>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        3usize,
                                        &"struct UserContents with 4 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(UserContents {
                            id: __field0,
                            profile_url: __field1,
                            evm_address: __field2,
                            contents: __field3,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<i64> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field3: _serde::__private::Option<Vec<UserContent>> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("id"),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<i64>(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "profile_url",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "evm_address",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field3 => {
                                    if _serde::__private::Option::is_some(&__field3) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "contents",
                                            ),
                                        );
                                    }
                                    __field3 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Vec<UserContent>,
                                        >(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("id")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("profile_url")?
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("evm_address")?
                            }
                        };
                        let __field3 = match __field3 {
                            _serde::__private::Some(__field3) => __field3,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("contents")?
                            }
                        };
                        _serde::__private::Ok(UserContents {
                            id: __field0,
                            profile_url: __field1,
                            evm_address: __field2,
                            contents: __field3,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "id",
                    "profile_url",
                    "evm_address",
                    "contents",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "UserContents",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<UserContents>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for UserContents {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "UserContents",
                    false as usize + 1 + 1 + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "id",
                    &self.id,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "profile_url",
                    &self.profile_url,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "evm_address",
                    &self.evm_address,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "contents",
                    &self.contents,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[automatically_derived]
    impl ::core::default::Default for UserContents {
        #[inline]
        fn default() -> UserContents {
            UserContents {
                id: ::core::default::Default::default(),
                profile_url: ::core::default::Default::default(),
                evm_address: ::core::default::Default::default(),
                contents: ::core::default::Default::default(),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for UserContents {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for UserContents {
        #[inline]
        fn eq(&self, other: &UserContents) -> bool {
            self.id == other.id && self.profile_url == other.profile_url
                && self.evm_address == other.evm_address
                && self.contents == other.contents
        }
    }
    #[serde(rename_all = "snake_case")]
    pub enum UserContentsAction {
        SignupOrLogin(UserContentsSignupOrLoginRequest),
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for UserContentsAction {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                UserContentsAction::SignupOrLogin(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "SignupOrLogin",
                        &__self_0,
                    )
                }
            }
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for UserContentsAction {
        #[inline]
        fn clone(&self) -> UserContentsAction {
            match self {
                UserContentsAction::SignupOrLogin(__self_0) => {
                    UserContentsAction::SignupOrLogin(
                        ::core::clone::Clone::clone(__self_0),
                    )
                }
            }
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for UserContentsAction {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    UserContentsAction::SignupOrLogin(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "UserContentsAction",
                            0u32,
                            "signup_or_login",
                            __field0,
                        )
                    }
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for UserContentsAction {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "variant identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::invalid_value(
                                        _serde::de::Unexpected::Unsigned(__value),
                                        &"variant index 0 <= i < 1",
                                    ),
                                )
                            }
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "signup_or_login" => _serde::__private::Ok(__Field::__field0),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"signup_or_login" => {
                                _serde::__private::Ok(__Field::__field0)
                            }
                            _ => {
                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<UserContentsAction>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = UserContentsAction;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "enum UserContentsAction",
                        )
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match _serde::de::EnumAccess::variant(__data)? {
                            (__Field::__field0, __variant) => {
                                _serde::__private::Result::map(
                                    _serde::de::VariantAccess::newtype_variant::<
                                        UserContentsSignupOrLoginRequest,
                                    >(__variant),
                                    UserContentsAction::SignupOrLogin,
                                )
                            }
                        }
                    }
                }
                #[doc(hidden)]
                const VARIANTS: &'static [&'static str] = &["signup_or_login"];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "UserContentsAction",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<UserContentsAction>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for UserContentsAction {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for UserContentsAction {
        #[inline]
        fn eq(&self, other: &UserContentsAction) -> bool {
            match (self, other) {
                (
                    UserContentsAction::SignupOrLogin(__self_0),
                    UserContentsAction::SignupOrLogin(__arg1_0),
                ) => __self_0 == __arg1_0,
            }
        }
    }
    pub struct UserContentsSignupOrLoginRequest {
        pub profile_url: String,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for UserContentsSignupOrLoginRequest {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field1_finish(
                f,
                "UserContentsSignupOrLoginRequest",
                "profile_url",
                &&self.profile_url,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for UserContentsSignupOrLoginRequest {
        #[inline]
        fn clone(&self) -> UserContentsSignupOrLoginRequest {
            UserContentsSignupOrLoginRequest {
                profile_url: ::core::clone::Clone::clone(&self.profile_url),
            }
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for UserContentsSignupOrLoginRequest {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "UserContentsSignupOrLoginRequest",
                    false as usize + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "profile_url",
                    &self.profile_url,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for UserContentsSignupOrLoginRequest {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "profile_url" => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"profile_url" => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<
                        UserContentsSignupOrLoginRequest,
                    >,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = UserContentsSignupOrLoginRequest;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct UserContentsSignupOrLoginRequest",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct UserContentsSignupOrLoginRequest with 1 element",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(UserContentsSignupOrLoginRequest {
                            profile_url: __field0,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "profile_url",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("profile_url")?
                            }
                        };
                        _serde::__private::Ok(UserContentsSignupOrLoginRequest {
                            profile_url: __field0,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &["profile_url"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "UserContentsSignupOrLoginRequest",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<
                            UserContentsSignupOrLoginRequest,
                        >,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::default::Default for UserContentsSignupOrLoginRequest {
        #[inline]
        fn default() -> UserContentsSignupOrLoginRequest {
            UserContentsSignupOrLoginRequest {
                profile_url: ::core::default::Default::default(),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for UserContentsSignupOrLoginRequest {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for UserContentsSignupOrLoginRequest {
        #[inline]
        fn eq(&self, other: &UserContentsSignupOrLoginRequest) -> bool {
            self.profile_url == other.profile_url
        }
    }
    impl UserContentsClient {
        pub async fn act(
            &self,
            params: UserContentsAction,
        ) -> crate::Result<UserContents> {
            let path = ::alloc::__export::must_use({
                let res = ::alloc::fmt::format(format_args!("/v1/users/contents"));
                res
            });
            let endpoint = ::alloc::__export::must_use({
                let res = ::alloc::fmt::format(
                    format_args!("{0}{1}", self.endpoint, path),
                );
                res
            });
            rest_api::post(&endpoint, params).await
        }
        pub async fn signup_or_login(
            &self,
            profile_url: String,
        ) -> crate::Result<UserContents> {
            let path = ::alloc::__export::must_use({
                let res = ::alloc::fmt::format(format_args!("/v1/users/contents"));
                res
            });
            let endpoint = ::alloc::__export::must_use({
                let res = ::alloc::fmt::format(
                    format_args!("{0}{1}", self.endpoint, path),
                );
                res
            });
            let req = UserContentsAction::SignupOrLogin(UserContentsSignupOrLoginRequest {
                profile_url,
            });
            rest_api::post(&endpoint, req).await
        }
    }
    pub struct UserContentsSummary {
        pub id: i64,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for UserContentsSummary {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field1_finish(
                f,
                "UserContentsSummary",
                "id",
                &&self.id,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for UserContentsSummary {
        #[inline]
        fn clone(&self) -> UserContentsSummary {
            UserContentsSummary {
                id: ::core::clone::Clone::clone(&self.id),
            }
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for UserContentsSummary {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "UserContentsSummary",
                    false as usize + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "id",
                    &self.id,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for UserContentsSummary {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "id" => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"id" => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<UserContentsSummary>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = UserContentsSummary;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct UserContentsSummary",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            i64,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct UserContentsSummary with 1 element",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(UserContentsSummary {
                            id: __field0,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<i64> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("id"),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<i64>(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("id")?
                            }
                        };
                        _serde::__private::Ok(UserContentsSummary {
                            id: __field0,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &["id"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "UserContentsSummary",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<UserContentsSummary>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::default::Default for UserContentsSummary {
        #[inline]
        fn default() -> UserContentsSummary {
            UserContentsSummary {
                id: ::core::default::Default::default(),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for UserContentsSummary {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for UserContentsSummary {
        #[inline]
        fn eq(&self, other: &UserContentsSummary) -> bool {
            self.id == other.id
        }
    }
    impl From<UserContents> for UserContentsSummary {
        fn from(item: UserContents) -> Self {
            Self { id: item.id }
        }
    }
    impl Into<UserContents> for UserContentsSummary {
        fn into(self) -> UserContents {
            UserContents {
                id: self.id,
                ..Default::default()
            }
        }
    }
    #[serde(rename_all = "kebab-case")]
    pub struct UserContentsQuery {
        #[serde(deserialize_with = "parse_size_of_user_contents_query", default)]
        pub size: usize,
        pub bookmark: Option<String>,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for UserContentsQuery {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(
                f,
                "UserContentsQuery",
                "size",
                &self.size,
                "bookmark",
                &&self.bookmark,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for UserContentsQuery {
        #[inline]
        fn clone(&self) -> UserContentsQuery {
            UserContentsQuery {
                size: ::core::clone::Clone::clone(&self.size),
                bookmark: ::core::clone::Clone::clone(&self.bookmark),
            }
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for UserContentsQuery {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "UserContentsQuery",
                    false as usize + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "size",
                    &self.size,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "bookmark",
                    &self.bookmark,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for UserContentsQuery {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "size" => _serde::__private::Ok(__Field::__field0),
                            "bookmark" => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"size" => _serde::__private::Ok(__Field::__field0),
                            b"bookmark" => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<UserContentsQuery>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = UserContentsQuery;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct UserContentsQuery",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match {
                            #[doc(hidden)]
                            struct __DeserializeWith<'de> {
                                value: usize,
                                phantom: _serde::__private::PhantomData<UserContentsQuery>,
                                lifetime: _serde::__private::PhantomData<&'de ()>,
                            }
                            #[automatically_derived]
                            impl<'de> _serde::Deserialize<'de>
                            for __DeserializeWith<'de> {
                                fn deserialize<__D>(
                                    __deserializer: __D,
                                ) -> _serde::__private::Result<Self, __D::Error>
                                where
                                    __D: _serde::Deserializer<'de>,
                                {
                                    _serde::__private::Ok(__DeserializeWith {
                                        value: parse_size_of_user_contents_query(__deserializer)?,
                                        phantom: _serde::__private::PhantomData,
                                        lifetime: _serde::__private::PhantomData,
                                    })
                                }
                            }
                            _serde::__private::Option::map(
                                _serde::de::SeqAccess::next_element::<
                                    __DeserializeWith<'de>,
                                >(&mut __seq)?,
                                |__wrap| __wrap.value,
                            )
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                _serde::__private::Default::default()
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            Option<String>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct UserContentsQuery with 2 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(UserContentsQuery {
                            size: __field0,
                            bookmark: __field1,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<usize> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<Option<String>> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("size"),
                                        );
                                    }
                                    __field0 = _serde::__private::Some({
                                        #[doc(hidden)]
                                        struct __DeserializeWith<'de> {
                                            value: usize,
                                            phantom: _serde::__private::PhantomData<UserContentsQuery>,
                                            lifetime: _serde::__private::PhantomData<&'de ()>,
                                        }
                                        #[automatically_derived]
                                        impl<'de> _serde::Deserialize<'de>
                                        for __DeserializeWith<'de> {
                                            fn deserialize<__D>(
                                                __deserializer: __D,
                                            ) -> _serde::__private::Result<Self, __D::Error>
                                            where
                                                __D: _serde::Deserializer<'de>,
                                            {
                                                _serde::__private::Ok(__DeserializeWith {
                                                    value: parse_size_of_user_contents_query(__deserializer)?,
                                                    phantom: _serde::__private::PhantomData,
                                                    lifetime: _serde::__private::PhantomData,
                                                })
                                            }
                                        }
                                        match _serde::de::MapAccess::next_value::<
                                            __DeserializeWith<'de>,
                                        >(&mut __map) {
                                            _serde::__private::Ok(__wrapper) => __wrapper.value,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        }
                                    });
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "bookmark",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<String>,
                                        >(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::Default::default()
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("bookmark")?
                            }
                        };
                        _serde::__private::Ok(UserContentsQuery {
                            size: __field0,
                            bookmark: __field1,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &["size", "bookmark"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "UserContentsQuery",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<UserContentsQuery>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::default::Default for UserContentsQuery {
        #[inline]
        fn default() -> UserContentsQuery {
            UserContentsQuery {
                size: ::core::default::Default::default(),
                bookmark: ::core::default::Default::default(),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for UserContentsQuery {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for UserContentsQuery {
        #[inline]
        fn eq(&self, other: &UserContentsQuery) -> bool {
            self.size == other.size && self.bookmark == other.bookmark
        }
    }
    impl std::fmt::Display for UserContentsQuery {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let query = serde_urlencoded::to_string(&self).map_err(|_| std::fmt::Error)?;
            f.write_fmt(format_args!("{0}", query))
        }
    }
    pub fn parse_size_of_user_contents_query<'de, D>(
        deserializer: D,
    ) -> std::result::Result<usize, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::Deserialize;
        let s: Option<String> = Option::deserialize(deserializer)?;
        s.unwrap_or_else(|| Default::default())
            .parse::<usize>()
            .map_err(serde::de::Error::custom)
    }
    impl UserContentsQuery {
        pub fn new(size: usize) -> Self {
            Self { size, ..Self::default() }
        }
        pub fn with_bookmark(mut self, bookmark: String) -> Self {
            self.bookmark = Some(bookmark);
            self
        }
        pub fn with_page(mut self, page: usize) -> Self {
            self.bookmark = Some(page.to_string());
            self
        }
        /// Returns the size(i32) of the query
        pub fn size(&self) -> i32 {
            self.size as i32
        }
        pub fn page(&self) -> i32 {
            self.bookmark.as_ref().unwrap_or(&"1".to_string()).parse().unwrap_or(1)
        }
    }
    impl UserContentsClient {}
    impl UserContents {
        pub fn get_client(endpoint: &str) -> UserContentsClient {
            UserContentsClient {
                endpoint: endpoint.to_string(),
            }
        }
    }
    pub struct UserContentsClient {
        pub endpoint: String,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for UserContentsClient {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field1_finish(
                f,
                "UserContentsClient",
                "endpoint",
                &&self.endpoint,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for UserContentsClient {
        #[inline]
        fn clone(&self) -> UserContentsClient {
            UserContentsClient {
                endpoint: ::core::clone::Clone::clone(&self.endpoint),
            }
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for UserContentsClient {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "UserContentsClient",
                    false as usize + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "endpoint",
                    &self.endpoint,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for UserContentsClient {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "endpoint" => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"endpoint" => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<UserContentsClient>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = UserContentsClient;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct UserContentsClient",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct UserContentsClient with 1 element",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(UserContentsClient {
                            endpoint: __field0,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "endpoint",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("endpoint")?
                            }
                        };
                        _serde::__private::Ok(UserContentsClient {
                            endpoint: __field0,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &["endpoint"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "UserContentsClient",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<UserContentsClient>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::default::Default for UserContentsClient {
        #[inline]
        fn default() -> UserContentsClient {
            UserContentsClient {
                endpoint: ::core::default::Default::default(),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for UserContentsClient {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for UserContentsClient {
        #[inline]
        fn eq(&self, other: &UserContentsClient) -> bool {
            self.endpoint == other.endpoint
        }
    }
    impl UserContentsClient {
        pub async fn query(
            &self,
            params: UserContentsQuery,
        ) -> crate::Result<by_types::QueryResponse<UserContentsSummary>> {
            let path = ::alloc::__export::must_use({
                let res = ::alloc::fmt::format(format_args!("/v1/users/contents"));
                res
            });
            let endpoint = ::alloc::__export::must_use({
                let res = ::alloc::fmt::format(
                    format_args!("{0}{1}", self.endpoint, path),
                );
                res
            });
            let query = ::alloc::__export::must_use({
                let res = ::alloc::fmt::format(
                    format_args!("{0}?{1}", endpoint, UserContentsParam::Query(params)),
                );
                res
            });
            rest_api::get(&query).await
        }
        pub async fn get(&self, id: i64) -> crate::Result<UserContents> {
            let path = ::alloc::__export::must_use({
                let res = ::alloc::fmt::format(format_args!("/v1/users/contents"));
                res
            });
            let endpoint = ::alloc::__export::must_use({
                let res = ::alloc::fmt::format(
                    format_args!("{0}{1}/{2}", self.endpoint, path, id),
                );
                res
            });
            rest_api::get(&endpoint).await
        }
    }
    impl UserContents {
        pub fn url() -> String {
            "/v1/users/contents".to_string()
        }
    }
    pub struct UserContentsReadAction {
        pub action: Option<UserContentsReadActionType>,
        pub evm_address: Option<String>,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for UserContentsReadAction {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(
                f,
                "UserContentsReadAction",
                "action",
                &self.action,
                "evm_address",
                &&self.evm_address,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for UserContentsReadAction {
        #[inline]
        fn clone(&self) -> UserContentsReadAction {
            UserContentsReadAction {
                action: ::core::clone::Clone::clone(&self.action),
                evm_address: ::core::clone::Clone::clone(&self.evm_address),
            }
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for UserContentsReadAction {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "UserContentsReadAction",
                    false as usize + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "action",
                    &self.action,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "evm_address",
                    &self.evm_address,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for UserContentsReadAction {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "action" => _serde::__private::Ok(__Field::__field0),
                            "evm_address" => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"action" => _serde::__private::Ok(__Field::__field0),
                            b"evm_address" => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<UserContentsReadAction>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = UserContentsReadAction;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct UserContentsReadAction",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            Option<UserContentsReadActionType>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct UserContentsReadAction with 2 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            Option<String>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct UserContentsReadAction with 2 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(UserContentsReadAction {
                            action: __field0,
                            evm_address: __field1,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<
                            Option<UserContentsReadActionType>,
                        > = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<Option<String>> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("action"),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<UserContentsReadActionType>,
                                        >(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "evm_address",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<String>,
                                        >(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("action")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("evm_address")?
                            }
                        };
                        _serde::__private::Ok(UserContentsReadAction {
                            action: __field0,
                            evm_address: __field1,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &["action", "evm_address"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "UserContentsReadAction",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<UserContentsReadAction>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::default::Default for UserContentsReadAction {
        #[inline]
        fn default() -> UserContentsReadAction {
            UserContentsReadAction {
                action: ::core::default::Default::default(),
                evm_address: ::core::default::Default::default(),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for UserContentsReadAction {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for UserContentsReadAction {
        #[inline]
        fn eq(&self, other: &UserContentsReadAction) -> bool {
            self.action == other.action && self.evm_address == other.evm_address
        }
    }
    impl std::fmt::Display for UserContentsReadAction {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let query = serde_urlencoded::to_string(&self).map_err(|_| std::fmt::Error)?;
            f.write_fmt(format_args!("{0}", query))
        }
    }
    impl UserContentsReadAction {
        pub fn new() -> Self {
            Self::default()
        }
        pub fn contents_by(mut self, evm_address: String) -> Self {
            self.evm_address = Some(evm_address);
            self.action = Some(UserContentsReadActionType::ContentsBy);
            self
        }
    }
    #[serde(rename_all = "kebab-case")]
    pub enum UserContentsReadActionType {
        ContentsBy,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for UserContentsReadActionType {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "ContentsBy")
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for UserContentsReadActionType {
        #[inline]
        fn clone(&self) -> UserContentsReadActionType {
            UserContentsReadActionType::ContentsBy
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for UserContentsReadActionType {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for UserContentsReadActionType {
        #[inline]
        fn eq(&self, other: &UserContentsReadActionType) -> bool {
            true
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for UserContentsReadActionType {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    UserContentsReadActionType::ContentsBy => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "UserContentsReadActionType",
                            0u32,
                            "contents-by",
                        )
                    }
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for UserContentsReadActionType {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "variant identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::invalid_value(
                                        _serde::de::Unexpected::Unsigned(__value),
                                        &"variant index 0 <= i < 1",
                                    ),
                                )
                            }
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "contents-by" => _serde::__private::Ok(__Field::__field0),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"contents-by" => _serde::__private::Ok(__Field::__field0),
                            _ => {
                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<UserContentsReadActionType>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = UserContentsReadActionType;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "enum UserContentsReadActionType",
                        )
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match _serde::de::EnumAccess::variant(__data)? {
                            (__Field::__field0, __variant) => {
                                _serde::de::VariantAccess::unit_variant(__variant)?;
                                _serde::__private::Ok(
                                    UserContentsReadActionType::ContentsBy,
                                )
                            }
                        }
                    }
                }
                #[doc(hidden)]
                const VARIANTS: &'static [&'static str] = &["contents-by"];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "UserContentsReadActionType",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<
                            UserContentsReadActionType,
                        >,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    impl UserContentsClient {
        pub async fn contents_by(
            &self,
            evm_address: String,
        ) -> crate::Result<UserContents> {
            let path = ::alloc::__export::must_use({
                let res = ::alloc::fmt::format(format_args!("/v1/users/contents"));
                res
            });
            let endpoint = ::alloc::__export::must_use({
                let res = ::alloc::fmt::format(
                    format_args!("{0}{1}", self.endpoint, path),
                );
                res
            });
            let params = UserContentsReadAction::new().contents_by(evm_address);
            let query = ::alloc::__export::must_use({
                let res = ::alloc::fmt::format(
                    format_args!("{0}?{1}", endpoint, UserContentsParam::Read(params)),
                );
                res
            });
            rest_api::get(&query).await
        }
    }
    #[serde(tag = "param-type", rename_all = "kebab-case")]
    pub enum UserContentsParam {
        Query(UserContentsQuery),
        Read(UserContentsReadAction),
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for UserContentsParam {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                UserContentsParam::Query(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Query",
                        &__self_0,
                    )
                }
                UserContentsParam::Read(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Read",
                        &__self_0,
                    )
                }
            }
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for UserContentsParam {
        #[inline]
        fn clone(&self) -> UserContentsParam {
            match self {
                UserContentsParam::Query(__self_0) => {
                    UserContentsParam::Query(::core::clone::Clone::clone(__self_0))
                }
                UserContentsParam::Read(__self_0) => {
                    UserContentsParam::Read(::core::clone::Clone::clone(__self_0))
                }
            }
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for UserContentsParam {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    UserContentsParam::Query(ref __field0) => {
                        _serde::__private::ser::serialize_tagged_newtype(
                            __serializer,
                            "UserContentsParam",
                            "Query",
                            "param-type",
                            "query",
                            __field0,
                        )
                    }
                    UserContentsParam::Read(ref __field0) => {
                        _serde::__private::ser::serialize_tagged_newtype(
                            __serializer,
                            "UserContentsParam",
                            "Read",
                            "param-type",
                            "read",
                            __field0,
                        )
                    }
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for UserContentsParam {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "variant identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::invalid_value(
                                        _serde::de::Unexpected::Unsigned(__value),
                                        &"variant index 0 <= i < 2",
                                    ),
                                )
                            }
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "query" => _serde::__private::Ok(__Field::__field0),
                            "read" => _serde::__private::Ok(__Field::__field1),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"query" => _serde::__private::Ok(__Field::__field0),
                            b"read" => _serde::__private::Ok(__Field::__field1),
                            _ => {
                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                const VARIANTS: &'static [&'static str] = &["query", "read"];
                let (__tag, __content) = _serde::Deserializer::deserialize_any(
                    __deserializer,
                    _serde::__private::de::TaggedContentVisitor::<
                        __Field,
                    >::new("param-type", "internally tagged enum UserContentsParam"),
                )?;
                let __deserializer = _serde::__private::de::ContentDeserializer::<
                    __D::Error,
                >::new(__content);
                match __tag {
                    __Field::__field0 => {
                        _serde::__private::Result::map(
                            <UserContentsQuery as _serde::Deserialize>::deserialize(
                                __deserializer,
                            ),
                            UserContentsParam::Query,
                        )
                    }
                    __Field::__field1 => {
                        _serde::__private::Result::map(
                            <UserContentsReadAction as _serde::Deserialize>::deserialize(
                                __deserializer,
                            ),
                            UserContentsParam::Read,
                        )
                    }
                }
            }
        }
    };
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for UserContentsParam {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for UserContentsParam {
        #[inline]
        fn eq(&self, other: &UserContentsParam) -> bool {
            let __self_discr = ::core::intrinsics::discriminant_value(self);
            let __arg1_discr = ::core::intrinsics::discriminant_value(other);
            __self_discr == __arg1_discr
                && match (self, other) {
                    (
                        UserContentsParam::Query(__self_0),
                        UserContentsParam::Query(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    (
                        UserContentsParam::Read(__self_0),
                        UserContentsParam::Read(__arg1_0),
                    ) => __self_0 == __arg1_0,
                    _ => unsafe { ::core::intrinsics::unreachable() }
                }
        }
    }
    impl std::fmt::Display for UserContentsParam {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let query = serde_urlencoded::to_string(&self).map_err(|_| std::fmt::Error)?;
            f.write_fmt(format_args!("{0}", query))
        }
    }
    #[serde(tag = "param_type")]
    #[serde(rename_all = "snake_case")]
    pub enum UserContentsGetResponse {
        Query(by_types::QueryResponse<UserContentsSummary>),
        Read(UserContents),
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for UserContentsGetResponse {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                UserContentsGetResponse::Query(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Query",
                        &__self_0,
                    )
                }
                UserContentsGetResponse::Read(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Read",
                        &__self_0,
                    )
                }
            }
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for UserContentsGetResponse {
        #[inline]
        fn clone(&self) -> UserContentsGetResponse {
            match self {
                UserContentsGetResponse::Query(__self_0) => {
                    UserContentsGetResponse::Query(::core::clone::Clone::clone(__self_0))
                }
                UserContentsGetResponse::Read(__self_0) => {
                    UserContentsGetResponse::Read(::core::clone::Clone::clone(__self_0))
                }
            }
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for UserContentsGetResponse {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    UserContentsGetResponse::Query(ref __field0) => {
                        _serde::__private::ser::serialize_tagged_newtype(
                            __serializer,
                            "UserContentsGetResponse",
                            "Query",
                            "param_type",
                            "query",
                            __field0,
                        )
                    }
                    UserContentsGetResponse::Read(ref __field0) => {
                        _serde::__private::ser::serialize_tagged_newtype(
                            __serializer,
                            "UserContentsGetResponse",
                            "Read",
                            "param_type",
                            "read",
                            __field0,
                        )
                    }
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for UserContentsGetResponse {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "variant identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::invalid_value(
                                        _serde::de::Unexpected::Unsigned(__value),
                                        &"variant index 0 <= i < 2",
                                    ),
                                )
                            }
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "query" => _serde::__private::Ok(__Field::__field0),
                            "read" => _serde::__private::Ok(__Field::__field1),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"query" => _serde::__private::Ok(__Field::__field0),
                            b"read" => _serde::__private::Ok(__Field::__field1),
                            _ => {
                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                const VARIANTS: &'static [&'static str] = &["query", "read"];
                let (__tag, __content) = _serde::Deserializer::deserialize_any(
                    __deserializer,
                    _serde::__private::de::TaggedContentVisitor::<
                        __Field,
                    >::new(
                        "param_type",
                        "internally tagged enum UserContentsGetResponse",
                    ),
                )?;
                let __deserializer = _serde::__private::de::ContentDeserializer::<
                    __D::Error,
                >::new(__content);
                match __tag {
                    __Field::__field0 => {
                        _serde::__private::Result::map(
                            <by_types::QueryResponse<
                                UserContentsSummary,
                            > as _serde::Deserialize>::deserialize(__deserializer),
                            UserContentsGetResponse::Query,
                        )
                    }
                    __Field::__field1 => {
                        _serde::__private::Result::map(
                            <UserContents as _serde::Deserialize>::deserialize(
                                __deserializer,
                            ),
                            UserContentsGetResponse::Read,
                        )
                    }
                }
            }
        }
    };
    /// UserContent is a generated struct that represents the model
    ///
    /// For making API calls related to this model, use `UserContent::get_client(endpoint: &str)`.
    /// It will returns UserContentClient struct that implements the API calls.
    ///
    /// In server side, you can use `UserContent::get_repository()` to interact with the database.
    /// Recommend to use `UserContentRepository` to insert or update the model.
    /// To query the model, use `UserContent::query_builder()`.
    /// For more detail, refer to the documentation of the query builder.
    pub struct UserContent {
        pub id: i64,
        pub created_at: i64,
        pub updated_at: i64,
        pub thumbnail_image: String,
        pub source: String,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for UserContent {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field5_finish(
                f,
                "UserContent",
                "id",
                &self.id,
                "created_at",
                &self.created_at,
                "updated_at",
                &self.updated_at,
                "thumbnail_image",
                &self.thumbnail_image,
                "source",
                &&self.source,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for UserContent {
        #[inline]
        fn clone(&self) -> UserContent {
            UserContent {
                id: ::core::clone::Clone::clone(&self.id),
                created_at: ::core::clone::Clone::clone(&self.created_at),
                updated_at: ::core::clone::Clone::clone(&self.updated_at),
                thumbnail_image: ::core::clone::Clone::clone(&self.thumbnail_image),
                source: ::core::clone::Clone::clone(&self.source),
            }
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for UserContent {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __field4,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            4u64 => _serde::__private::Ok(__Field::__field4),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "id" => _serde::__private::Ok(__Field::__field0),
                            "created_at" => _serde::__private::Ok(__Field::__field1),
                            "updated_at" => _serde::__private::Ok(__Field::__field2),
                            "thumbnail_image" => _serde::__private::Ok(__Field::__field3),
                            "source" => _serde::__private::Ok(__Field::__field4),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"id" => _serde::__private::Ok(__Field::__field0),
                            b"created_at" => _serde::__private::Ok(__Field::__field1),
                            b"updated_at" => _serde::__private::Ok(__Field::__field2),
                            b"thumbnail_image" => {
                                _serde::__private::Ok(__Field::__field3)
                            }
                            b"source" => _serde::__private::Ok(__Field::__field4),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<UserContent>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = UserContent;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct UserContent",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            i64,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct UserContent with 5 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            i64,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct UserContent with 5 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match _serde::de::SeqAccess::next_element::<
                            i64,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct UserContent with 5 elements",
                                    ),
                                );
                            }
                        };
                        let __field3 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        3usize,
                                        &"struct UserContent with 5 elements",
                                    ),
                                );
                            }
                        };
                        let __field4 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        4usize,
                                        &"struct UserContent with 5 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(UserContent {
                            id: __field0,
                            created_at: __field1,
                            updated_at: __field2,
                            thumbnail_image: __field3,
                            source: __field4,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<i64> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<i64> = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<i64> = _serde::__private::None;
                        let mut __field3: _serde::__private::Option<String> = _serde::__private::None;
                        let mut __field4: _serde::__private::Option<String> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("id"),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<i64>(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "created_at",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<i64>(&mut __map)?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "updated_at",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<i64>(&mut __map)?,
                                    );
                                }
                                __Field::__field3 => {
                                    if _serde::__private::Option::is_some(&__field3) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "thumbnail_image",
                                            ),
                                        );
                                    }
                                    __field3 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                __Field::__field4 => {
                                    if _serde::__private::Option::is_some(&__field4) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("source"),
                                        );
                                    }
                                    __field4 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("id")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("created_at")?
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("updated_at")?
                            }
                        };
                        let __field3 = match __field3 {
                            _serde::__private::Some(__field3) => __field3,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("thumbnail_image")?
                            }
                        };
                        let __field4 = match __field4 {
                            _serde::__private::Some(__field4) => __field4,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("source")?
                            }
                        };
                        _serde::__private::Ok(UserContent {
                            id: __field0,
                            created_at: __field1,
                            updated_at: __field2,
                            thumbnail_image: __field3,
                            source: __field4,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[
                    "id",
                    "created_at",
                    "updated_at",
                    "thumbnail_image",
                    "source",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "UserContent",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<UserContent>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for UserContent {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "UserContent",
                    false as usize + 1 + 1 + 1 + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "id",
                    &self.id,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "created_at",
                    &self.created_at,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "updated_at",
                    &self.updated_at,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "thumbnail_image",
                    &self.thumbnail_image,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "source",
                    &self.source,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[automatically_derived]
    impl ::core::default::Default for UserContent {
        #[inline]
        fn default() -> UserContent {
            UserContent {
                id: ::core::default::Default::default(),
                created_at: ::core::default::Default::default(),
                updated_at: ::core::default::Default::default(),
                thumbnail_image: ::core::default::Default::default(),
                source: ::core::default::Default::default(),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for UserContent {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for UserContent {
        #[inline]
        fn eq(&self, other: &UserContent) -> bool {
            self.id == other.id && self.created_at == other.created_at
                && self.updated_at == other.updated_at
                && self.thumbnail_image == other.thumbnail_image
                && self.source == other.source
        }
    }
    pub struct UserContentSummary {}
    #[automatically_derived]
    impl ::core::fmt::Debug for UserContentSummary {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "UserContentSummary")
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for UserContentSummary {
        #[inline]
        fn clone(&self) -> UserContentSummary {
            UserContentSummary {}
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for UserContentSummary {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "UserContentSummary",
                    false as usize,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for UserContentSummary {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<UserContentSummary>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = UserContentSummary;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct UserContentSummary",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        _: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        _serde::__private::Ok(UserContentSummary {})
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        _serde::__private::Ok(UserContentSummary {})
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "UserContentSummary",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<UserContentSummary>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::default::Default for UserContentSummary {
        #[inline]
        fn default() -> UserContentSummary {
            UserContentSummary {}
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for UserContentSummary {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for UserContentSummary {
        #[inline]
        fn eq(&self, other: &UserContentSummary) -> bool {
            true
        }
    }
    impl From<UserContent> for UserContentSummary {
        fn from(item: UserContent) -> Self {
            Self {}
        }
    }
    impl Into<UserContent> for UserContentSummary {
        fn into(self) -> UserContent {
            UserContent {
                ..Default::default()
            }
        }
    }
    #[serde(rename_all = "kebab-case")]
    pub struct UserContentQuery {
        #[serde(deserialize_with = "parse_size_of_user_content_query", default)]
        pub size: usize,
        pub bookmark: Option<String>,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for UserContentQuery {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(
                f,
                "UserContentQuery",
                "size",
                &self.size,
                "bookmark",
                &&self.bookmark,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for UserContentQuery {
        #[inline]
        fn clone(&self) -> UserContentQuery {
            UserContentQuery {
                size: ::core::clone::Clone::clone(&self.size),
                bookmark: ::core::clone::Clone::clone(&self.bookmark),
            }
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for UserContentQuery {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "UserContentQuery",
                    false as usize + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "size",
                    &self.size,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "bookmark",
                    &self.bookmark,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for UserContentQuery {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "size" => _serde::__private::Ok(__Field::__field0),
                            "bookmark" => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"size" => _serde::__private::Ok(__Field::__field0),
                            b"bookmark" => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<UserContentQuery>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = UserContentQuery;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct UserContentQuery",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match {
                            #[doc(hidden)]
                            struct __DeserializeWith<'de> {
                                value: usize,
                                phantom: _serde::__private::PhantomData<UserContentQuery>,
                                lifetime: _serde::__private::PhantomData<&'de ()>,
                            }
                            #[automatically_derived]
                            impl<'de> _serde::Deserialize<'de>
                            for __DeserializeWith<'de> {
                                fn deserialize<__D>(
                                    __deserializer: __D,
                                ) -> _serde::__private::Result<Self, __D::Error>
                                where
                                    __D: _serde::Deserializer<'de>,
                                {
                                    _serde::__private::Ok(__DeserializeWith {
                                        value: parse_size_of_user_content_query(__deserializer)?,
                                        phantom: _serde::__private::PhantomData,
                                        lifetime: _serde::__private::PhantomData,
                                    })
                                }
                            }
                            _serde::__private::Option::map(
                                _serde::de::SeqAccess::next_element::<
                                    __DeserializeWith<'de>,
                                >(&mut __seq)?,
                                |__wrap| __wrap.value,
                            )
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                _serde::__private::Default::default()
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            Option<String>,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct UserContentQuery with 2 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(UserContentQuery {
                            size: __field0,
                            bookmark: __field1,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<usize> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<Option<String>> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("size"),
                                        );
                                    }
                                    __field0 = _serde::__private::Some({
                                        #[doc(hidden)]
                                        struct __DeserializeWith<'de> {
                                            value: usize,
                                            phantom: _serde::__private::PhantomData<UserContentQuery>,
                                            lifetime: _serde::__private::PhantomData<&'de ()>,
                                        }
                                        #[automatically_derived]
                                        impl<'de> _serde::Deserialize<'de>
                                        for __DeserializeWith<'de> {
                                            fn deserialize<__D>(
                                                __deserializer: __D,
                                            ) -> _serde::__private::Result<Self, __D::Error>
                                            where
                                                __D: _serde::Deserializer<'de>,
                                            {
                                                _serde::__private::Ok(__DeserializeWith {
                                                    value: parse_size_of_user_content_query(__deserializer)?,
                                                    phantom: _serde::__private::PhantomData,
                                                    lifetime: _serde::__private::PhantomData,
                                                })
                                            }
                                        }
                                        match _serde::de::MapAccess::next_value::<
                                            __DeserializeWith<'de>,
                                        >(&mut __map) {
                                            _serde::__private::Ok(__wrapper) => __wrapper.value,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        }
                                    });
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "bookmark",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<
                                            Option<String>,
                                        >(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::Default::default()
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("bookmark")?
                            }
                        };
                        _serde::__private::Ok(UserContentQuery {
                            size: __field0,
                            bookmark: __field1,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &["size", "bookmark"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "UserContentQuery",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<UserContentQuery>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::default::Default for UserContentQuery {
        #[inline]
        fn default() -> UserContentQuery {
            UserContentQuery {
                size: ::core::default::Default::default(),
                bookmark: ::core::default::Default::default(),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for UserContentQuery {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for UserContentQuery {
        #[inline]
        fn eq(&self, other: &UserContentQuery) -> bool {
            self.size == other.size && self.bookmark == other.bookmark
        }
    }
    impl std::fmt::Display for UserContentQuery {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let query = serde_urlencoded::to_string(&self).map_err(|_| std::fmt::Error)?;
            f.write_fmt(format_args!("{0}", query))
        }
    }
    pub fn parse_size_of_user_content_query<'de, D>(
        deserializer: D,
    ) -> std::result::Result<usize, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use serde::Deserialize;
        let s: Option<String> = Option::deserialize(deserializer)?;
        s.unwrap_or_else(|| Default::default())
            .parse::<usize>()
            .map_err(serde::de::Error::custom)
    }
    impl UserContentQuery {
        pub fn new(size: usize) -> Self {
            Self { size, ..Self::default() }
        }
        pub fn with_bookmark(mut self, bookmark: String) -> Self {
            self.bookmark = Some(bookmark);
            self
        }
        pub fn with_page(mut self, page: usize) -> Self {
            self.bookmark = Some(page.to_string());
            self
        }
        /// Returns the size(i32) of the query
        pub fn size(&self) -> i32 {
            self.size as i32
        }
        pub fn page(&self) -> i32 {
            self.bookmark.as_ref().unwrap_or(&"1".to_string()).parse().unwrap_or(1)
        }
    }
    impl UserContentClient {}
    impl UserContent {
        pub fn get_client(endpoint: &str) -> UserContentClient {
            UserContentClient {
                endpoint: endpoint.to_string(),
            }
        }
    }
    pub struct UserContentClient {
        pub endpoint: String,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for UserContentClient {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field1_finish(
                f,
                "UserContentClient",
                "endpoint",
                &&self.endpoint,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for UserContentClient {
        #[inline]
        fn clone(&self) -> UserContentClient {
            UserContentClient {
                endpoint: ::core::clone::Clone::clone(&self.endpoint),
            }
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for UserContentClient {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "UserContentClient",
                    false as usize + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "endpoint",
                    &self.endpoint,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for UserContentClient {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "endpoint" => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"endpoint" => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<UserContentClient>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = UserContentClient;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct UserContentClient",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            String,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct UserContentClient with 1 element",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(UserContentClient {
                            endpoint: __field0,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "endpoint",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("endpoint")?
                            }
                        };
                        _serde::__private::Ok(UserContentClient {
                            endpoint: __field0,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &["endpoint"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "UserContentClient",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<UserContentClient>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::default::Default for UserContentClient {
        #[inline]
        fn default() -> UserContentClient {
            UserContentClient {
                endpoint: ::core::default::Default::default(),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for UserContentClient {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for UserContentClient {
        #[inline]
        fn eq(&self, other: &UserContentClient) -> bool {
            self.endpoint == other.endpoint
        }
    }
    impl UserContentClient {
        pub async fn query(
            &self,
            params: UserContentQuery,
        ) -> crate::Result<by_types::QueryResponse<UserContentSummary>> {
            let path = ::alloc::__export::must_use({
                let res = ::alloc::fmt::format(format_args!(""));
                res
            });
            let endpoint = ::alloc::__export::must_use({
                let res = ::alloc::fmt::format(
                    format_args!("{0}{1}", self.endpoint, path),
                );
                res
            });
            let query = ::alloc::__export::must_use({
                let res = ::alloc::fmt::format(
                    format_args!("{0}?{1}", endpoint, UserContentParam::Query(params)),
                );
                res
            });
            rest_api::get(&query).await
        }
        pub async fn get(&self, id: i64) -> crate::Result<UserContent> {
            let path = ::alloc::__export::must_use({
                let res = ::alloc::fmt::format(format_args!(""));
                res
            });
            let endpoint = ::alloc::__export::must_use({
                let res = ::alloc::fmt::format(
                    format_args!("{0}{1}/{2}", self.endpoint, path, id),
                );
                res
            });
            rest_api::get(&endpoint).await
        }
    }
    impl UserContent {
        pub fn url() -> String {
            "".to_string()
        }
    }
    pub struct UserContentReadAction {}
    #[automatically_derived]
    impl ::core::fmt::Debug for UserContentReadAction {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "UserContentReadAction")
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for UserContentReadAction {
        #[inline]
        fn clone(&self) -> UserContentReadAction {
            UserContentReadAction {}
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for UserContentReadAction {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "UserContentReadAction",
                    false as usize,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for UserContentReadAction {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<UserContentReadAction>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = UserContentReadAction;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct UserContentReadAction",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        _: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        _serde::__private::Ok(UserContentReadAction {})
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        _serde::__private::Ok(UserContentReadAction {})
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &[];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "UserContentReadAction",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<UserContentReadAction>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::default::Default for UserContentReadAction {
        #[inline]
        fn default() -> UserContentReadAction {
            UserContentReadAction {}
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for UserContentReadAction {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for UserContentReadAction {
        #[inline]
        fn eq(&self, other: &UserContentReadAction) -> bool {
            true
        }
    }
    impl std::fmt::Display for UserContentReadAction {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let query = serde_urlencoded::to_string(&self).map_err(|_| std::fmt::Error)?;
            f.write_fmt(format_args!("{0}", query))
        }
    }
    impl UserContentReadAction {
        pub fn new() -> Self {
            Self::default()
        }
    }
    impl UserContentClient {}
    #[serde(tag = "param-type", rename_all = "kebab-case")]
    pub enum UserContentParam {
        Query(UserContentQuery),
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for UserContentParam {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                UserContentParam::Query(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Query",
                        &__self_0,
                    )
                }
            }
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for UserContentParam {
        #[inline]
        fn clone(&self) -> UserContentParam {
            match self {
                UserContentParam::Query(__self_0) => {
                    UserContentParam::Query(::core::clone::Clone::clone(__self_0))
                }
            }
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for UserContentParam {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    UserContentParam::Query(ref __field0) => {
                        _serde::__private::ser::serialize_tagged_newtype(
                            __serializer,
                            "UserContentParam",
                            "Query",
                            "param-type",
                            "query",
                            __field0,
                        )
                    }
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for UserContentParam {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "variant identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::invalid_value(
                                        _serde::de::Unexpected::Unsigned(__value),
                                        &"variant index 0 <= i < 1",
                                    ),
                                )
                            }
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "query" => _serde::__private::Ok(__Field::__field0),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"query" => _serde::__private::Ok(__Field::__field0),
                            _ => {
                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                const VARIANTS: &'static [&'static str] = &["query"];
                let (__tag, __content) = _serde::Deserializer::deserialize_any(
                    __deserializer,
                    _serde::__private::de::TaggedContentVisitor::<
                        __Field,
                    >::new("param-type", "internally tagged enum UserContentParam"),
                )?;
                let __deserializer = _serde::__private::de::ContentDeserializer::<
                    __D::Error,
                >::new(__content);
                match __tag {
                    __Field::__field0 => {
                        _serde::__private::Result::map(
                            <UserContentQuery as _serde::Deserialize>::deserialize(
                                __deserializer,
                            ),
                            UserContentParam::Query,
                        )
                    }
                }
            }
        }
    };
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for UserContentParam {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for UserContentParam {
        #[inline]
        fn eq(&self, other: &UserContentParam) -> bool {
            match (self, other) {
                (
                    UserContentParam::Query(__self_0),
                    UserContentParam::Query(__arg1_0),
                ) => __self_0 == __arg1_0,
            }
        }
    }
    impl std::fmt::Display for UserContentParam {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let query = serde_urlencoded::to_string(&self).map_err(|_| std::fmt::Error)?;
            f.write_fmt(format_args!("{0}", query))
        }
    }
    #[serde(tag = "param_type")]
    #[serde(rename_all = "snake_case")]
    pub enum UserContentGetResponse {
        Query(by_types::QueryResponse<UserContent>),
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for UserContentGetResponse {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                UserContentGetResponse::Query(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Query",
                        &__self_0,
                    )
                }
            }
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for UserContentGetResponse {
        #[inline]
        fn clone(&self) -> UserContentGetResponse {
            match self {
                UserContentGetResponse::Query(__self_0) => {
                    UserContentGetResponse::Query(::core::clone::Clone::clone(__self_0))
                }
            }
        }
    }
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for UserContentGetResponse {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    UserContentGetResponse::Query(ref __field0) => {
                        _serde::__private::ser::serialize_tagged_newtype(
                            __serializer,
                            "UserContentGetResponse",
                            "Query",
                            "param_type",
                            "query",
                            __field0,
                        )
                    }
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for UserContentGetResponse {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "variant identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::invalid_value(
                                        _serde::de::Unexpected::Unsigned(__value),
                                        &"variant index 0 <= i < 1",
                                    ),
                                )
                            }
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "query" => _serde::__private::Ok(__Field::__field0),
                            _ => {
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"query" => _serde::__private::Ok(__Field::__field0),
                            _ => {
                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                _serde::__private::Err(
                                    _serde::de::Error::unknown_variant(__value, VARIANTS),
                                )
                            }
                        }
                    }
                }
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                const VARIANTS: &'static [&'static str] = &["query"];
                let (__tag, __content) = _serde::Deserializer::deserialize_any(
                    __deserializer,
                    _serde::__private::de::TaggedContentVisitor::<
                        __Field,
                    >::new("param_type", "internally tagged enum UserContentGetResponse"),
                )?;
                let __deserializer = _serde::__private::de::ContentDeserializer::<
                    __D::Error,
                >::new(__content);
                match __tag {
                    __Field::__field0 => {
                        _serde::__private::Result::map(
                            <by_types::QueryResponse<
                                UserContent,
                            > as _serde::Deserialize>::deserialize(__deserializer),
                            UserContentGetResponse::Query,
                        )
                    }
                }
            }
        }
    };
    impl Into<ContentSummary> for UserContent {
        fn into(self) -> ContentSummary {
            ContentSummary {
                id: self.id,
                created_at: self.created_at,
                updated_at: self.updated_at,
                thumbnail_image: self.thumbnail_image,
                source: self.source,
                ..Default::default()
            }
        }
    }
}
pub mod wallets {
    pub mod kaikas_wallet {
        use std::sync::Arc;
        use async_trait::async_trait;
        use ethers::{
            providers::{Http, Provider},
            types::Signature,
        };
        use crate::contracts::klaytn_transaction::KlaytnTransaction;
        use super::KaiaWallet;
        use crate::Result;
        pub struct KaikasWallet {
            pub chain_id: u64,
            pub address: String,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for KaikasWallet {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(
                    f,
                    "KaikasWallet",
                    "chain_id",
                    &self.chain_id,
                    "address",
                    &&self.address,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for KaikasWallet {
            #[inline]
            fn clone(&self) -> KaikasWallet {
                KaikasWallet {
                    chain_id: ::core::clone::Clone::clone(&self.chain_id),
                    address: ::core::clone::Clone::clone(&self.address),
                }
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for KaikasWallet {
            #[inline]
            fn default() -> KaikasWallet {
                KaikasWallet {
                    chain_id: ::core::default::Default::default(),
                    address: ::core::default::Default::default(),
                }
            }
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for KaikasWallet {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "chain_id" => _serde::__private::Ok(__Field::__field0),
                                "address" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"chain_id" => _serde::__private::Ok(__Field::__field0),
                                b"address" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<KaikasWallet>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = KaikasWallet;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct KaikasWallet",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                u64,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct KaikasWallet with 2 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct KaikasWallet with 2 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(KaikasWallet {
                                chain_id: __field0,
                                address: __field1,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<u64> = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<String> = _serde::__private::None;
                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "chain_id",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<u64>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "address",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("chain_id")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("address")?
                                }
                            };
                            _serde::__private::Ok(KaikasWallet {
                                chain_id: __field0,
                                address: __field1,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &["chain_id", "address"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "KaikasWallet",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<KaikasWallet>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for KaikasWallet {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "KaikasWallet",
                        false as usize + 1 + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "chain_id",
                        &self.chain_id,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "address",
                        &self.address,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for KaikasWallet {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for KaikasWallet {
            #[inline]
            fn eq(&self, other: &KaikasWallet) -> bool {
                self.chain_id == other.chain_id && self.address == other.address
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Eq for KaikasWallet {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<u64>;
                let _: ::core::cmp::AssertParamIsEq<String>;
            }
        }
        #[cfg(not(feature = "web"))]
        impl KaikasWallet {
            pub async fn new(_provider: Arc<Provider<Http>>) -> Result<Self> {
                Ok(Self::default())
            }
            pub async fn switch_chain(_chain_id: u64) -> Result<()> {
                Ok(())
            }
        }
        #[serde(rename_all = "camelCase")]
        pub struct SwitchChainRequest {
            chain_id: String,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for SwitchChainRequest {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field1_finish(
                    f,
                    "SwitchChainRequest",
                    "chain_id",
                    &&self.chain_id,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for SwitchChainRequest {
            #[inline]
            fn clone(&self) -> SwitchChainRequest {
                SwitchChainRequest {
                    chain_id: ::core::clone::Clone::clone(&self.chain_id),
                }
            }
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for SwitchChainRequest {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "chainId" => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"chainId" => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<SwitchChainRequest>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = SwitchChainRequest;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct SwitchChainRequest",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct SwitchChainRequest with 1 element",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(SwitchChainRequest {
                                chain_id: __field0,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "chainId",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("chainId")?
                                }
                            };
                            _serde::__private::Ok(SwitchChainRequest {
                                chain_id: __field0,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &["chainId"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "SwitchChainRequest",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<SwitchChainRequest>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for SwitchChainRequest {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "SwitchChainRequest",
                        false as usize + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "chainId",
                        &self.chain_id,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        pub struct KaikasRequest<T> {
            pub method: String,
            pub params: Vec<T>,
        }
        #[automatically_derived]
        impl<T: ::core::fmt::Debug> ::core::fmt::Debug for KaikasRequest<T> {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(
                    f,
                    "KaikasRequest",
                    "method",
                    &self.method,
                    "params",
                    &&self.params,
                )
            }
        }
        #[automatically_derived]
        impl<T: ::core::clone::Clone> ::core::clone::Clone for KaikasRequest<T> {
            #[inline]
            fn clone(&self) -> KaikasRequest<T> {
                KaikasRequest {
                    method: ::core::clone::Clone::clone(&self.method),
                    params: ::core::clone::Clone::clone(&self.params),
                }
            }
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de, T> _serde::Deserialize<'de> for KaikasRequest<T>
            where
                T: _serde::Deserialize<'de>,
            {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "method" => _serde::__private::Ok(__Field::__field0),
                                "params" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"method" => _serde::__private::Ok(__Field::__field0),
                                b"params" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de, T>
                    where
                        T: _serde::Deserialize<'de>,
                    {
                        marker: _serde::__private::PhantomData<KaikasRequest<T>>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de, T> _serde::de::Visitor<'de> for __Visitor<'de, T>
                    where
                        T: _serde::Deserialize<'de>,
                    {
                        type Value = KaikasRequest<T>;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct KaikasRequest",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct KaikasRequest with 2 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                Vec<T>,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct KaikasRequest with 2 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(KaikasRequest {
                                method: __field0,
                                params: __field1,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<Vec<T>> = _serde::__private::None;
                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("method"),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("params"),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<Vec<T>>(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("method")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("params")?
                                }
                            };
                            _serde::__private::Ok(KaikasRequest {
                                method: __field0,
                                params: __field1,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &["method", "params"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "KaikasRequest",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<KaikasRequest<T>>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<T> _serde::Serialize for KaikasRequest<T>
            where
                T: _serde::Serialize,
            {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "KaikasRequest",
                        false as usize + 1 + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "method",
                        &self.method,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "params",
                        &self.params,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[serde(rename_all = "camelCase")]
        pub struct Transaction {
            r#type: String,
            to: String,
            from: String,
            gas: String,
            gas_price: String,
            value: String,
            data: String,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for Transaction {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                let names: &'static _ = &[
                    "type",
                    "to",
                    "from",
                    "gas",
                    "gas_price",
                    "value",
                    "data",
                ];
                let values: &[&dyn ::core::fmt::Debug] = &[
                    &self.r#type,
                    &self.to,
                    &self.from,
                    &self.gas,
                    &self.gas_price,
                    &self.value,
                    &&self.data,
                ];
                ::core::fmt::Formatter::debug_struct_fields_finish(
                    f,
                    "Transaction",
                    names,
                    values,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for Transaction {
            #[inline]
            fn clone(&self) -> Transaction {
                Transaction {
                    r#type: ::core::clone::Clone::clone(&self.r#type),
                    to: ::core::clone::Clone::clone(&self.to),
                    from: ::core::clone::Clone::clone(&self.from),
                    gas: ::core::clone::Clone::clone(&self.gas),
                    gas_price: ::core::clone::Clone::clone(&self.gas_price),
                    value: ::core::clone::Clone::clone(&self.value),
                    data: ::core::clone::Clone::clone(&self.data),
                }
            }
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for Transaction {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __field3,
                        __field4,
                        __field5,
                        __field6,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                3u64 => _serde::__private::Ok(__Field::__field3),
                                4u64 => _serde::__private::Ok(__Field::__field4),
                                5u64 => _serde::__private::Ok(__Field::__field5),
                                6u64 => _serde::__private::Ok(__Field::__field6),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "type" => _serde::__private::Ok(__Field::__field0),
                                "to" => _serde::__private::Ok(__Field::__field1),
                                "from" => _serde::__private::Ok(__Field::__field2),
                                "gas" => _serde::__private::Ok(__Field::__field3),
                                "gasPrice" => _serde::__private::Ok(__Field::__field4),
                                "value" => _serde::__private::Ok(__Field::__field5),
                                "data" => _serde::__private::Ok(__Field::__field6),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"type" => _serde::__private::Ok(__Field::__field0),
                                b"to" => _serde::__private::Ok(__Field::__field1),
                                b"from" => _serde::__private::Ok(__Field::__field2),
                                b"gas" => _serde::__private::Ok(__Field::__field3),
                                b"gasPrice" => _serde::__private::Ok(__Field::__field4),
                                b"value" => _serde::__private::Ok(__Field::__field5),
                                b"data" => _serde::__private::Ok(__Field::__field6),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<Transaction>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = Transaction;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct Transaction",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct Transaction with 7 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct Transaction with 7 elements",
                                        ),
                                    );
                                }
                            };
                            let __field2 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            2usize,
                                            &"struct Transaction with 7 elements",
                                        ),
                                    );
                                }
                            };
                            let __field3 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            3usize,
                                            &"struct Transaction with 7 elements",
                                        ),
                                    );
                                }
                            };
                            let __field4 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            4usize,
                                            &"struct Transaction with 7 elements",
                                        ),
                                    );
                                }
                            };
                            let __field5 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            5usize,
                                            &"struct Transaction with 7 elements",
                                        ),
                                    );
                                }
                            };
                            let __field6 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            6usize,
                                            &"struct Transaction with 7 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(Transaction {
                                r#type: __field0,
                                to: __field1,
                                from: __field2,
                                gas: __field3,
                                gas_price: __field4,
                                value: __field5,
                                data: __field6,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<String> = _serde::__private::None;
                            let mut __field2: _serde::__private::Option<String> = _serde::__private::None;
                            let mut __field3: _serde::__private::Option<String> = _serde::__private::None;
                            let mut __field4: _serde::__private::Option<String> = _serde::__private::None;
                            let mut __field5: _serde::__private::Option<String> = _serde::__private::None;
                            let mut __field6: _serde::__private::Option<String> = _serde::__private::None;
                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("type"),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("to"),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field2 => {
                                        if _serde::__private::Option::is_some(&__field2) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("from"),
                                            );
                                        }
                                        __field2 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field3 => {
                                        if _serde::__private::Option::is_some(&__field3) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("gas"),
                                            );
                                        }
                                        __field3 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field4 => {
                                        if _serde::__private::Option::is_some(&__field4) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "gasPrice",
                                                ),
                                            );
                                        }
                                        __field4 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field5 => {
                                        if _serde::__private::Option::is_some(&__field5) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("value"),
                                            );
                                        }
                                        __field5 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field6 => {
                                        if _serde::__private::Option::is_some(&__field6) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("data"),
                                            );
                                        }
                                        __field6 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("type")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("to")?
                                }
                            };
                            let __field2 = match __field2 {
                                _serde::__private::Some(__field2) => __field2,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("from")?
                                }
                            };
                            let __field3 = match __field3 {
                                _serde::__private::Some(__field3) => __field3,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("gas")?
                                }
                            };
                            let __field4 = match __field4 {
                                _serde::__private::Some(__field4) => __field4,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("gasPrice")?
                                }
                            };
                            let __field5 = match __field5 {
                                _serde::__private::Some(__field5) => __field5,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("value")?
                                }
                            };
                            let __field6 = match __field6 {
                                _serde::__private::Some(__field6) => __field6,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("data")?
                                }
                            };
                            _serde::__private::Ok(Transaction {
                                r#type: __field0,
                                to: __field1,
                                from: __field2,
                                gas: __field3,
                                gas_price: __field4,
                                value: __field5,
                                data: __field6,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &[
                        "type",
                        "to",
                        "from",
                        "gas",
                        "gasPrice",
                        "value",
                        "data",
                    ];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "Transaction",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<Transaction>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for Transaction {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "Transaction",
                        false as usize + 1 + 1 + 1 + 1 + 1 + 1 + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "type",
                        &self.r#type,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "to",
                        &self.to,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "from",
                        &self.from,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "gas",
                        &self.gas,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "gasPrice",
                        &self.gas_price,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "value",
                        &self.value,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "data",
                        &self.data,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        impl KaiaWallet for KaikasWallet {
            fn address(&self) -> ethers::types::H160 {
                ::core::panicking::panic("not implemented")
            }
            #[cfg(not(feature = "web"))]
            #[allow(
                elided_named_lifetimes,
                clippy::async_yields_async,
                clippy::diverging_sub_expression,
                clippy::let_unit_value,
                clippy::needless_arbitrary_self_type,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn sign_transaction<'life0, 'life1, 'async_trait>(
                &'life0 self,
                _tx: &'life1 KlaytnTransaction,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<Output = Result<Signature>> + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                'life1: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    if let ::core::option::Option::Some(__ret) = ::core::option::Option::None::<
                        Result<Signature>,
                    > {
                        #[allow(unreachable_code)] return __ret;
                    }
                    let __self = self;
                    let __ret: Result<Signature> = {
                        ::core::panicking::panic("not implemented")
                    };
                    #[allow(unreachable_code)] __ret
                })
            }
        }
        #[serde(rename_all = "camelCase")]
        pub struct KaikasSignature {
            r: String,
            s: String,
            v: String,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for KaikasSignature {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field3_finish(
                    f,
                    "KaikasSignature",
                    "r",
                    &self.r,
                    "s",
                    &self.s,
                    "v",
                    &&self.v,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for KaikasSignature {
            #[inline]
            fn clone(&self) -> KaikasSignature {
                KaikasSignature {
                    r: ::core::clone::Clone::clone(&self.r),
                    s: ::core::clone::Clone::clone(&self.s),
                    v: ::core::clone::Clone::clone(&self.v),
                }
            }
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for KaikasSignature {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "r" => _serde::__private::Ok(__Field::__field0),
                                "s" => _serde::__private::Ok(__Field::__field1),
                                "v" => _serde::__private::Ok(__Field::__field2),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"r" => _serde::__private::Ok(__Field::__field0),
                                b"s" => _serde::__private::Ok(__Field::__field1),
                                b"v" => _serde::__private::Ok(__Field::__field2),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<KaikasSignature>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = KaikasSignature;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct KaikasSignature",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct KaikasSignature with 3 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct KaikasSignature with 3 elements",
                                        ),
                                    );
                                }
                            };
                            let __field2 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            2usize,
                                            &"struct KaikasSignature with 3 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(KaikasSignature {
                                r: __field0,
                                s: __field1,
                                v: __field2,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<String> = _serde::__private::None;
                            let mut __field2: _serde::__private::Option<String> = _serde::__private::None;
                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("r"),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("s"),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field2 => {
                                        if _serde::__private::Option::is_some(&__field2) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("v"),
                                            );
                                        }
                                        __field2 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("r")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("s")?
                                }
                            };
                            let __field2 = match __field2 {
                                _serde::__private::Some(__field2) => __field2,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("v")?
                                }
                            };
                            _serde::__private::Ok(KaikasSignature {
                                r: __field0,
                                s: __field1,
                                v: __field2,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &["r", "s", "v"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "KaikasSignature",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<KaikasSignature>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for KaikasSignature {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "KaikasSignature",
                        false as usize + 1 + 1 + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "r",
                        &self.r,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "s",
                        &self.s,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "v",
                        &self.v,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
    }
    pub mod local_fee_payer {
        use std::sync::Arc;
        use async_trait::async_trait;
        use ethers::{
            core::k256::ecdsa::SigningKey,
            middleware::{MiddlewareBuilder, SignerMiddleware},
            providers::{Http, Middleware, Provider},
            signers::{to_eip155_v, LocalWallet, Signer, Wallet},
            types::{Signature, H160},
        };
        use crate::contracts::klaytn_transaction::KlaytnTransaction;
        use super::KaiaWallet;
        use crate::Result;
        pub struct LocalFeePayer {
            pub wallet: LocalWallet,
            pub provider: SignerMiddleware<Arc<Provider<Http>>, Wallet<SigningKey>>,
            pub chain_id: u64,
            pub address: H160,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for LocalFeePayer {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field4_finish(
                    f,
                    "LocalFeePayer",
                    "wallet",
                    &self.wallet,
                    "provider",
                    &self.provider,
                    "chain_id",
                    &self.chain_id,
                    "address",
                    &&self.address,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for LocalFeePayer {
            #[inline]
            fn clone(&self) -> LocalFeePayer {
                LocalFeePayer {
                    wallet: ::core::clone::Clone::clone(&self.wallet),
                    provider: ::core::clone::Clone::clone(&self.provider),
                    chain_id: ::core::clone::Clone::clone(&self.chain_id),
                    address: ::core::clone::Clone::clone(&self.address),
                }
            }
        }
        impl LocalFeePayer {
            pub async fn new(
                address: &str,
                private_key: &str,
                provider: Arc<Provider<Http>>,
            ) -> Result<Self> {
                let chain_id = provider
                    .get_chainid()
                    .await
                    .map_err(|e| crate::Error::Klaytn(e.to_string()))?;
                let wallet = private_key
                    .parse::<LocalWallet>()
                    .expect("invalid fee payer private key")
                    .with_chain_id(chain_id.as_u64());
                let provider = provider.with_signer(wallet.clone());
                {
                    use ::tracing::__macro_support::Callsite as _;
                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "event packages/dto/src/wallets/local_fee_payer.rs:40",
                                "dto::wallets::local_fee_payer",
                                ::tracing::Level::DEBUG,
                                ::tracing_core::__macro_support::Option::Some(
                                    "packages/dto/src/wallets/local_fee_payer.rs",
                                ),
                                ::tracing_core::__macro_support::Option::Some(40u32),
                                ::tracing_core::__macro_support::Option::Some(
                                    "dto::wallets::local_fee_payer",
                                ),
                                ::tracing_core::field::FieldSet::new(
                                    &["message"],
                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                ),
                                ::tracing::metadata::Kind::EVENT,
                            )
                        };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                    let enabled = ::tracing::Level::DEBUG
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && ::tracing::Level::DEBUG
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            let interest = __CALLSITE.interest();
                            !interest.is_never()
                                && ::tracing::__macro_support::__is_enabled(
                                    __CALLSITE.metadata(),
                                    interest,
                                )
                        };
                    if enabled {
                        (|value_set: ::tracing::field::ValueSet| {
                            let meta = __CALLSITE.metadata();
                            ::tracing::Event::dispatch(meta, &value_set);
                        })({
                            #[allow(unused_imports)]
                            use ::tracing::field::{debug, display, Value};
                            let mut iter = __CALLSITE.metadata().fields().iter();
                            __CALLSITE
                                .metadata()
                                .fields()
                                .value_set(
                                    &[
                                        (
                                            &::tracing::__macro_support::Iterator::next(&mut iter)
                                                .expect("FieldSet corrupted (this is a bug)"),
                                            ::tracing::__macro_support::Option::Some(
                                                &format_args!("wallet chain id: {0:?}", wallet.chain_id())
                                                    as &dyn Value,
                                            ),
                                        ),
                                    ],
                                )
                        });
                    } else {
                    }
                };
                Ok(Self {
                    address: address.parse().expect("invalid feepayer address"),
                    wallet,
                    provider,
                    chain_id: chain_id.as_u64(),
                })
            }
        }
        impl KaiaWallet for LocalFeePayer {
            fn address(&self) -> H160 {
                self.wallet.address()
            }
            #[allow(
                elided_named_lifetimes,
                clippy::async_yields_async,
                clippy::diverging_sub_expression,
                clippy::let_unit_value,
                clippy::needless_arbitrary_self_type,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn sign_transaction<'life0, 'life1, 'async_trait>(
                &'life0 self,
                tx: &'life1 KlaytnTransaction,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<Output = Result<Signature>> + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                'life1: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    if let ::core::option::Option::Some(__ret) = ::core::option::Option::None::<
                        Result<Signature>,
                    > {
                        #[allow(unreachable_code)] return __ret;
                    }
                    let __self = self;
                    let __ret: Result<Signature> = {
                        let hash = tx
                            .to_sig_fee_payer_hash(__self.address(), __self.chain_id);
                        let mut signature = __self
                            .wallet
                            .sign_hash(hash)
                            .map_err(|e| crate::Error::Klaytn(e.to_string()))?;
                        signature.v = to_eip155_v(
                            signature.v as u8 - 27,
                            __self.chain_id,
                        );
                        {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "event packages/dto/src/wallets/local_fee_payer.rs:66",
                                        "dto::wallets::local_fee_payer",
                                        ::tracing::Level::DEBUG,
                                        ::tracing_core::__macro_support::Option::Some(
                                            "packages/dto/src/wallets/local_fee_payer.rs",
                                        ),
                                        ::tracing_core::__macro_support::Option::Some(66u32),
                                        ::tracing_core::__macro_support::Option::Some(
                                            "dto::wallets::local_fee_payer",
                                        ),
                                        ::tracing_core::field::FieldSet::new(
                                            &["message"],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::EVENT,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let enabled = ::tracing::Level::DEBUG
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && ::tracing::Level::DEBUG
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    let interest = __CALLSITE.interest();
                                    !interest.is_never()
                                        && ::tracing::__macro_support::__is_enabled(
                                            __CALLSITE.metadata(),
                                            interest,
                                        )
                                };
                            if enabled {
                                (|value_set: ::tracing::field::ValueSet| {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Event::dispatch(meta, &value_set);
                                })({
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                    __CALLSITE
                                        .metadata()
                                        .fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::tracing::__macro_support::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::tracing::__macro_support::Option::Some(
                                                        &format_args!("fee payer signature: {0:?}", signature)
                                                            as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                });
                            } else {
                            }
                        };
                        Ok(signature)
                    };
                    #[allow(unreachable_code)] __ret
                })
            }
        }
    }
    pub mod remote_fee_payer {
        use async_trait::async_trait;
        use ethers::types::{Signature, H160};
        use crate::{
            contracts::klaytn_transaction::KlaytnTransaction, FeePayerAddress,
            FeePayerSignature,
        };
        use super::KaiaWallet;
        pub struct RemoteFeePayer {
            pub endpoint: &'static str,
            pub address: H160,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for RemoteFeePayer {
            #[inline]
            fn clone(&self) -> RemoteFeePayer {
                let _: ::core::clone::AssertParamIsClone<&'static str>;
                let _: ::core::clone::AssertParamIsClone<H160>;
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for RemoteFeePayer {}
        impl RemoteFeePayer {
            pub async fn new(endpoint: &'static str) -> crate::Result<Self> {
                let ret = FeePayerAddress::get_client(endpoint).get_fee_payer().await?;
                Ok(Self {
                    endpoint,
                    address: ret.address.parse().expect("invalid feepayer address"),
                })
            }
        }
        impl KaiaWallet for RemoteFeePayer {
            fn address(&self) -> H160 {
                self.address
            }
            #[allow(
                elided_named_lifetimes,
                clippy::async_yields_async,
                clippy::diverging_sub_expression,
                clippy::let_unit_value,
                clippy::needless_arbitrary_self_type,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn sign_transaction<'life0, 'life1, 'async_trait>(
                &'life0 self,
                tx: &'life1 KlaytnTransaction,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = crate::Result<Signature>,
                    > + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                'life1: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    if let ::core::option::Option::Some(__ret) = ::core::option::Option::None::<
                        crate::Result<Signature>,
                    > {
                        #[allow(unreachable_code)] return __ret;
                    }
                    let __self = self;
                    let __ret: crate::Result<Signature> = {
                        let sig = FeePayerSignature::get_client(__self.endpoint)
                            .sign_transaction(tx.clone())
                            .await?;
                        Ok(sig.into())
                    };
                    #[allow(unreachable_code)] __ret
                })
            }
        }
    }
    pub mod wallet {
        use std::sync::Arc;
        use async_trait::async_trait;
        use ethers::{
            core::k256::ecdsa::SigningKey,
            middleware::{MiddlewareBuilder, SignerMiddleware},
            providers::{Http, Middleware, Provider},
            signers::{to_eip155_v, LocalWallet, Signer, Wallet},
            types::Signature,
        };
        use crate::contracts::klaytn_transaction::KlaytnTransaction;
        use super::KaiaWallet;
        use crate::Result;
        pub struct KaiaLocalWallet {
            pub wallet: LocalWallet,
            pub provider: SignerMiddleware<Arc<Provider<Http>>, Wallet<SigningKey>>,
            pub chain_id: u64,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for KaiaLocalWallet {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field3_finish(
                    f,
                    "KaiaLocalWallet",
                    "wallet",
                    &self.wallet,
                    "provider",
                    &self.provider,
                    "chain_id",
                    &&self.chain_id,
                )
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for KaiaLocalWallet {
            #[inline]
            fn clone(&self) -> KaiaLocalWallet {
                KaiaLocalWallet {
                    wallet: ::core::clone::Clone::clone(&self.wallet),
                    provider: ::core::clone::Clone::clone(&self.provider),
                    chain_id: ::core::clone::Clone::clone(&self.chain_id),
                }
            }
        }
        impl KaiaLocalWallet {
            pub async fn new(
                private_key: &str,
                provider: Arc<Provider<Http>>,
            ) -> Result<Self> {
                let chain_id = provider
                    .get_chainid()
                    .await
                    .map_err(|e| crate::Error::Klaytn(e.to_string()))?;
                let wallet = private_key
                    .parse::<LocalWallet>()?
                    .with_chain_id(chain_id.as_u64());
                let provider = provider.with_signer(wallet.clone());
                {
                    use ::tracing::__macro_support::Callsite as _;
                    static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "event packages/dto/src/wallets/wallet.rs:34",
                                "dto::wallets::wallet",
                                ::tracing::Level::DEBUG,
                                ::tracing_core::__macro_support::Option::Some(
                                    "packages/dto/src/wallets/wallet.rs",
                                ),
                                ::tracing_core::__macro_support::Option::Some(34u32),
                                ::tracing_core::__macro_support::Option::Some(
                                    "dto::wallets::wallet",
                                ),
                                ::tracing_core::field::FieldSet::new(
                                    &["message"],
                                    ::tracing_core::callsite::Identifier(&__CALLSITE),
                                ),
                                ::tracing::metadata::Kind::EVENT,
                            )
                        };
                        ::tracing::callsite::DefaultCallsite::new(&META)
                    };
                    let enabled = ::tracing::Level::DEBUG
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && ::tracing::Level::DEBUG
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            let interest = __CALLSITE.interest();
                            !interest.is_never()
                                && ::tracing::__macro_support::__is_enabled(
                                    __CALLSITE.metadata(),
                                    interest,
                                )
                        };
                    if enabled {
                        (|value_set: ::tracing::field::ValueSet| {
                            let meta = __CALLSITE.metadata();
                            ::tracing::Event::dispatch(meta, &value_set);
                        })({
                            #[allow(unused_imports)]
                            use ::tracing::field::{debug, display, Value};
                            let mut iter = __CALLSITE.metadata().fields().iter();
                            __CALLSITE
                                .metadata()
                                .fields()
                                .value_set(
                                    &[
                                        (
                                            &::tracing::__macro_support::Iterator::next(&mut iter)
                                                .expect("FieldSet corrupted (this is a bug)"),
                                            ::tracing::__macro_support::Option::Some(
                                                &format_args!("wallet chain id: {0:?}", wallet.chain_id())
                                                    as &dyn Value,
                                            ),
                                        ),
                                    ],
                                )
                        });
                    } else {
                    }
                };
                Ok(Self {
                    wallet,
                    provider,
                    chain_id: chain_id.as_u64(),
                })
            }
        }
        impl KaiaWallet for KaiaLocalWallet {
            fn address(&self) -> ethers::types::H160 {
                self.wallet.address()
            }
            #[allow(
                elided_named_lifetimes,
                clippy::async_yields_async,
                clippy::diverging_sub_expression,
                clippy::let_unit_value,
                clippy::needless_arbitrary_self_type,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn sign_transaction<'life0, 'life1, 'async_trait>(
                &'life0 self,
                tx: &'life1 KlaytnTransaction,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<Output = Result<Signature>> + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                'life1: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    if let ::core::option::Option::Some(__ret) = ::core::option::Option::None::<
                        Result<Signature>,
                    > {
                        #[allow(unreachable_code)] return __ret;
                    }
                    let __self = self;
                    let __ret: Result<Signature> = {
                        let hash = tx.to_sig_hash(__self.chain_id);
                        let mut signature = __self
                            .wallet
                            .sign_hash(hash)
                            .map_err(|e| crate::Error::Klaytn(e.to_string()))?;
                        signature.v = to_eip155_v(
                            signature.v as u8 - 27,
                            __self.chain_id,
                        );
                        {
                            use ::tracing::__macro_support::Callsite as _;
                            static __CALLSITE: ::tracing::callsite::DefaultCallsite = {
                                static META: ::tracing::Metadata<'static> = {
                                    ::tracing_core::metadata::Metadata::new(
                                        "event packages/dto/src/wallets/wallet.rs:58",
                                        "dto::wallets::wallet",
                                        ::tracing::Level::DEBUG,
                                        ::tracing_core::__macro_support::Option::Some(
                                            "packages/dto/src/wallets/wallet.rs",
                                        ),
                                        ::tracing_core::__macro_support::Option::Some(58u32),
                                        ::tracing_core::__macro_support::Option::Some(
                                            "dto::wallets::wallet",
                                        ),
                                        ::tracing_core::field::FieldSet::new(
                                            &["message"],
                                            ::tracing_core::callsite::Identifier(&__CALLSITE),
                                        ),
                                        ::tracing::metadata::Kind::EVENT,
                                    )
                                };
                                ::tracing::callsite::DefaultCallsite::new(&META)
                            };
                            let enabled = ::tracing::Level::DEBUG
                                <= ::tracing::level_filters::STATIC_MAX_LEVEL
                                && ::tracing::Level::DEBUG
                                    <= ::tracing::level_filters::LevelFilter::current()
                                && {
                                    let interest = __CALLSITE.interest();
                                    !interest.is_never()
                                        && ::tracing::__macro_support::__is_enabled(
                                            __CALLSITE.metadata(),
                                            interest,
                                        )
                                };
                            if enabled {
                                (|value_set: ::tracing::field::ValueSet| {
                                    let meta = __CALLSITE.metadata();
                                    ::tracing::Event::dispatch(meta, &value_set);
                                })({
                                    #[allow(unused_imports)]
                                    use ::tracing::field::{debug, display, Value};
                                    let mut iter = __CALLSITE.metadata().fields().iter();
                                    __CALLSITE
                                        .metadata()
                                        .fields()
                                        .value_set(
                                            &[
                                                (
                                                    &::tracing::__macro_support::Iterator::next(&mut iter)
                                                        .expect("FieldSet corrupted (this is a bug)"),
                                                    ::tracing::__macro_support::Option::Some(
                                                        &format_args!("signature: {0:?}", signature) as &dyn Value,
                                                    ),
                                                ),
                                            ],
                                        )
                                });
                            } else {
                            }
                        };
                        Ok(signature)
                    };
                    #[allow(unreachable_code)] __ret
                })
            }
        }
    }
    use async_trait::async_trait;
    use ethers::types::{Signature, H160};
    use crate::contracts::klaytn_transaction::KlaytnTransaction;
    pub trait KaiaWallet {
        fn address(&self) -> H160;
        #[must_use]
        #[allow(
            elided_named_lifetimes,
            clippy::type_complexity,
            clippy::type_repetition_in_bounds
        )]
        fn sign_transaction<'life0, 'life1, 'async_trait>(
            &'life0 self,
            tx: &'life1 KlaytnTransaction,
        ) -> ::core::pin::Pin<
            Box<
                dyn ::core::future::Future<
                    Output = Result<Signature, crate::Error>,
                > + 'async_trait,
            >,
        >
        where
            'life0: 'async_trait,
            'life1: 'async_trait,
            Self: 'async_trait;
    }
}
pub use asset::*;
pub use content::*;
pub use error::*;
pub use feepayer::*;
pub use user::*;
pub type Result<T> = std::result::Result<T, Error>;
